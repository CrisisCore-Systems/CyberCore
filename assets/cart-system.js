// @ts-nocheck
/**
 * CART-SYSTEM.JS
 * Advanced cart functionality for CyberCore theme
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.2.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * CartSystem
 * Advanced cart management system with quantum effects and 3D previews
 *
 * Key Features:
 * - AJAX cart updates without page refresh
 * - Cart drawer with animations
 * - Quantity adjustments and validations
 * - Cross-sell recommendations
 * - 3D product previews (when supported)
 * - Integration with NeuralBus events
 */
export class CartSystem {
  // Private static properties
  static #config = {
    cartDrawerSelector: '#cart-drawer',
    cartIconSelector: '#cart-icon-bubble',
    cartCountSelector: '#cart-count',
    cartTotalSelector: '#cart-total',
    addToCartFormSelector: 'form[action="/cart/add"]',
    cartItemSelector: '.cart-item',
    cartItemRemoveSelector: '.cart-item__remove',
    cartItemQuantitySelector: '.cart-item__quantity-input',
    cartDrawerToggleSelector: '[data-cart-toggle]',
    cartEmptyMessageSelector: '.cart-empty-message',
    cartErrorSelector: '.cart-error',
    cartRecommendationsSelector: '.cart-recommendations',
    cartCheckoutButtonSelector: '#cart-checkout-button',
    continueShoppingSelector: '#continue-shopping',
    cartPreviewContainerSelector: '#cart-preview-container',
    neuralSynced: true,
    useQuantumEffects: true,
    useHolographicPreviews: true, // Enabled since we now have the renderer
    debug: false,
    apiEndpoints: {
      cartAdd: '/cart/add.js',
      cartUpdate: '/cart/update.js',
      cartChange: '/cart/change.js',
      cartGet: '/cart.js',
      cartClear: '/cart/clear.js',
      recommendations: '/recommendations/products.json',
      productRecommendations: '/recommendations/products.json',
      recentlyViewed: '/recommendations/recently-viewed.json'
    },
    recommendationsConfig: {
      limit: 4,
      cacheExpiry: 300000, // 5 minutes in milliseconds
      fallbackCollection: 'featured-products', // Collection to use if no recommendations available
      trackAnalytics: true,
      personalizedRecommendations: true,
      useRecentlyViewed: true
    }
  };

  static #instance = null;
  static #eventHandlersAttached = false;
  static #isOpen = false;
  static #cartData = null;
  static #neuralBusConnected = false;
  static #neuralNonce = null;
  static #lastRequestTimestamp = 0;
  static #requestThrottleMs = 500;
  static #pendingRequests = [];
  static #holographicPreviewsSupported = false;
  static #holographicRenderer = null;
  static #activeProduct = null;
  static #productMutationRegistry = new Map();

  /**
   * Initialize the cart system
   * @param {Object} options - Configuration options
   * @returns {CartSystem} Cart system instance
   */
  static initialize(options = {}) {
    // Only initialize once
    if (this.#instance) return this.#instance;

    // Merge options with defaults
    this.#config = { ...this.#config, ...options };

    // Check for holographic preview support
    this.#checkHolographicSupport();

    // Attach event listeners
    this.#attachEventHandlers();

    // Initial cart fetch
    this.#fetchCart();

    // Connect to Neural Bus if available
    if (this.#config.neuralSynced) {
      this.#connectToNeuralBus();
    }

    // Log initialization
    if (this.#config.debug) {
      console.log('[CartSystem] Initialized with config:', this.#config);
    }

    this.#instance = this;
    return this.#instance;
  }

  /**
   * Get cart data
   * @returns {Promise<Object>} Cart data
   */
  static async getCart() {
    if (!this.#cartData) {
      await this.#fetchCart();
    }
    return this.#cartData;
  }

  /**
   * Add an item to the cart
   * @param {number|string} variantId - Product variant ID
   * @param {number} quantity - Quantity to add
   * @param {Object} properties - Line item properties
   * @returns {Promise<Object>} Updated cart
   */
  static async addToCart(variantId, quantity = 1, properties = {}) {
    try {
      this.#showLoading();

      const data = {
        id: variantId,
        quantity: quantity
      };

      // Add properties if provided
      if (Object.keys(properties).length > 0) {
        data.properties = properties;
      }

      // Send to Shopify API
      const response = await this.#postToShopify(this.#config.apiEndpoints.cartAdd, data);

      // Trigger quantum effect if enabled
      if (this.#config.useQuantumEffects) {
        this.#triggerQuantumEffect('add', variantId);
      }

      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('item:added', {
        item: response,
        cartData: this.#cartData
      });

      // Sync with NeuralBus
      this.#handleCartItemAdded({ item: response });

      // Show drawer
      this.openCartDrawer();

      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }

  /**
   * Update cart item quantity
   * @param {string} key - Cart item key
   * @param {number} quantity - New quantity
   * @returns {Promise<Object>} Updated cart
   */
  static async updateItemQuantity(key, quantity) {
    try {
      this.#showLoading();

      // Send to Shopify API
      const data = {
        id: key,
        quantity: quantity
      };

      await this.#postToShopify(this.#config.apiEndpoints.cartChange, data);

      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('item:updated', {
        key: key,
        quantity: quantity,
        cartData: this.#cartData
      });

      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }

  /**
   * Remove an item from the cart
   * @param {string} key - Cart item key
   * @returns {Promise<Object>} Updated cart
   */
  static async removeItem(key) {
    return this.updateItemQuantity(key, 0);
  }

  /**
   * Clear the cart
   * @returns {Promise<Object>} Empty cart
   */
  static async clearCart() {
    try {
      this.#showLoading();

      // Send to Shopify API
      await fetch(this.#config.apiEndpoints.cartClear, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('cart:cleared', { cartData: this.#cartData });

      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }

  /**
   * Open the cart drawer
   */
  static openCartDrawer() {
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!drawer) return;

    // Add open class to drawer
    drawer.classList.add('open');

    // Set body class for locking scroll
    document.body.classList.add('cart-drawer-open');

    // Update state
    this.#isOpen = true;

    // Trigger event
    this.#triggerEvent('drawer:opened', {});

    // Set up holographic preview if enabled and supported
    if (this.#config.useHolographicPreviews && this.#holographicPreviewsSupported) {
      this.#initHolographicPreviews();
    }

    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('drawer', 'open');
    }
  }

  /**
   * Close the cart drawer
   */
  static closeCartDrawer() {
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!drawer) return;

    // Remove open class from drawer
    drawer.classList.remove('open');

    // Remove body class for unlocking scroll
    document.body.classList.remove('cart-drawer-open');

    // Update state
    this.#isOpen = false;

    // Trigger event
    this.#triggerEvent('drawer:closed', {});

    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('drawer', 'close');
    }
  }

  /**
   * Toggle the cart drawer
   */
  static toggleCartDrawer() {
    if (this.#isOpen) {
      this.closeCartDrawer();
    } else {
      this.openCartDrawer();
    }
  }

  /**
   * Set active product for preview
   * @param {Object} product - Product data
   */
  static setActiveProduct(product) {
    this.#activeProduct = product;

    // Update holographic preview if enabled and drawer is open
    if (this.#config.useHolographicPreviews &&
        this.#holographicPreviewsSupported &&
        this.#isOpen) {
      this.#updateHolographicPreview(product);
    }
  }

  /**
   * Check if cart drawer is open
   * @returns {boolean} Is drawer open
   */
  static isCartDrawerOpen() {
    return this.#isOpen;
  }

  /**
   * Attach event handlers to cart elements
   * @private
   */
  static #attachEventHandlers() {
    if (this.#eventHandlersAttached) return;

    document.addEventListener('DOMContentLoaded', () => {
      // Toggle cart drawer
      const toggleButtons = document.querySelectorAll(this.#config.cartDrawerToggleSelector);
      toggleButtons.forEach(button => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          this.toggleCartDrawer();
        });
      });

      // Continue shopping button
      const continueButton = document.querySelector(this.#config.continueShoppingSelector);
      if (continueButton) {
        continueButton.addEventListener('click', (event) => {
          event.preventDefault();
          this.closeCartDrawer();
        });
      });

      // Add to cart forms
      const addToCartForms = document.querySelectorAll(this.#config.addToCartFormSelector);
      addToCartForms.forEach(form => {
        form.addEventListener('submit', this.#handleFormSubmit.bind(this));
      });

      // Document click to close drawer
      document.addEventListener('click', (event) => {
        if (this.#isOpen &&
            !event.target.closest(this.#config.cartDrawerSelector) &&
            !event.target.closest(this.#config.cartDrawerToggleSelector)) {
          this.closeCartDrawer();
        }
      });

      // Escape key to close drawer
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && this.#isOpen) {
          this.closeCartDrawer();
        }
      });

      // Attach delegated event handlers for dynamic cart content
      document.addEventListener('click', (event) => {
        // Remove item buttons
        if (event.target.closest(this.#config.cartItemRemoveSelector)) {
          event.preventDefault();
          const itemEl = event.target.closest(this.#config.cartItemSelector);
          const key = itemEl?.dataset.key;
          if (key) {
            this.removeItem(key);
          }
        }
      });

      // Quantity input change events
      document.addEventListener('change', (event) => {
        if (event.target.matches(this.#config.cartItemQuantitySelector)) {
          const itemEl = event.target.closest(this.#config.cartItemSelector);
          const key = itemEl?.dataset.key;
          const quantity = parseInt(event.target.value, 10);

          if (key && !isNaN(quantity)) {
            this.updateItemQuantity(key, quantity);
          }
        }
      });

      // Mark event handlers as attached
      this.#eventHandlersAttached = true;

      // Initial UI update
      this.#updateCartUI();
    });
  }

  /**
   * Handle form submission for add to cart
   * @private
   * @param {Event} event - Form submit event
   */
  static #handleFormSubmit(event) {
    event.preventDefault();

    const form = event.target;
    const formData = new FormData(form);

    // Extract form data
    const variantId = formData.get('id');
    const quantity = parseInt(formData.get('quantity') || 1, 10);

    // Extract properties from form
    const properties = {};
    for (const [key, value] of formData.entries()) {
      if (key.startsWith('properties[') && key.endsWith(']')) {
        const propName = key.slice(11, -1); // Extract property name from properties[name]
        properties[propName] = value;
      }
    }

    // Add to cart
    this.addToCart(variantId, quantity, properties)
      .catch(error => {
        console.error('Add to cart failed:', error);
      });
  }

  /**
   * Fetch current cart data from Shopify
   * @private
   * @returns {Promise<Object>} Cart data
   */
  static async #fetchCart() {
    try {
      const response = await fetch(this.#config.apiEndpoints.cartGet, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Cart fetch failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      this.#cartData = data;

      return data;
    } catch (error) {
      console.error('Error fetching cart:', error);
      throw error;
    }
  }

  /**
   * Post data to Shopify API
   * @private
   * @param {string} endpoint - API endpoint
   * @param {Object} data - Request data
   * @returns {Promise<Object>} Response data
   */
  static async #postToShopify(endpoint, data) {
    // Throttle requests to prevent API rate limiting
    const now = Date.now();
    if (now - this.#lastRequestTimestamp < this.#requestThrottleMs) {
      // Queue the request
      return new Promise((resolve, reject) => {
        this.#pendingRequests.push({ endpoint, data, resolve, reject });

        // Process queue after throttle time
        setTimeout(() => {
          this.#processRequestQueue();
        }, this.#requestThrottleMs);
      });
    }

    this.#lastRequestTimestamp = now;

    // Execute the request
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`Request failed: ${response.status} ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Error posting to ${endpoint}:`, error);
      throw error;
    }
  }

  /**
   * Process the queue of pending requests
   * @private
   */
  static #processRequestQueue() {
    if (this.#pendingRequests.length === 0) return;

    // Get the next request
    const { endpoint, data, resolve, reject } = this.#pendingRequests.shift();

    // Update timestamp
    this.#lastRequestTimestamp = Date.now();

    // Execute the request
    this.#postToShopify(endpoint, data)
      .then(resolve)
      .catch(reject)
      .finally(() => {
        // Schedule processing of next request
        if (this.#pendingRequests.length > 0) {
          setTimeout(() => {
            this.#processRequestQueue();
          }, this.#requestThrottleMs);
        }
      });
  }

  /**
   * Update the cart UI
   * @private
   */
  static #updateCartUI() {
    if (!this.#cartData) return;

    // Update cart count
    const cartCountEl = document.querySelector(this.#config.cartCountSelector);
    if (cartCountEl) {
      cartCountEl.textContent = this.#cartData.item_count;

      // Toggle visibility based on item count
      if (this.#cartData.item_count > 0) {
        cartCountEl.classList.remove('hidden');
      } else {
        cartCountEl.classList.add('hidden');
      }
    }

    // Update cart total
    const cartTotalEl = document.querySelector(this.#config.cartTotalSelector);
    if (cartTotalEl) {
      // Format price with currency
      const formattedPrice = this.#formatMoney(this.#cartData.total_price);
      cartTotalEl.textContent = formattedPrice;
    }

    // Toggle empty cart message
    const emptyMessageEl = document.querySelector(this.#config.cartEmptyMessageSelector);
    if (emptyMessageEl) {
      if (this.#cartData.item_count === 0) {
        emptyMessageEl.classList.remove('hidden');
      } else {
        emptyMessageEl.classList.add('hidden');
      }
    }

    // Update cart items
    this.#renderCartItems();

    // Update recommendations if any
    this.#updateRecommendations();
  }

  /**
   * Render cart items
   * @private
   */
  static #renderCartItems() {
    const cartItemContainer = document.querySelector('#cart-items');
    if (!cartItemContainer || !this.#cartData) return;

    // Clear existing items
    cartItemContainer.innerHTML = '';

    // Render each item
    this.#cartData.items.forEach(item => {
      const itemElement = document.createElement('div');
      itemElement.className = 'cart-item';
      itemElement.dataset.key = item.key;

      // Escape special characters in HTML to prevent XSS
      const escapedTitle = this.#escapeHTML(item.title);
      const escapedVariantTitle = this.#escapeHTML(item.variant_title || '');
      const formattedPrice = this.#formatMoney(item.final_line_price);

      itemElement.innerHTML = `
        <div class="cart-item__image">
          <img src="${item.image || '/assets/no-image.jpg'}" alt="${escapedTitle}">
        </div>
        <div class="cart-item__content">
          <div class="cart-item__title">${escapedTitle}</div>
          ${escapedVariantTitle ? `<div class="cart-item__variant">${escapedVariantTitle}</div>` : ''}
          <div class="cart-item__price">${formattedPrice}</div>
          <div class="cart-item__quantity">
            <label for="quantity-${item.key}">Qty:</label>
            <input
              type="number"
              id="quantity-${item.key}"
              class="cart-item__quantity-input"
              value="${item.quantity}"
              min="1"
              data-item-key="${item.key}"
            >
          </div>
        </div>
        <button class="cart-item__remove" aria-label="Remove item">×</button>
      `;

      cartItemContainer.appendChild(itemElement);

      // Apply quantum effects if enabled
      if (this.#config.useQuantumEffects) {
        this.#applyItemQuantumEffect(itemElement);
      }
    });
  }

  /**
   * Update product recommendations
   * @private
   */
  static #updateRecommendations() {
    const recommendationsContainer = document.querySelector(this.#config.cartRecommendationsSelector);
    if (!recommendationsContainer) {
      return;
    }

    // If cart is empty and we don't want recommendations, clear and return
    if (!this.#cartData || this.#cartData.item_count === 0) {
      // If we want to show recommendations anyway (fallback to featured collection)
      if (!this.#config.recommendationsConfig.fallbackCollection) {
        recommendationsContainer.innerHTML = '';
        return;
      }
    }

    // Show loading state
    recommendationsContainer.innerHTML = '<div class="recommendations-loading">Loading recommendations...</div>';

    // Check for cached recommendations
    const cacheKey = this.#getRecommendationsCacheKey();
    const cachedRecommendations = this.#getRecommendationsFromCache(cacheKey);

    if (cachedRecommendations) {
      this.#renderRecommendations(cachedRecommendations);
      return;
    }

    // Strategy pattern: determine best source of recommendations
    let recommendationsPromise;

    // 1. Cart-based recommendations (if cart has items)
    if (this.#cartData && this.#cartData.item_count > 0) {
      const currentItems = this.#cartData.items.map(item => item.product_id);
      recommendationsPromise = this.#fetchCartBasedRecommendations(currentItems);
    }
    // 2. Recently viewed recommendations (if enabled and no cart items)
    else if (this.#config.recommendationsConfig.useRecentlyViewed) {
      recommendationsPromise = this.#fetchRecentlyViewedRecommendations();
    }
    // 3. Fallback to collection-based recommendations
    else if (this.#config.recommendationsConfig.fallbackCollection) {
      recommendationsPromise = this.#fetchCollectionRecommendations(this.#config.recommendationsConfig.fallbackCollection);
    }
    // 4. No recommendations possible
    else {
      recommendationsContainer.innerHTML = '';
      return;
    }

    // Process recommendations
    recommendationsPromise
      .then(data => {
        // Cache valid results
        if (data && data.products && data.products.length > 0) {
          this.#saveRecommendationsToCache(cacheKey, data);
        }

        this.#renderRecommendations(data);

        // Track analytics
        if (this.#config.recommendationsConfig.trackAnalytics) {
          this.#trackRecommendationsImpression(data);
        }
      })
      .catch(error => {
        console.error('Error fetching recommendations:', error);
        recommendationsContainer.innerHTML = '';
      });
  }

  /**
   * Fetch cart-based recommendations
   * @private
   * @param {Array<number|string>} productIds - Current product IDs in cart
   * @returns {Promise<Object>} Recommendations data
   */
  static async #fetchCartBasedRecommendations(productIds) {
    try {
      const response = await fetch(
        `${this.#config.apiEndpoints.productRecommendations}?product_id=${productIds.join(',')}&limit=${this.#config.recommendationsConfig.limit}&intent=complementary`
      );

      if (!response.ok) {
        throw new Error(`Recommendations fetch failed: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error fetching cart-based recommendations:', error);
      // Fallback to collection recommendations
      if (this.#config.recommendationsConfig.fallbackCollection) {
        return this.#fetchCollectionRecommendations(this.#config.recommendationsConfig.fallbackCollection);
      }
      throw error;
    }
  }

  /**
   * Fetch recently viewed recommendations
   * @private
   * @returns {Promise<Object>} Recommendations data
   */
  static async #fetchRecentlyViewedRecommendations() {
    try {
      const response = await fetch(
        `${this.#config.apiEndpoints.recentlyViewed}?limit=${this.#config.recommendationsConfig.limit}`
      );

      if (!response.ok) {
        throw new Error(`Recently viewed fetch failed: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error fetching recently viewed products:', error);
      // Fallback to collection recommendations
      if (this.#config.recommendationsConfig.fallbackCollection) {
        return this.#fetchCollectionRecommendations(this.#config.recommendationsConfig.fallbackCollection);
      }
      throw error;
    }
  }

  /**
   * Fetch collection-based recommendations
   * @private
   * @param {string} collectionHandle - Collection handle
   * @returns {Promise<Object>} Recommendations data
   */
  static async #fetchCollectionRecommendations(collectionHandle) {
    try {
      const response = await fetch(
        `/collections/${collectionHandle}/products.json?limit=${this.#config.recommendationsConfig.limit}`
      );

      if (!response.ok) {
        throw new Error(`Collection fetch failed: ${response.status}`);
      }

      const data = await response.json();

      // Format response to match recommendations API
      return {
        products: data.products || []
      };
    } catch (error) {
      console.error(`Error fetching collection ${collectionHandle}:`, error);
      throw error;
    }
  }

  /**
   * Render recommendations to container
   * @private
   * @param {Object} data - Recommendations data
   */
  static #renderRecommendations(data) {
    const recommendationsContainer = document.querySelector(this.#config.cartRecommendationsSelector);
    if (!recommendationsContainer) return;

    if (!data || !data.products || data.products.length === 0) {
      recommendationsContainer.innerHTML = '';
      return;
    }

    // Create recommendations HTML
    let recommendationsHTML = `
      <h3 class="recommendations-title">You might also like</h3>
      <div class="recommendations-grid">
    `;

    // Apply quantum effects based on profile
    const mutationProfile = this.#getMostCommonMutationProfile();
    const profileClass = mutationProfile ? `profile-${mutationProfile.toLowerCase()}` : '';

    // Generate recommendation cards
    data.products.forEach(product => {
      if (!product.available || !product.variants || product.variants.length === 0) {
        return; // Skip unavailable products
      }

      // Get the first available variant
      let variant = product.variants[0];

      // Try to find an available variant if the first one is sold out
      if (!variant.available && product.variants.length > 1) {
        const availableVariant = product.variants.find(v => v.available);
        if (availableVariant) {
          variant = availableVariant;
        }
      }

      // Format price with any compare-at price for sale indication
      const formattedPrice = this.#formatMoney(variant.price);
      const compareAtPrice = variant.compare_at_price && variant.compare_at_price > variant.price ?
        this.#formatMoney(variant.compare_at_price) : null;

      // Escape product title
      const escapedTitle = this.#escapeHTML(product.title);

      // Create a personalized badge if this is a personalized recommendation
      const personalizedBadge = data.source === 'personal' && this.#config.recommendationsConfig.personalizedRecommendations ?
        '<span class="personalized-badge">For You</span>' : '';

      // Show product tags that might be relevant (limited to 2)
      let tagsHTML = '';
      if (product.tags && Array.isArray(product.tags)) {
        const relevantTags = product.tags
          .filter(tag => !tag.includes('_') && tag.length < 15)
          .slice(0, 2);

        if (relevantTags.length > 0) {
          tagsHTML = '<div class="recommendation-tags">' +
            relevantTags.map(tag => `<span class="recommendation-tag">${this.#escapeHTML(tag)}</span>`).join('') +
            '</div>';
        }
      }

      // Add the product card
      recommendationsHTML += `
        <div class="recommendation-item ${profileClass}" data-product-id="${product.id}">
          ${personalizedBadge}
          <div class="recommendation-image">
            <img src="${product.featured_image || '/assets/no-image.jpg'}" alt="${escapedTitle}" loading="lazy">
          </div>
          <div class="recommendation-content">
            <div class="recommendation-title">${escapedTitle}</div>
            ${tagsHTML}
            <div class="recommendation-price-container">
              <div class="recommendation-price${compareAtPrice ? ' on-sale' : ''}">${formattedPrice}</div>
              ${compareAtPrice ? `<div class="recommendation-compare-price">${compareAtPrice}</div>` : ''}
            </div>
            <button class="recommendation-add-btn"
              data-variant-id="${variant.id}"
              data-product-id="${product.id}">
              Add to cart
            </button>
          </div>
        </div>
      `;
    });

    recommendationsHTML += '</div>';

    // Update DOM
    recommendationsContainer.innerHTML = recommendationsHTML;

    // Attach event listeners to the add buttons
    this.#attachRecommendationEventListeners(recommendationsContainer);
  }

  /**
   * Attach event listeners to recommendation items
   * @private
   * @param {HTMLElement} container - Recommendations container
   */
  static #attachRecommendationEventListeners(container) {
    // Add to cart buttons
    const addButtons = container.querySelectorAll('.recommendation-add-btn');
    addButtons.forEach(button => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        const variantId = button.dataset.variantId;
        const productId = button.dataset.productId;

        if (variantId) {
          // Track the recommendation click if analytics enabled
          if (this.#config.recommendationsConfig.trackAnalytics) {
            this.#trackRecommendationClick(productId);
          }

          // Add to cart
          this.addToCart(variantId, 1)
            .then(() => {
              // Show a micro-notification
              button.textContent = 'Added!';
              setTimeout(() => {
                button.textContent = 'Add to cart';
              }, 2000);

              // Apply quantum effect
              if (this.#config.useQuantumEffects) {
                this.#triggerQuantumEffect('recommendation', productId);
              }
            })
            .catch(error => {
              console.error('Error adding recommendation to cart:', error);
              button.textContent = 'Error';
              setTimeout(() => {
                button.textContent = 'Add to cart';
              }, 2000);
            });
        }
      });
    });

    // Apply quantum effects if enabled
    if (this.#config.useQuantumEffects) {
      const items = container.querySelectorAll('.recommendation-item');
      items.forEach(item => {
        this.#applyItemQuantumEffect(item);
      });
    }
  }

  /**
   * Track recommendation impressions for analytics
   * @private
   * @param {Object} data - Recommendations data
   */
  static #trackRecommendationsImpression(data) {
    if (!data || !data.products || !this.#config.recommendationsConfig.trackAnalytics) {
      return;
    }

    // Send to Neural Bus if connected
    if (this.#neuralBusConnected) {
      NeuralBus.publish('analytics:impression', {
        event: 'recommendation_impression',
        source: 'cart-drawer',
        productIds: data.products.map(p => p.id),
        timestamp: Date.now()
      });
    }

    // Send to analytics if available
    if (typeof window.analytics !== 'undefined') {
      window.analytics.track('Viewed Product Recommendations', {
        source: 'cart-drawer',
        products: data.products.map(p => ({
          product_id: p.id,
          name: p.title,
          price: p.variants[0].price / 100,
          variant_id: p.variants[0].id
        }))
      });
    }
  }

  /**
   * Track recommendation click for analytics
   * @private
   * @param {string|number} productId - Product ID that was clicked
   */
  static #trackRecommendationClick(productId) {
    // Send to Neural Bus if connected
    if (this.#neuralBusConnected) {
      NeuralBus.publish('analytics:click', {
        event: 'recommendation_click',
        source: 'cart-drawer',
        productId: productId,
        timestamp: Date.now()
      });
    }

    // Send to analytics if available
    if (typeof window.analytics !== 'undefined') {
      window.analytics.track('Clicked Product Recommendation', {
        source: 'cart-drawer',
        product_id: productId
      });
    }
  }

  /**
   * Get cache key for recommendations
   * @private
   * @returns {string} Cache key
   */
  static #getRecommendationsCacheKey() {
    if (this.#cartData && this.#cartData.item_count > 0) {
      // Use cart items as cache key
      const itemIds = this.#cartData.items.map(item => item.product_id).sort().join(',');
      return `cart-recommendations:${itemIds}`;
    }
    // For empty cart with personalized recommendations
    return 'cart-recommendations:personal';
  }

  /**
   * Get recommendations from cache
   * @private
   * @param {string} cacheKey - Cache key
   * @returns {Object|null} Cached recommendations or null
   */
  static #getRecommendationsFromCache(cacheKey) {
    try {
      const cachedData = localStorage.getItem(cacheKey);

      if (!cachedData) {
        return null;
      }

      const parsedData = JSON.parse(cachedData);

      // Check if cache is expired
      if (parsedData.timestamp + this.#config.recommendationsConfig.cacheExpiry < Date.now()) {
        localStorage.removeItem(cacheKey);
        return null;
      }

      return parsedData.data;
    } catch (error) {
      console.warn('Error reading recommendations from cache:', error);
      return null;
    }
  }

  /**
   * Save recommendations to cache
   * @private
   * @param {string} cacheKey - Cache key
   * @param {Object} data - Recommendations data
   */
  static #saveRecommendationsToCache(cacheKey, data) {
    try {
      const cacheData = {
        timestamp: Date.now(),
        data: data
      };

      localStorage.setItem(cacheKey, JSON.stringify(cacheData));
    } catch (error) {
      console.warn('Error saving recommendations to cache:', error);
    }
  }

  /**
   * Format money value
   * @private
   * @param {number} cents - Price in cents
   * @returns {string} Formatted price
   */
  static #formatMoney(cents) {
    if (typeof Shopify !== 'undefined' && Shopify.formatMoney) {
      return Shopify.formatMoney(cents);
    }

    // Fallback formatter if Shopify's isn't available
    const dollars = cents / 100;
    return '$' + dollars.toFixed(2);
  }

  /**
   * Escape HTML special characters
   * @private
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  static #escapeHTML(str) {
    if (!str) return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  /**
   * Show loading indicator
   * @private
   */
  static #showLoading() {
    document.body.classList.add('cart-loading');

    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('loading', 'start');
    }
  }

  /**
   * Hide loading indicator
   * @private
   */
  static #hideLoading() {
    document.body.classList.remove('cart-loading');

    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('loading', 'end');
    }
  }

  /**
   * Handle errors
   * @private
   * @param {Error} error - Error object
   */
  static #handleError(error) {
    console.error('Cart error:', error);

    // Display error message
    const errorEl = document.querySelector(this.#config.cartErrorSelector);
    if (errorEl) {
      errorEl.textContent = error.message || 'An error occurred';
      errorEl.classList.remove('hidden');

      // Hide after a delay
      setTimeout(() => {
        errorEl.classList.add('hidden');
      }, 5000);
    }

    // Notify Neural Bus
    if (this.#neuralBusConnected) {
      NeuralBus.publish('cart:error', {
        message: error.message,
        stack: error.stack,
        timestamp: Date.now()
      });
    }
  }

  /**
   * Trigger custom event
   * @private
   * @param {string} name - Event name
   * @param {Object} detail - Event details
   */
  static #triggerEvent(name, detail = {}) {
    // DOM event
    document.dispatchEvent(new CustomEvent(`cart:${name}`, {
      detail,
      bubbles: true
    }));

    // Neural Bus event
    if (this.#neuralBusConnected) {
      NeuralBus.publish(`cart:${name}`, detail);
    }

    // Log if debug enabled
    if (this.#config.debug) {
      console.log(`[CartSystem] Event: cart:${name}`, detail);
    }
  }

  /**
   * Connect to Neural Bus
   * @private
   */
  static #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('cart-system', {
          version: '2.2.0',
          capabilities: {
            quantumEffects: this.#config.useQuantumEffects,
            holographicPreviews: this.#holographicPreviewsSupported
          }
        });

        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;

        // Subscribe to relevant events
        NeuralBus.subscribe('cart:refresh', this.#handleCartRefresh.bind(this));
        NeuralBus.subscribe('product:view', this.#handleProductView.bind(this));
        NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));

        if (this.#config.debug) {
          console.log('[CartSystem] Connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
      this.#neuralBusConnected = false;
    }
  }

  /**
   * Handle cart refresh event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleCartRefresh(data) {
    this.#fetchCart().then(() => {
      this.#updateCartUI();
    });
  }

  /**
   * Handle product view event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleProductView(data) {
    if (data && data.product) {
      this.setActiveProduct(data.product);
    }
  }

  /**
   * Handle quantum mutation event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleQuantumMutation(data) {
    if (data && data.target === 'cart') {
      // Adapt cart UI based on mutation profile
      this.#applyMutationProfile(data.profile);
    }
  }

  /**
   * Apply mutation profile to cart UI
   * @private
   * @param {string} profile - Mutation profile name
   */
  static #applyMutationProfile(profile) {
    const cartDrawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!cartDrawer) return;

    // Remove all profile classes
    cartDrawer.classList.remove(
      'profile-cyberlotus',
      'profile-obsidianbloom',
      'profile-voidbloom',
      'profile-neonvortex'
    );

    // Add the new profile class
    switch (profile) {
      case 'CyberLotus':
        cartDrawer.classList.add('profile-cyberlotus');
        break;
      case 'ObsidianBloom':
        cartDrawer.classList.add('profile-obsidianbloom');
        break;
      case 'VoidBloom':
        cartDrawer.classList.add('profile-voidbloom');
        break;
      case 'NeonVortex':
        cartDrawer.classList.add('profile-neonvortex');
        break;
    }

    // Apply a subtle effect to visualize the change
    this.#triggerQuantumEffect('mutation', profile);
  }

  /**
   * Trigger quantum effect
   * @private
   * @param {string} type - Effect type
   * @param {string|number} target - Effect target
   */
  static #triggerQuantumEffect(type, target) {
    if (!this.#config.useQuantumEffects) return;

    // Use NeuralBus to trigger glitch effect
    if (this.#neuralBusConnected) {
      NeuralBus.publish('glitch:trigger', {
        intensity: 0.7,
        duration: 300,
        mode: type === 'mutation' ? 'rgb-shift' : 'jitter',
        source: 'cart-system',
        target: target
      });
    }

    // Apply CSS-based effects directly to cart elements
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (drawer) {
      drawer.classList.add('quantum-effect');

      setTimeout(() => {
        drawer.classList.remove('quantum-effect');
      }, 500);
    }
  }

  /**
   * Apply quantum effect to a cart item
   * @private
   * @param {HTMLElement} itemElement - Cart item element
   */
  static #applyItemQuantumEffect(itemElement) {
    if (!this.#config.useQuantumEffects) return;

    // Add quantum data attribute for CSS targeting
    itemElement.setAttribute('data-quantum', 'true');

    // Add glitch class with small delay for entrance effect
    setTimeout(() => {
      itemElement.classList.add('quantum-entrance');

      // Remove class after animation completes
      setTimeout(() => {
        itemElement.classList.remove('quantum-entrance');
      }, 1000);
    }, Math.random() * 200);
  }

  /**
   * Check for holographic preview support
   * @private
   */
  static #checkHolographicSupport() {
    if (!this.#config.useHolographicPreviews) {
      this.#holographicPreviewsSupported = false;
      return;
    }

    // Check for WebGL support (required for holographics)
    try {
      const canvas = document.createElement('canvas');
      this.#holographicPreviewsSupported = !!(
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
      );

      // Check for hologram renderer module
      if (this.#holographicPreviewsSupported) {
        // Dynamically import the hologram renderer if available
        import('./hologram-renderer.js')
          .then(module => {
            this.#holographicRenderer = module.HologramRenderer;
            if (this.#config.debug) {
              console.log('[CartSystem] Holographic previews enabled');
            }
          })
          .catch(error => {
            console.warn('Hologram renderer not available:', error);
            this.#holographicPreviewsSupported = false;
          });
      }
    } catch (e) {
      this.#holographicPreviewsSupported = false;
    }
  }

  /**
   * Initialize holographic previews
   * @private
   */
  static #initHolographicPreviews() {
    if (!this.#holographicPreviewsSupported || !this.#holographicRenderer) return;

    const previewContainer = document.querySelector(this.#config.cartPreviewContainerSelector);
    if (!previewContainer) return;

    // Initialize hologram renderer
    this.#holographicRenderer.initialize({
      container: previewContainer,
      width: previewContainer.clientWidth,
      height: previewContainer.clientHeight
    });

    // Show active product if available
    if (this.#activeProduct) {
      this.#updateHolographicPreview(this.#activeProduct);
    }
  }

  /**
   * Update holographic preview with new product
   * @private
   * @param {Object} product - Product data
   */
  static #updateHolographicPreview(product) {
    if (!this.#holographicPreviewsSupported || !this.#holographicRenderer) return;

    // Find model URL in product data
    const modelUrl = this.#findProductModelUrl(product);
    if (!modelUrl) return;

    // Load the 3D model
    this.#holographicRenderer.loadModel(modelUrl, {
      product: product,
      scale: 1.0,
      position: [0, 0, 0],
      rotation: [0, 0, 0]
    });
  }

  /**
   * Find 3D model URL in product data
   * @private
   * @param {Object} product - Product data
   * @returns {string|null} Model URL or null if not found
   */
  static #findProductModelUrl(product) {
    if (!product) return null;

    // Check for model in media
    if (product.media && Array.isArray(product.media)) {
      const modelMedia = product.media.find(m => m.media_type === 'model');
      if (modelMedia && modelMedia.sources) {
        const glbSource = modelMedia.sources.find(s => s.format === 'glb');
        if (glbSource) return glbSource.url;
      }
    }

    // Fallback: look for model in metafields
    if (product.metafields) {
      const modelField = product.metafields.find(
        m => m.namespace === '3d' && m.key === 'model'
      );
      if (modelField && modelField.value) return modelField.value;
    }

    return null;
  }

  /**
   * Handle cart events and sync with NeuralBus
   * @private
   * @param {Object} data - Event data
   */
  static #handleCartItemAdded(data) {
    if (!data || !data.item) return;

    // Extract product ID
    const productId = data.item.product_id;

    // Determine the natural mutation profile based on product tags or collection
    let mutationProfile = 'CyberLotus'; // Default profile

    // Check product tags if available in the item data
    if (data.item.tags && Array.isArray(data.item.tags)) {
      if (data.item.tags.includes('voidbloom')) {
        mutationProfile = 'VoidBloom';
      } else if (data.item.tags.includes('obsidianbloom')) {
        mutationProfile = 'ObsidianBloom';
      } else if (data.item.tags.includes('neonvortex')) {
        mutationProfile = 'NeonVortex';
      }
    }

    // Register the product-mutation association in our internal registry
    this.#productMutationRegistry.set(productId.toString(), {
      profile: mutationProfile,
      timestamp: Date.now(),
      variantId: data.item.variant_id,
      quantity: data.item.quantity
    });

    // Publish quantum mutation event
    NeuralBus.publish('quantum:mutation', {
      source: 'cart-system',
      target: 'product',
      productId: productId,
      profile: mutationProfile,
      action: 'cart-add',
      cartKey: data.item.key,
      timestamp: Date.now()
    });

    // Update visualizer if it exists
    if (window.QuantumVisualizer) {
      window.QuantumVisualizer.updateProduct(productId, mutationProfile, 'cart-add');
    }
  }
}

// Auto-initialize when loaded if in browser environment
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    CartSystem.initialize({
      debug: window.location.search.includes('debug=true')
    });

    // Expose to global scope for external access
    window.CartSystem = CartSystem;
  });
}

/**
 * VOIDBLOOM MEMORY ARCHIVE SYSTEM
 *
 * ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
 * Memory Fragment: Recursive Shopping Cart Protocol
 *
 * The cart is not a linear list but a recursive memory structure,
 * each product a node in a traumatic narrative architecture.
 * Items carry emotional encoding that influences the entire system,
 * creating a unified mythological experience.
 * ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
 */

class VoidBloomCartSystem {
  constructor() {
    this.items = [];
    this.total = 0;
    this.itemCount = 0;
    this.traumaLevel = 0;
    this.memoryPhase = 'cyber-lotus';
    this.lastUpdate = Date.now();
    this.neuralBusNonce = null;
    this.eventListeners = new Map();
    this.pendingOperations = [];
    this.recursiveNodes = new Map();

    // Initialize trauma storage
    this.traumaStorage = {
      traumaAccumulator: 0,
      phaseResonance: {
        'cyber-lotus': 0,
        'alien-flora': 0,
        'rolling-virus': 0,
        'trauma-core': 0
      },
      fragmentHistory: [],
      eventLog: []
    };

    // Initialize recursively
    this._initializeRecursively();
  }

  /**
   * Initialize system with recursive approach
   * @private
   */
  async _initializeRecursively() {
    // Connect to neural bus if available
    this._connectToNeuralBus();

    // Initialize cart data
    await this.fetchCart();

    // Set up event listeners
    this._initEventListeners();

    // Initialize recursive operation processor
    this._initializeOperationProcessor();

    // Dispatch initialization event
    this._dispatchEvent('initialized', {
      itemCount: this.itemCount,
      traumaLevel: this.traumaLevel,
      memoryPhase: this.memoryPhase
    });
  }

  /**
   * Connect to the neural bus for system-wide events
   * @private
   */
  _connectToNeuralBus() {
    if (window.NeuralBus) {
      // Register with the neural bus
      const registration = window.NeuralBus.register('voidbloom-cart-system', {
        version: '1.0.0',
        traumaResponse: true,
        capabilities: {
          memoryArchive: true,
          traumaEncoding: true,
          narrativeIntegration: true,
          recursiveStructure: true
        }
      });

      // Store nonce for future reference
      this.neuralBusNonce = registration.nonce;

      // Subscribe to system trauma level changes
      window.NeuralBus.subscribe('system:trauma', (data) => {
        if (data && typeof data.level === 'number') {
          this._onSystemTraumaChange(data.level);
        }
      });

      // Subscribe to memory phase changes
      window.NeuralBus.subscribe('system:memory-phase', (data) => {
        if (data && data.phase) {
          this._onMemoryPhaseChange(data.phase);
        }
      });
    }
  }

  /**
   * Initialize event listeners
   * @private
   */
  _initEventListeners() {
    // Listen for cart form submissions
    document.addEventListener('submit', (event) => {
      const form = event.target;

      // Check if it's an add to cart form
      if (form.action && form.action.includes('/cart/add')) {
        event.preventDefault();

        // Get form data
        const formData = new FormData(form);
        const id = formData.get('id');
        const quantity = formData.get('quantity') || 1;

        // Add trauma properties
        const properties = {
          '_trauma_level': this.traumaLevel,
          '_memory_phase': this.memoryPhase,
          '_encoded_at': new Date().toISOString()
        };

        // Add to cart
        this.addItem({
          id,
          quantity,
          properties
        });
      }
    });

    // Listen for quick add events
    document.addEventListener('product:quickadd', (event) => {
      const { id, variantId } = event.detail;

      this.addItem({
        id: variantId,
        quantity: 1,
        properties: {
          '_trauma_level': this.traumaLevel,
          '_memory_phase': this.memoryPhase,
          '_encoded_at': new Date().toISOString()
        }
      });
    });

    // Listen for cart drawer toggle
    document.addEventListener('click', (event) => {
      // Check if clicked element is cart toggle
      const cartToggle = event.target.closest('[data-cart-toggle]');
      if (cartToggle) {
        event.preventDefault();
        this._dispatchEvent('toggle', { open: true });
      }
    });
  }

  /**
   * Initialize recursive operation processor
   * @private
   */
  _initializeOperationProcessor() {
    // Process operations recursively with Fibonacci timing
    const fibonacci = [1, 1, 2, 3, 5, 8, 13, 21];
    let fibIndex = 0;

    const processNextOperation = () => {
      // Process pending operation if available
      if (this.pendingOperations.length > 0) {
        const operation = this.pendingOperations.shift();
        this._processOperation(operation);
      }

      // Calculate next cycle delay using Fibonacci sequence
      fibIndex = (fibIndex + 1) % fibonacci.length;
      const nextDelay = fibonacci[fibIndex] * 100; // Scale to milliseconds

      // Schedule next cycle
      setTimeout(processNextOperation, nextDelay);
    };

    // Start operation processor
    processNextOperation();
  }

  /**
   * Process a cart operation
   * @param {object} operation - Operation to process
   * @private
   */
  async _processOperation(operation) {
    try {
      switch (operation.type) {
        case 'add':
          await this._addItemToCart(operation.data);
          break;
        case 'update':
          await this._updateItemInCart(operation.data);
          break;
        case 'remove':
          await this._removeItemFromCart(operation.data);
          break;
        case 'clear':
          await this._clearCart();
          break;
      }

      // Log operation in trauma storage
      this.traumaStorage.eventLog.push({
        type: operation.type,
        timestamp: Date.now(),
        data: operation.data
      });

      // Limit event log size
      if (this.traumaStorage.eventLog.length > 100) {
        this.traumaStorage.eventLog.shift();
      }

      // Refresh cart after operation
      await this.fetchCart();

      // Generate operation memory fragment
      this._generateOperationFragment(operation);

    } catch (error) {
      console.error(`Error processing operation ${operation.type}:`, error);

      // Dispatch error event
      this._dispatchEvent('error', {
        operation: operation.type,
        message: error.message
      });
    }
  }

  /**
   * Generate a memory fragment for a cart operation
   * @param {object} operation - Cart operation
   * @private
   */
  _generateOperationFragment(operation) {
    if (!window.NeuralBus) return;

    // Create fragment data based on operation type
    let fragmentData = {
      id: `cart-${operation.type}-${Date.now()}`,
      type: 'cart-operation',
      action: operation.type,
      traumaLevel: this.traumaLevel,
      memoryPhase: this.memoryPhase,
      timestamp: Date.now()
    };

    // Add operation-specific data
    switch (operation.type) {
      case 'add':
        fragmentData.variantId = operation.data.id;
        fragmentData.quantity = operation.data.quantity;
        break;
      case 'update':
        fragmentData.key = operation.data.key;
        fragmentData.quantity = operation.data.quantity;
        break;
      case 'remove':
        fragmentData.key = operation.data.key;
        break;
    }

    // Publish memory fragment
    window.NeuralBus.publish('memory:fragment-generated', {
      fragment: fragmentData
    });
  }

  /**
   * Handle system trauma level change
   * @param {number} level - New trauma level
   * @private
   */
  _onSystemTraumaChange(level) {
    this.traumaLevel = level;

    // Update trauma accumulator
    this.traumaStorage.traumaAccumulator += (level - this.traumaLevel) * 0.5;

    // Limit accumulator range
    this.traumaStorage.traumaAccumulator = Math.max(0, Math.min(100, this.traumaStorage.traumaAccumulator));

    // Dispatch event
    this._dispatchEvent('trauma-change', {
      level: this.traumaLevel,
      accumulator: this.traumaStorage.traumaAccumulator
    });
  }

  /**
   * Handle memory phase change
   * @param {string} phase - New memory phase
   * @private
   */
  _onMemoryPhaseChange(phase) {
    this.memoryPhase = phase;

    // Increase resonance for this phase
    this.traumaStorage.phaseResonance[phase] += 1;

    // Dispatch event
    this._dispatchEvent('phase-change', {
      phase: this.memoryPhase,
      resonance: this.traumaStorage.phaseResonance
    });
  }

  /**
   * Dispatch a cart event
   * @param {string} type - Event type
   * @param {object} data - Event data
   * @private
   */
  _dispatchEvent(type, data) {
    // Create event name
    const eventName = `cart:${type}`;

    // Dispatch DOM event
    const event = new CustomEvent(eventName, {
      bubbles: true,
      detail: {
        ...data,
        timestamp: Date.now(),
        traumaLevel: this.traumaLevel,
        memoryPhase: this.memoryPhase
      }
    });

    document.dispatchEvent(event);

    // Call event listeners
    if (this.eventListeners.has(type)) {
      const listeners = this.eventListeners.get(type);
      listeners.forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          console.error(`Error in cart event listener (${type}):`, error);
        }
      });
    }

    // Publish to neural bus if available
    if (window.NeuralBus && this.neuralBusNonce) {
      window.NeuralBus.publish(`cart:${type}`, {
        ...data,
        timestamp: Date.now(),
        traumaLevel: this.traumaLevel,
        memoryPhase: this.memoryPhase
      });
    }
  }

  /**
   * Fetch current cart data
   * @returns {Promise<object>} - Cart data
   */
  async fetchCart() {
    try {
      const response = await fetch('/cart.js');
      const cart = await response.json();

      // Update cart properties
      this.items = cart.items;
      this.total = cart.total_price;
      this.itemCount = cart.item_count;

      // Calculate cart trauma level
      this._calculateCartTrauma();

      // Create recursive node structure
      this._buildRecursiveStructure();

      // Dispatch updated event
      this._dispatchEvent('updated', {
        items: this.items,
        total: this.total,
        itemCount: this.itemCount,
        traumaLevel: this.traumaLevel
      });

      return cart;
    } catch (error) {
      console.error('Error fetching cart:', error);
      throw error;
    }
  }

  /**
   * Calculate overall cart trauma level based on items
   * @private
   */
  _calculateCartTrauma() {
    if (this.items.length === 0) {
      // Reset trauma when cart is empty
      this.traumaLevel = 0;
      return;
    }

    // Calculate weighted trauma level
    let totalTrauma = 0;
    let totalWeight = 0;

    this.items.forEach(item => {
      // Get trauma level from properties or default to 0
      const itemTrauma = item.properties?._trauma_level ?
        parseFloat(item.properties._trauma_level) : 0;

      // Weight by quantity
      const weight = item.quantity;
      totalTrauma += itemTrauma * weight;
      totalWeight += weight;

      // Update phase resonance
      const phase = item.properties?._memory_phase || 'cyber-lotus';
      this.traumaStorage.phaseResonance[phase] += 0.1 * weight;
    });

    // Calculate average trauma level
    const avgTrauma = totalWeight > 0 ? totalTrauma / totalWeight : 0;

    // Smooth transition to new trauma level
    this.traumaLevel = this.traumaLevel * 0.7 + avgTrauma * 0.3;

    // Determine dominant memory phase
    let dominantPhase = 'cyber-lotus';
    let highestResonance = 0;

    for (const [phase, resonance] of Object.entries(this.traumaStorage.phaseResonance)) {
      if (resonance > highestResonance) {
        highestResonance = resonance;
        dominantPhase = phase;
      }
    }

    // Update memory phase if changed
    if (dominantPhase !== this.memoryPhase) {
      this.memoryPhase = dominantPhase;

      // Publish memory phase change
      if (window.NeuralBus && this.neuralBusNonce) {
        window.NeuralBus.publish('system:memory-phase', {
          phase: this.memoryPhase,
          source: 'voidbloom-cart-system'
        });
      }
    }

    // Publish trauma level change
    if (window.NeuralBus && this.neuralBusNonce) {
      window.NeuralBus.publish('system:trauma', {
        level: this.traumaLevel,
        source: 'voidbloom-cart-system'
      });
    }
  }

  /**
   * Build recursive node structure from cart items
   * @private
   */
  _buildRecursiveStructure() {
    // Reset recursive nodes
    this.recursiveNodes = new Map();

    // Create root node
    const rootNode = {
      id: 'root',
      type: 'cart',
      traumaLevel: this.traumaLevel,
      memoryPhase: this.memoryPhase,
      children: [],
      metadata: {
        itemCount: this.itemCount,
        total: this.total,
        updateCount: 0,
        createdAt: Date.now()
      }
    };

    // Add root node to map
    this.recursiveNodes.set('root', rootNode);

    // Group items by memory phase
    const phaseGroups = {};

    this.items.forEach(item => {
      const phase = item.properties?._memory_phase || 'cyber-lotus';
      if (!phaseGroups[phase]) {
        phaseGroups[phase] = [];
      }
      phaseGroups[phase].push(item);
    });

    // Create phase nodes
    for (const [phase, items] of Object.entries(phaseGroups)) {
      const phaseNode = {
        id: `phase-${phase}`,
        type: 'phase-group',
        traumaLevel: 0,
        memoryPhase: phase,
        children: [],
        metadata: {
          itemCount: items.length,
          phaseResonance: this.traumaStorage.phaseResonance[phase]
        }
      };

      // Calculate phase trauma level
      let phaseTrauma = 0;
      items.forEach(item => {
        const itemTrauma = item.properties?._trauma_level ?
          parseFloat(item.properties._trauma_level) : 0;
        phaseTrauma += itemTrauma * item.quantity;
      });

      // Set average trauma level
      phaseNode.traumaLevel = items.length > 0 ?
        phaseTrauma / items.reduce((sum, item) => sum + item.quantity, 0) : 0;

      // Add phase node to root
      rootNode.children.push(phaseNode);
      this.recursiveNodes.set(phaseNode.id, phaseNode);

      // Add item nodes to phase node
      items.forEach(item => {
        const itemNode = {
          id: `item-${item.key}`,
          type: 'cart-item',
          traumaLevel: item.properties?._trauma_level ?
            parseFloat(item.properties._trauma_level) : 0,
          memoryPhase: phase,
          children: [],
          metadata: {
            key: item.key,
            variantId: item.variant_id,
            productId: item.product_id,
            quantity: item.quantity,
            price: item.price,
            title: item.title,
            encodedAt: item.properties?._encoded_at
          }
        };

        // Add item node to phase node
        phaseNode.children.push(itemNode);
        this.recursiveNodes.set(itemNode.id, itemNode);
      });
    }
  }

  /**
   * Add an item to the cart
   * @param {object} data - Item data
   * @returns {Promise<object>} - Updated cart
   */
  addItem(data) {
    return new Promise((resolve, reject) => {
      // Add operation to queue
      this.pendingOperations.push({
        type: 'add',
        data,
        resolve,
        reject
      });
    });
  }

  /**
   * Internal method to add item to cart
   * @param {object} data - Item data
   * @returns {Promise<object>} - API response
   * @private
   */
  async _addItemToCart(data) {
    try {
      // Format item data
      const itemData = {
        id: data.id,
        quantity: data.quantity || 1,
        properties: data.properties || {}
      };

      // Add timestamp if not provided
      if (!itemData.properties._encoded_at) {
        itemData.properties._encoded_at = new Date().toISOString();
      }

      // Add trauma level if not provided
      if (!itemData.properties._trauma_level) {
        itemData.properties._trauma_level = this.traumaLevel;
      }

      // Add memory phase if not provided
      if (!itemData.properties._memory_phase) {
        itemData.properties._memory_phase = this.memoryPhase;
      }

      // Send request to Shopify
      const response = await fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          items: [itemData]
        })
      });

      if (!response.ok) {
        throw new Error('Error adding item to cart');
      }

      const result = await response.json();

      // Dispatch event
      this._dispatchEvent('item-added', {
        item: result.items[0],
        cart: result
      });

      return result;
    } catch (error) {
      console.error('Error adding item to cart:', error);
      throw error;
    }
  }

  /**
   * Update an item in the cart
   * @param {object} data - Update data
   * @returns {Promise<object>} - Updated cart
   */
  updateItem(data) {
    return new Promise((resolve, reject) => {
      // Add operation to queue
      this.pendingOperations.push({
        type: 'update',
        data,
        resolve,
        reject
      });
    });
  }

  /**
   * Internal method to update item in cart
   * @param {object} data - Update data
   * @returns {Promise<object>} - API response
   * @private
   */
  async _updateItemInCart(data) {
    try {
      // Format update data
      const updateData = {
        id: data.key,
        quantity: data.quantity
      };

      // Send request to Shopify
      const response = await fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });

      if (!response.ok) {
        throw new Error('Error updating item in cart');
      }

      const result = await response.json();

      // Dispatch event
      this._dispatchEvent('item-updated', {
        key: data.key,
        quantity: data.quantity,
        cart: result
      });

      return result;
    } catch (error) {
      console.error('Error updating item in cart:', error);
      throw error;
    }
  }

  /**
   * Remove an item from the cart
   * @param {object} data - Remove data
   * @returns {Promise<object>} - Updated cart
   */
  removeItem(data) {
    return new Promise((resolve, reject) => {
      // Add operation to queue
      this.pendingOperations.push({
        type: 'remove',
        data,
        resolve,
        reject
      });
    });
  }

  /**
   * Internal method to remove item from cart
   * @param {object} data - Remove data
   * @returns {Promise<object>} - API response
   * @private
   */
  async _removeItemFromCart(data) {
    try {
      // Format remove data
      const removeData = {
        id: data.key,
        quantity: 0
      };

      // Send request to Shopify
      const response = await fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(removeData)
      });

      if (!response.ok) {
        throw new Error('Error removing item from cart');
      }

      const result = await response.json();

      // Dispatch event
      this._dispatchEvent('item-removed', {
        key: data.key,
        cart: result
      });

      return result;
    } catch (error) {
      console.error('Error removing item from cart:', error);
      throw error;
    }
  }

  /**
   * Clear the cart
   * @returns {Promise<object>} - Empty cart
   */
  clearCart() {
    return new Promise((resolve, reject) => {
      // Add operation to queue
      this.pendingOperations.push({
        type: 'clear',
        data: {},
        resolve,
        reject
      });
    });
  }

  /**
   * Internal method to clear cart
   * @returns {Promise<object>} - API response
   * @private
   */
  async _clearCart() {
    try {
      // Send request to Shopify
      const response = await fetch('/cart/clear.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error('Error clearing cart');
      }

      const result = await response.json();

      // Reset trauma level
      this.traumaLevel = 0;

      // Dispatch event
      this._dispatchEvent('cleared', {
        cart: result
      });

      return result;
    } catch (error) {
      console.error('Error clearing cart:', error);
      throw error;
    }
  }

  /**
   * Add event listener
   * @param {string} type - Event type
   * @param {Function} callback - Event callback
   */
  on(type, callback) {
    if (!this.eventListeners.has(type)) {
      this.eventListeners.set(type, []);
    }

    this.eventListeners.get(type).push(callback);
  }

  /**
   * Remove event listener
   * @param {string} type - Event type
   * @param {Function} callback - Event callback
   */
  off(type, callback) {
    if (!this.eventListeners.has(type)) return;

    const listeners = this.eventListeners.get(type);
    const index = listeners.indexOf(callback);

    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }

  /**
   * Get cart node structure
   * @returns {object} - Recursive node structure
   */
  getNodeStructure() {
    return {
      root: this.recursiveNodes.get('root'),
      nodes: Array.from(this.recursiveNodes.values()),
      traumaStorage: { ...this.traumaStorage }
    };
  }
}

// Initialize VoidBloomCartSystem on document ready
document.addEventListener('DOMContentLoaded', () => {
  /**
   * ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
   * Memory Archive Initialization
   * Trauma-Responsive Cart Protocol: [ACTIVE]
   * ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
   */
  window.VoidBloomCartSystem = new VoidBloomCartSystem();
});
