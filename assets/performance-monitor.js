/**
 * PERFORMANCE-MONITOR.JS
 * Unified performance monitoring system for CyberCore components
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-optimized
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { ConfigDomain, ConfigManager, ConfigPriority } from './config-manager.js';
import { ErrorCategory, ErrorHandler } from './error-handler.js';
import { NeuralBus } from './neural-bus.js';

/**
 * Performance metric types
 * @enum {string}
 */
export const MetricType = {
  FPS: 'fps',
  CPU: 'cpu',
  MEMORY: 'memory',
  RENDER_TIME: 'render-time',
  NETWORK: 'network',
  EVENT_LATENCY: 'event-latency',
  COMPONENT_EXECUTION: 'component-execution',
  TRANSACTION: 'transaction',
};

/**
 * Optimization strategy types
 * @enum {string}
 */
export const OptimizationStrategy = {
  REDUCE_PARTICLES: 'reduce-particles',
  LOWER_QUALITY: 'lower-quality',
  DISABLE_EFFECTS: 'disable-effects',
  REDUCE_POLLING: 'reduce-polling',
  BATCH_UPDATES: 'batch-updates',
  DEFER_PROCESSING: 'defer-processing',
  REDUCE_TRAUMA_INTENSITY: 'reduce-trauma-intensity',
};

/**
 * Performance optimization levels
 * @enum {number}
 */
export const OptimizationLevel = {
  NONE: 0,        // No optimization
  LOW: 1,         // Minimal optimizations
  MEDIUM: 2,      // Balanced optimizations
  HIGH: 3,        // Aggressive optimizations
  CRITICAL: 4,    // Maximum optimizations
};

/**
 * Performance monitor for CyberCore systems
 * Tracks performance metrics and applies optimizations as needed
 */
export class PerformanceMonitor {
  // Static instance for singleton pattern
  static #instance = null;

  // Private properties
  #config = {
    sampleRate: 1000,         // Milliseconds between measurements
    fpsHistorySize: 60,       // Keep 60 fps samples (1 minute at 1 sample/sec)
    thresholds: {
      [MetricType.FPS]: {
        optimal: 55,          // Optimal fps: 55+
        acceptable: 30,       // Acceptable fps: 30-55
        problematic: 20,      // Problematic fps: 20-30
        critical: 10,         // Critical fps: <10
      },
      [MetricType.CPU]: {
        optimal: 0.3,         // Optimal CPU usage: <30%
        acceptable: 0.5,      // Acceptable CPU usage: 30-50%
        problematic: 0.7,     // Problematic CPU usage: 50-70%
        critical: 0.9,        // Critical CPU usage: >90%
      },
      [MetricType.MEMORY]: {
        optimal: 100 * 1024 * 1024,    // Optimal memory: <100MB
        acceptable: 200 * 1024 * 1024, // Acceptable memory: <200MB
        problematic: 300 * 1024 * 1024, // Problematic memory: <300MB
        critical: 500 * 1024 * 1024,   // Critical memory: >500MB
      },
      [MetricType.RENDER_TIME]: {
        optimal: 10,          // Optimal render time: <10ms
        acceptable: 16,       // Acceptable render time: <16ms (60fps)
        problematic: 33,      // Problematic render time: <33ms (30fps)
        critical: 50,         // Critical render time: >50ms
      },
    },
    optimizationLevels: {
      [OptimizationStrategy.REDUCE_PARTICLES]: {
        [OptimizationLevel.LOW]: 0.8,      // Reduce particles to 80%
        [OptimizationLevel.MEDIUM]: 0.5,   // Reduce particles to 50%
        [OptimizationLevel.HIGH]: 0.2,     // Reduce particles to 20%
        [OptimizationLevel.CRITICAL]: 0.1, // Reduce particles to 10%
      },
      [OptimizationStrategy.LOWER_QUALITY]: {
        [OptimizationLevel.LOW]: 0.9,      // Lower quality to 90%
        [OptimizationLevel.MEDIUM]: 0.7,   // Lower quality to 70%
        [OptimizationLevel.HIGH]: 0.5,     // Lower quality to 50%
        [OptimizationLevel.CRITICAL]: 0.3, // Lower quality to 30%
      },
      [OptimizationStrategy.DISABLE_EFFECTS]: {
        [OptimizationLevel.LOW]: ['bloom'],
        [OptimizationLevel.MEDIUM]: ['bloom', 'aberration'],
        [OptimizationLevel.HIGH]: ['bloom', 'aberration', 'film'],
        [OptimizationLevel.CRITICAL]: ['bloom', 'aberration', 'film', 'glitch'],
      },
      [OptimizationStrategy.REDUCE_TRAUMA_INTENSITY]: {
        [OptimizationLevel.LOW]: 0.9,      // Reduce trauma intensity to 90%
        [OptimizationLevel.MEDIUM]: 0.7,   // Reduce trauma intensity to 70%
        [OptimizationLevel.HIGH]: 0.5,     // Reduce trauma intensity to 50%
        [OptimizationLevel.CRITICAL]: 0.2, // Reduce trauma intensity to 20%
      },
    },
    autoOptimizeThresholds: {
      [OptimizationLevel.LOW]: 0.7,        // Apply low optimizations at 70% of critical
      [OptimizationLevel.MEDIUM]: 0.8,     // Apply medium optimizations at 80% of critical
      [OptimizationLevel.HIGH]: 0.9,       // Apply high optimizations at 90% of critical
      [OptimizationLevel.CRITICAL]: 1.0,   // Apply critical optimizations at 100% of critical
    },
    autoOptimize: true,                   // Whether to automatically apply optimizations
    notifyThreshold: OptimizationLevel.MEDIUM, // Notify when optimization level reaches this
    debugMode: false,                     // Enable debug logging
  };

  #errorHandler = null;
  #configManager = null;
  #neuralBusConnected = false;
  #neuralNonce = null;

  #metrics = new Map();
  #fpsHistory = [];
  #frameCount = 0;
  #lastFrameTime = 0;
  #lastSampleTime = 0;
  #monitoringInterval = null;
  #currentOptimizationLevel = OptimizationLevel.NONE;
  #appliedOptimizations = new Map();
  #componentPerformance = new Map();
  #eventLatencies = new Map();
  #transactionTimes = new Map();

  /**
   * Create a new PerformanceMonitor (or return existing instance)
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    // Singleton pattern - return existing instance if available
    if (PerformanceMonitor.#instance) {
      // Update config if provided
      if (Object.keys(config).length > 0) {
        PerformanceMonitor.#instance.updateConfig(config);
      }
      return PerformanceMonitor.#instance;
    }

    // Set up dependencies
    this.#errorHandler = config.errorHandler || new ErrorHandler({
      componentName: 'performance-monitor',
    });

    this.#configManager = config.configManager || new ConfigManager();

    // Initialize metrics storage
    this.#initializeMetrics();

    // Update config with provided values
    this.updateConfig(config);

    // Connect to NeuralBus
    this.#connectToNeuralBus();

    // Set up performance monitoring
    this.#setupPerformanceMonitoring();

    // Set as singleton instance
    PerformanceMonitor.#instance = this;

    this.#log('PerformanceMonitor initialized');
  }

  /**
   * Update performance monitor configuration
   * @param {Object} config - New configuration options
   */
  updateConfig(config = {}) {
    // Deep merge configurations
    if (config.thresholds) {
      for (const [metricType, thresholds] of Object.entries(config.thresholds)) {
        this.#config.thresholds[metricType] = {
          ...this.#config.thresholds[metricType],
          ...thresholds,
        };
      }
      delete config.thresholds;
    }

    if (config.optimizationLevels) {
      for (const [strategy, levels] of Object.entries(config.optimizationLevels)) {
        this.#config.optimizationLevels[strategy] = {
          ...this.#config.optimizationLevels[strategy],
          ...levels,
        };
      }
      delete config.optimizationLevels;
    }

    if (config.autoOptimizeThresholds) {
      this.#config.autoOptimizeThresholds = {
        ...this.#config.autoOptimizeThresholds,
        ...config.autoOptimizeThresholds,
      };
      delete config.autoOptimizeThresholds;
    }

    // Merge remaining top-level config
    this.#config = {
      ...this.#config,
      ...config,
    };

    // Update configuration in the ConfigManager
    this.#configManager.setMultiple(
      ConfigDomain.PERFORMANCE,
      {
        sampleRate: this.#config.sampleRate,
        autoOptimize: this.#config.autoOptimize,
        currentOptimizationLevel: this.#currentOptimizationLevel,
      },
      ConfigPriority.DEFAULT
    );

    // Restart monitoring if interval changed
    if (config.sampleRate && this.#monitoringInterval) {
      this.stop();
      this.start();
    }

    this.#log('Configuration updated');
  }

  /**
   * Start performance monitoring
   */
  start() {
    if (this.#monitoringInterval) {
      this.#log('Performance monitoring already running');
      return;
    }

    // Reset counters
    this.#frameCount = 0;
    this.#lastFrameTime = performance.now();
    this.#lastSampleTime = performance.now();

    // Start monitoring interval
    this.#monitoringInterval = setInterval(() => {
      this.#sampleMetrics();
    }, this.#config.sampleRate);

    // Hook into requestAnimationFrame for FPS tracking
    this.#hookAnimationFrame();

    this.#log('Performance monitoring started');

    // Publish monitoring status
    if (this.#neuralBusConnected) {
      NeuralBus.publish('performance:status', {
        status: 'started',
        timestamp: Date.now(),
        sampleRate: this.#config.sampleRate,
      });
    }

    return this;
  }

  /**
   * Stop performance monitoring
   */
  stop() {
    if (!this.#monitoringInterval) {
      this.#log('Performance monitoring not running');
      return;
    }

    // Clear interval
    clearInterval(this.#monitoringInterval);
    this.#monitoringInterval = null;

    // Unhook animation frame
    this.#unhookAnimationFrame();

    this.#log('Performance monitoring stopped');

    // Publish monitoring status
    if (this.#neuralBusConnected) {
      NeuralBus.publish('performance:status', {
        status: 'stopped',
        timestamp: Date.now(),
      });
    }

    return this;
  }

  /**
   * Check if performance monitoring is running
   * @returns {boolean} Whether monitoring is active
   */
  isRunning() {
    return !!this.#monitoringInterval;
  }

  /**
   * Reset all performance metrics
   */
  reset() {
    this.#initializeMetrics();
    this.#fpsHistory = [];
    this.#frameCount = 0;
    this.#lastFrameTime = performance.now();
    this.#lastSampleTime = performance.now();
    this.#appliedOptimizations.clear();
    this.#componentPerformance.clear();
    this.#eventLatencies.clear();
    this.#transactionTimes.clear();

    this.#log('Performance metrics reset');

    return this;
  }

  /**
   * Get current performance metrics
   * @param {string} metricType - Specific metric type to get (optional)
   * @returns {Object|number} Performance metrics or specific metric value
   */
  getMetrics(metricType = null) {
    if (metricType) {
      return this.#metrics.get(metricType)?.value;
    }

    // Convert metrics map to object
    const metrics = {};
    for (const [type, data] of this.#metrics.entries()) {
      metrics[type] = data.value;
    }

    return metrics;
  }

  /**
   * Get current FPS history
   * @returns {Array} FPS history
   */
  getFpsHistory() {
    return [...this.#fpsHistory];
  }

  /**
   * Get current optimization level
   * @returns {number} Optimization level
   */
  getOptimizationLevel() {
    return this.#currentOptimizationLevel;
  }

  /**
   * Get applied optimizations
   * @returns {Map} Applied optimizations
   */
  getAppliedOptimizations() {
    return new Map(this.#appliedOptimizations);
  }

  /**
   * Manually apply optimizations at a specific level
   * @param {number} level - Optimization level to apply
   * @param {boolean} force - Whether to force optimizations even if auto-optimize is disabled
   * @returns {boolean} Whether optimizations were applied
   */
  applyOptimizations(level, force = false) {
    if (!force && !this.#config.autoOptimize) {
      this.#log('Auto-optimize disabled, skipping optimization');
      return false;
    }

    if (level === this.#currentOptimizationLevel) {
      this.#log(`Already at optimization level ${level}`);
      return true;
    }

    this.#log(`Applying optimizations at level ${level}`);

    try {
      // Track previous level for rollback if needed
      const previousLevel = this.#currentOptimizationLevel;
      this.#currentOptimizationLevel = level;

      // Track applied optimizations for reporting
      this.#appliedOptimizations.clear();

      // Apply optimization strategies
      if (level > OptimizationLevel.NONE) {
        this.#applyOptimizationStrategies(level);
      } else {
        // Reset to default values
        this.#resetOptimizations();
      }

      // Update configuration
      this.#configManager.set(
        ConfigDomain.PERFORMANCE,
        'currentOptimizationLevel',
        level,
        ConfigPriority.OVERRIDE
      );

      // Publish optimization event
      if (this.#neuralBusConnected) {
        NeuralBus.publish('performance:optimizations:applied', {
          level,
          timestamp: Date.now(),
          strategies: Array.from(this.#appliedOptimizations.entries()),
        });
      }

      // Notify user if level is above notification threshold
      if (level >= this.#config.notifyThreshold) {
        this.#notifyOptimizationApplied(level);
      }

      return true;
    } catch (error) {
      this.#errorHandler.logError('Failed to apply optimizations', {
        category: ErrorCategory.PERFORMANCE,
        code: 'OPTIMIZATION_FAILED',
        error,
        level,
      });

      // Roll back to previous level on failure
      this.#currentOptimizationLevel = previousLevel;
      return false;
    }
  }

  /**
   * Start measuring execution time for a component
   * @param {string} componentName - Name of the component
   * @param {string} operationName - Name of the operation
   * @returns {Function} Function to call when operation is complete
   */
  startMeasure(componentName, operationName) {
    const key = `${componentName}:${operationName}`;
    const startTime = performance.now();

    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Store performance data
      if (!this.#componentPerformance.has(key)) {
        this.#componentPerformance.set(key, {
          counts: 0,
          totalTime: 0,
          averageTime: 0,
          minTime: Infinity,
          maxTime: 0,
          lastTime: 0,
        });
      }

      const stats = this.#componentPerformance.get(key);
      stats.counts++;
      stats.totalTime += duration;
      stats.averageTime = stats.totalTime / stats.counts;
      stats.minTime = Math.min(stats.minTime, duration);
      stats.maxTime = Math.max(stats.maxTime, duration);
      stats.lastTime = duration;

      // Log slow operations
      if (duration > 50) { // 50ms is a significant frame budget
        this.#log(`Slow operation: ${key} took ${duration.toFixed(2)}ms`, true);
      }

      return duration;
    };
  }

  /**
   * Track event latency
   * @param {string} eventName - Name of the event
   * @param {number} latency - Latency in milliseconds
   */
  trackEventLatency(eventName, latency) {
    if (!this.#eventLatencies.has(eventName)) {
      this.#eventLatencies.set(eventName, {
        counts: 0,
        totalLatency: 0,
        averageLatency: 0,
        minLatency: Infinity,
        maxLatency: 0,
        lastLatency: 0,
      });
    }

    const stats = this.#eventLatencies.get(eventName);
    stats.counts++;
    stats.totalLatency += latency;
    stats.averageLatency = stats.totalLatency / stats.counts;
    stats.minLatency = Math.min(stats.minLatency, latency);
    stats.maxLatency = Math.max(stats.maxLatency, latency);
    stats.lastLatency = latency;

    // Track as a performance metric if significant
    if (stats.counts > 10 && stats.averageLatency > 50) {
      this.#metrics.set(MetricType.EVENT_LATENCY, {
        value: stats.averageLatency,
        timestamp: Date.now(),
        source: eventName,
      });
    }
  }

  /**
   * Start a transaction measurement
   * @param {string} transactionName - Name of the transaction
   * @returns {Function} Function to call when transaction is complete
   */
  startTransaction(transactionName) {
    const startTime = performance.now();

    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime;

      // Store transaction data
      if (!this.#transactionTimes.has(transactionName)) {
        this.#transactionTimes.set(transactionName, {
          counts: 0,
          totalTime: 0,
          averageTime: 0,
          minTime: Infinity,
          maxTime: 0,
          lastTime: 0,
        });
      }

      const stats = this.#transactionTimes.get(transactionName);
      stats.counts++;
      stats.totalTime += duration;
      stats.averageTime = stats.totalTime / stats.counts;
      stats.minTime = Math.min(stats.minTime, duration);
      stats.maxTime = Math.max(stats.maxTime, duration);
      stats.lastTime = duration;

      // Track as a performance metric
      this.#metrics.set(`${MetricType.TRANSACTION}:${transactionName}`, {
        value: duration,
        timestamp: Date.now(),
      });

      return duration;
    };
  }

  /**
   * Get component performance statistics
   * @param {string} componentName - Name of component (optional)
   * @returns {Object} Component performance statistics
   */
  getComponentPerformance(componentName = null) {
    if (componentName) {
      // Get stats for specific component
      const componentStats = {};

      for (const [key, stats] of this.#componentPerformance.entries()) {
        if (key.startsWith(`${componentName}:`)) {
          const operationName = key.substring(componentName.length + 1);
          componentStats[operationName] = stats;
        }
      }

      return componentStats;
    }

    // Get all component stats
    const allStats = {};

    for (const [key, stats] of this.#componentPerformance.entries()) {
      const [componentName, operationName] = key.split(':');

      if (!allStats[componentName]) {
        allStats[componentName] = {};
      }

      allStats[componentName][operationName] = stats;
    }

    return allStats;
  }

  /**
   * Get event latency statistics
   * @param {string} eventName - Name of event (optional)
   * @returns {Object} Event latency statistics
   */
  getEventLatencies(eventName = null) {
    if (eventName) {
      return this.#eventLatencies.get(eventName);
    }

    // Return all event latencies
    const latencies = {};

    for (const [name, stats] of this.#eventLatencies.entries()) {
      latencies[name] = stats;
    }

    return latencies;
  }

  /**
   * Get transaction time statistics
   * @param {string} transactionName - Name of transaction (optional)
   * @returns {Object} Transaction time statistics
   */
  getTransactionTimes(transactionName = null) {
    if (transactionName) {
      return this.#transactionTimes.get(transactionName);
    }

    // Return all transaction times
    const times = {};

    for (const [name, stats] of this.#transactionTimes.entries()) {
      times[name] = stats;
    }

    return times;
  }

  /**
   * Initialize metrics storage
   * @private
   */
  #initializeMetrics() {
    this.#metrics = new Map([
      [MetricType.FPS, { value: 60, timestamp: Date.now() }],
      [MetricType.CPU, { value: 0, timestamp: Date.now() }],
      [MetricType.MEMORY, { value: 0, timestamp: Date.now() }],
      [MetricType.RENDER_TIME, { value: 0, timestamp: Date.now() }],
      [MetricType.NETWORK, { value: 0, timestamp: Date.now() }],
    ]);
  }

  /**
   * Connect to NeuralBus for event communication
   * @private
   */
  #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('performance-monitor', {
          version: '1.0.0',
          capabilities: {
            performanceMonitoring: true,
            optimizationStrategies: Object.values(OptimizationStrategy),
          },
        });

        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;

        // Subscribe to performance events
        NeuralBus.subscribe('performance:request', this.#handlePerformanceRequest.bind(this));
        NeuralBus.subscribe('performance:optimize:request', this.#handleOptimizationRequest.bind(this));
        NeuralBus.subscribe('performance:reset:request', this.#handleResetRequest.bind(this));

        // Subscribe to component events
        NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));
        NeuralBus.subscribe('trauma:activated', this.#handleTraumaActivation.bind(this));

        this.#log('Connected to Neural Bus');
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to connect to Neural Bus', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'PERFORMANCE_NEURALBUS_CONNECTION_FAILED',
        error,
      });
      this.#neuralBusConnected = false;
    }
  }

  /**
   * Set up performance monitoring
   * @private
   */
  #setupPerformanceMonitoring() {
    // Register schema with ConfigManager
    this.#configManager.registerSchema(
      ConfigDomain.PERFORMANCE,
      {
        type: 'object',
        properties: {
          sampleRate: {
            type: 'number',
            minimum: 100,
            maximum: 10000,
          },
          autoOptimize: {
            type: 'boolean',
          },
          currentOptimizationLevel: {
            type: 'number',
            minimum: 0,
            maximum: 4,
          },
        },
      },
      {
        sampleRate: this.#config.sampleRate,
        autoOptimize: this.#config.autoOptimize,
        currentOptimizationLevel: this.#currentOptimizationLevel,
      }
    );

    // Observe configuration changes
    this.#configManager.observe(ConfigDomain.PERFORMANCE, 'autoOptimize', (value) => {
      this.#config.autoOptimize = value;
      this.#log(`Auto-optimize ${value ? 'enabled' : 'disabled'}`);
    });

    this.#configManager.observe(ConfigDomain.PERFORMANCE, 'sampleRate', (value) => {
      if (value !== this.#config.sampleRate) {
        this.#config.sampleRate = value;

        // Restart monitoring if running
        if (this.isRunning()) {
          this.stop();
          this.start();
        }

        this.#log(`Sample rate updated to ${value}ms`);
      }
    });

    // Start monitoring
    if (typeof window !== 'undefined') {
      // Wait for page load
      if (document.readyState === 'complete') {
        this.start();
      } else {
        window.addEventListener('load', () => {
          setTimeout(() => this.start(), 1000);
        });
      }
    }
  }

  /**
   * Hook into requestAnimationFrame for FPS tracking
   * @private
   */
  #hookAnimationFrame() {
    // Store original requestAnimationFrame
    if (!window._originalRAF) {
      window._originalRAF = window.requestAnimationFrame;

      // Override requestAnimationFrame
      window.requestAnimationFrame = (callback) => {
        return window._originalRAF((timestamp) => {
          this.#frameCount++;
          this.#trackFrameTime(timestamp);
          callback(timestamp);
        });
      };
    }
  }

  /**
   * Unhook animation frame
   * @private
   */
  #unhookAnimationFrame() {
    // Restore original requestAnimationFrame
    if (window._originalRAF) {
      window.requestAnimationFrame = window._originalRAF;
      window._originalRAF = null;
    }
  }

  /**
   * Track frame time for FPS calculation
   * @private
   * @param {number} timestamp - Current timestamp
   */
  #trackFrameTime(timestamp) {
    const frameTime = timestamp - this.#lastFrameTime;
    this.#lastFrameTime = timestamp;

    // Update render time metric
    this.#metrics.set(MetricType.RENDER_TIME, {
      value: frameTime,
      timestamp: Date.now(),
    });
  }

  /**
   * Sample performance metrics
   * @private
   */
  #sampleMetrics() {
    const now = performance.now();
    const elapsed = now - this.#lastSampleTime;

    // Calculate FPS
    const fps = Math.round((1000 * this.#frameCount) / elapsed);
    this.#metrics.set(MetricType.FPS, {
      value: fps,
      timestamp: Date.now(),
    });

    // Store in history
    this.#fpsHistory.push(fps);
    if (this.#fpsHistory.length > this.#config.fpsHistorySize) {
      this.#fpsHistory.shift();
    }

    // Reset counters
    this.#frameCount = 0;
    this.#lastSampleTime = now;

    // Sample CPU and memory if available
    this.#sampleSystemMetrics();

    // Analyze metrics and apply optimizations if needed
    if (this.#config.autoOptimize) {
      this.#analyzePerformance();
    }

    // Publish metrics
    this.#publishMetrics();
  }

  /**
   * Sample system metrics like CPU and memory
   * @private
   */
  #sampleSystemMetrics() {
    // Memory usage
    if (performance.memory) {
      this.#metrics.set(MetricType.MEMORY, {
        value: performance.memory.usedJSHeapSize,
        timestamp: Date.now(),
      });
    }

    // CPU usage - not directly available in browsers
    // For a real implementation, you might track execution time
    // as a proxy for CPU load
  }

  /**
   * Analyze performance metrics and apply optimizations if needed
   * @private
   */
  #analyzePerformance() {
    // Check FPS performance
    const fps = this.#metrics.get(MetricType.FPS).value;
    const fpsThresholds = this.#config.thresholds[MetricType.FPS];

    // Determine optimization level based on FPS
    let requiredLevel = OptimizationLevel.NONE;

    if (fps <= fpsThresholds.critical) {
      requiredLevel = OptimizationLevel.CRITICAL;
    } else if (fps <= fpsThresholds.problematic) {
      requiredLevel = OptimizationLevel.HIGH;
    } else if (fps <= fpsThresholds.acceptable) {
      requiredLevel = OptimizationLevel.MEDIUM;
    } else if (fps < fpsThresholds.optimal) {
      requiredLevel = OptimizationLevel.LOW;
    }

    // Check if memory usage requires higher optimization level
    if (this.#metrics.has(MetricType.MEMORY)) {
      const memory = this.#metrics.get(MetricType.MEMORY).value;
      const memoryThresholds = this.#config.thresholds[MetricType.MEMORY];

      if (memory >= memoryThresholds.critical) {
        requiredLevel = Math.max(requiredLevel, OptimizationLevel.CRITICAL);
      } else if (memory >= memoryThresholds.problematic) {
        requiredLevel = Math.max(requiredLevel, OptimizationLevel.HIGH);
      } else if (memory >= memoryThresholds.acceptable) {
        requiredLevel = Math.max(requiredLevel, OptimizationLevel.MEDIUM);
      } else if (memory > memoryThresholds.optimal) {
        requiredLevel = Math.max(requiredLevel, OptimizationLevel.LOW);
      }
    }

    // Check render time
    const renderTime = this.#metrics.get(MetricType.RENDER_TIME).value;
    const renderThresholds = this.#config.thresholds[MetricType.RENDER_TIME];

    if (renderTime >= renderThresholds.critical) {
      requiredLevel = Math.max(requiredLevel, OptimizationLevel.CRITICAL);
    } else if (renderTime >= renderThresholds.problematic) {
      requiredLevel = Math.max(requiredLevel, OptimizationLevel.HIGH);
    } else if (renderTime >= renderThresholds.acceptable) {
      requiredLevel = Math.max(requiredLevel, OptimizationLevel.MEDIUM);
    } else if (renderTime > renderThresholds.optimal) {
      requiredLevel = Math.max(requiredLevel, OptimizationLevel.LOW);
    }

    // Apply optimizations if level needs to change
    if (requiredLevel !== this.#currentOptimizationLevel) {
      // Apply higher level immediately, but when improving, wait for stability
      if (requiredLevel > this.#currentOptimizationLevel) {
        this.applyOptimizations(requiredLevel);
      } else {
        // Require multiple samples below threshold before improving
        const consecutiveSamples = this.#fpsHistory.slice(-3);
        const allGood = consecutiveSamples.every(sample => {
          // Check if sample exceeds the threshold for the current level
          if (this.#currentOptimizationLevel === OptimizationLevel.LOW) {
            return sample >= fpsThresholds.optimal;
          } else if (this.#currentOptimizationLevel === OptimizationLevel.MEDIUM) {
            return sample >= fpsThresholds.acceptable;
          } else if (this.#currentOptimizationLevel === OptimizationLevel.HIGH) {
            return sample >= fpsThresholds.problematic;
          } else if (this.#currentOptimizationLevel === OptimizationLevel.CRITICAL) {
            return sample >= fpsThresholds.critical;
          }
          return true;
        });

        if (allGood && consecutiveSamples.length === 3) {
          this.applyOptimizations(requiredLevel);
        }
      }
    }
  }

  /**
   * Apply optimization strategies at the specified level
   * @private
   * @param {number} level - Optimization level
   */
  #applyOptimizationStrategies(level) {
    // Apply particle reduction
    const particleReduction = this.#config.optimizationLevels[OptimizationStrategy.REDUCE_PARTICLES][level];
    if (particleReduction) {
      this.#configManager.set(
        ConfigDomain.VISUALIZATION,
        'maxParticles',
        Math.floor(this.#getOriginalParticleCount() * particleReduction),
        ConfigPriority.PERFORMANCE
      );

      this.#appliedOptimizations.set(OptimizationStrategy.REDUCE_PARTICLES, particleReduction);
    }

    // Apply quality reduction
    const qualityReduction = this.#config.optimizationLevels[OptimizationStrategy.LOWER_QUALITY][level];
    if (qualityReduction) {
      this.#configManager.set(
        ConfigDomain.VISUALIZATION,
        'renderQuality',
        qualityReduction,
        ConfigPriority.PERFORMANCE
      );

      // Adjust shadow quality
      this.#configManager.set(
        ConfigDomain.VISUALIZATION,
        'shadowQuality',
        qualityReduction < 0.5 ? 'low' : 'medium',
        ConfigPriority.PERFORMANCE
      );

      this.#appliedOptimizations.set(OptimizationStrategy.LOWER_QUALITY, qualityReduction);
    }

    // Apply effect disabling
    const disabledEffects = this.#config.optimizationLevels[OptimizationStrategy.DISABLE_EFFECTS][level];
    if (disabledEffects && disabledEffects.length) {
      for (const effect of disabledEffects) {
        this.#configManager.set(
          ConfigDomain.VISUALIZATION,
          `enable${effect.charAt(0).toUpperCase() + effect.slice(1)}`,
          false,
          ConfigPriority.PERFORMANCE
        );
      }

      this.#appliedOptimizations.set(OptimizationStrategy.DISABLE_EFFECTS, disabledEffects);
    }

    // Apply trauma intensity reduction
    const traumaReduction = this.#config.optimizationLevels[OptimizationStrategy.REDUCE_TRAUMA_INTENSITY][level];
    if (traumaReduction) {
      this.#configManager.set(
        ConfigDomain.TRAUMA,
        'traumaIntensityMultiplier',
        traumaReduction,
        ConfigPriority.PERFORMANCE
      );

      this.#appliedOptimizations.set(OptimizationStrategy.REDUCE_TRAUMA_INTENSITY, traumaReduction);
    }

    this.#log(`Applied optimizations at level ${level}: ${Array.from(this.#appliedOptimizations.keys()).join(', ')}`);
  }

  /**
   * Reset optimizations to default values
   * @private
   */
  #resetOptimizations() {
    // Reset particle count
    this.#configManager.set(
      ConfigDomain.VISUALIZATION,
      'maxParticles',
      this.#getOriginalParticleCount(),
      ConfigPriority.DEFAULT
    );

    // Reset render quality
    this.#configManager.set(
      ConfigDomain.VISUALIZATION,
      'renderQuality',
      1.0,
      ConfigPriority.DEFAULT
    );

    // Reset shadow quality
    this.#configManager.set(
      ConfigDomain.VISUALIZATION,
      'shadowQuality',
      'high',
      ConfigPriority.DEFAULT
    );

    // Reset effects
    const effects = ['bloom', 'aberration', 'film', 'glitch'];
    for (const effect of effects) {
      this.#configManager.set(
        ConfigDomain.VISUALIZATION,
        `enable${effect.charAt(0).toUpperCase() + effect.slice(1)}`,
        true,
        ConfigPriority.DEFAULT
      );
    }

    // Reset trauma intensity
    this.#configManager.set(
      ConfigDomain.TRAUMA,
      'traumaIntensityMultiplier',
      1.0,
      ConfigPriority.DEFAULT
    );

    this.#log('Reset all optimizations to default values');
  }

  /**
   * Get original particle count from config or estimate
   * @private
   * @returns {number} Original particle count
   */
  #getOriginalParticleCount() {
    // Try to get from config
    const configParticles = this.#configManager.get(
      ConfigDomain.VISUALIZATION,
      'maxParticles'
    );

    if (configParticles && this.#currentOptimizationLevel === OptimizationLevel.NONE) {
      return configParticles;
    }

    // Get original particle count based on current count and level
    const currentCount = this.#configManager.get(
      ConfigDomain.VISUALIZATION,
      'maxParticles',
      2000
    );

    if (this.#currentOptimizationLevel === OptimizationLevel.NONE) {
      return currentCount;
    }

    // Calculate original count based on current level and reduction
    const currentReduction = this.#config.optimizationLevels[OptimizationStrategy.REDUCE_PARTICLES][this.#currentOptimizationLevel];
    if (currentReduction) {
      return Math.round(currentCount / currentReduction);
    }

    return window.innerWidth > 1200 ? 5000 : 2000; // Fallback to default
  }

  /**
   * Publish metrics to NeuralBus
   * @private
   */
  #publishMetrics() {
    if (!this.#neuralBusConnected) return;

    const metricsData = {};

    for (const [type, data] of this.#metrics.entries()) {
      metricsData[type] = data.value;
    }

    NeuralBus.publish('performance:metrics', {
      metrics: metricsData,
      fpsHistory: this.#fpsHistory.slice(-10), // Only send last 10 samples
      optimizationLevel: this.#currentOptimizationLevel,
      timestamp: Date.now(),
    });
  }

  /**
   * Notify user about optimizations being applied
   * @private
   * @param {number} level - Optimization level
   */
  #notifyOptimizationApplied(level) {
    // Use ConfigManager to check if notifications are enabled
    const notificationsEnabled = this.#configManager.get(
      ConfigDomain.USER_INTERFACE,
      'showPerformanceNotifications',
      true
    );

    if (!notificationsEnabled) return;

    // Get readable level name
    const levelNames = [
      'None',
      'Low',
      'Medium',
      'High',
      'Critical',
    ];

    const levelName = levelNames[level] || 'Unknown';

    // Publish notification event
    if (this.#neuralBusConnected) {
      NeuralBus.publish('system:notification', {
        type: 'performance',
        level: level >= OptimizationLevel.HIGH ? 'warning' : 'info',
        message: `Performance optimizations applied (${levelName})`,
        details: Array.from(this.#appliedOptimizations.keys())
          .map(strategy => strategy.replace(/-/g, ' '))
          .join(', '),
        timestamp: Date.now(),
        autoHide: level < OptimizationLevel.HIGH, // Auto-hide less severe notifications
      });
    }
  }

  /**
   * Handle performance request from NeuralBus
   * @private
   * @param {Object} data - Request data
   */
  #handlePerformanceRequest(data) {
    if (!data) return;

    // Send current metrics
    if (this.#neuralBusConnected) {
      NeuralBus.publish('performance:response', {
        requestId: data.requestId,
        metrics: this.getMetrics(),
        fpsHistory: this.getFpsHistory(),
        optimizationLevel: this.getOptimizationLevel(),
        appliedOptimizations: Array.from(this.getAppliedOptimizations().entries()),
        componentPerformance: this.getComponentPerformance(),
        timestamp: Date.now(),
      });
    }
  }

  /**
   * Handle optimization request from NeuralBus
   * @private
   * @param {Object} data - Request data
   */
  #handleOptimizationRequest(data) {
    if (!data || data.level === undefined) return;

    this.applyOptimizations(data.level, data.force);
  }

  /**
   * Handle reset request from NeuralBus
   * @private
   */
  #handleResetRequest() {
    this.reset();
    this.applyOptimizations(OptimizationLevel.NONE);
  }

  /**
   * Handle quantum mutation events
   * @private
   * @param {Object} data - Mutation data
   */
  #handleQuantumMutation(data) {
    // Track event latency
    if (data && data.timestamp) {
      const latency = Date.now() - data.timestamp;
      this.trackEventLatency('quantum:mutation', latency);
    }
  }

  /**
   * Handle trauma activation events
   * @private
   * @param {Object} data - Trauma activation data
   */
  #handleTraumaActivation(data) {
    // Track event latency
    if (data && data.timestamp) {
      const latency = Date.now() - data.timestamp;
      this.trackEventLatency('trauma:activated', latency);
    }

    // Adjust optimization based on trauma intensity
    if (data && data.intensity && data.intensity > 0.7 && this.#config.autoOptimize) {
      // High intensity trauma may require more aggressive optimizations
      const currentFps = this.#metrics.get(MetricType.FPS).value;

      if (currentFps < 40) {
        // If already struggling, apply higher optimization
        const newLevel = Math.min(
          OptimizationLevel.HIGH,
          this.#currentOptimizationLevel + 1
        );

        if (newLevel > this.#currentOptimizationLevel) {
          this.applyOptimizations(newLevel);
        }
      }
    }
  }

  /**
   * Log a message
   * @private
   * @param {string} message - Message to log
   * @param {boolean} isWarning - Whether this is a warning message
   */
  #log(message, isWarning = false) {
    if (isWarning) {
      this.#errorHandler.logWarning(message, {
        category: ErrorCategory.PERFORMANCE,
        code: 'PERFORMANCE_WARNING',
      });
    } else if (this.#config.debugMode) {
      this.#errorHandler.logDebug(message, {
        category: ErrorCategory.PERFORMANCE,
        code: 'PERFORMANCE_DEBUG',
      });
    }
  }
}

/**
 * Get the global performance monitor instance
 * @param {Object} config - Configuration options
 * @returns {PerformanceMonitor} Performance monitor instance
 */
export function getPerformanceMonitor(config = {}) {
  return new PerformanceMonitor(config);
}

// Create default instance
const defaultPerformanceMonitor = new PerformanceMonitor();

export default defaultPerformanceMonitor;
