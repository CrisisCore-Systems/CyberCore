/**
 * QEAR-CORE.JS
 * Quantum Engine AI Reactor Core
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * QEARCore
 * Quantum Engine AI Reactor - Dynamic mutation decision engine
 * 
 * The QEAR system makes autonomous decisions about when and how to 
 * apply mutations based on real-time factors including:
 * 
 * - Trauma type and intensity
 * - User interaction patterns
 * - Memory coherence level
 * - Recursion depth
 * - Time-based decay and amplification
 */
export class QEARCore {
  // Private properties
  #config = null;
  #initialized = false;
  #neuralBusConnected = false;
  #neuralNonce = null;
  #currentState = {
    activeProfile: null,
    coherence: 1.0,
    lastMutation: null,
    activeTraumas: new Map(),
    pendingMutations: [],
    currentPhase: 'stable'
  };
  #decisionMatrix = new Map();
  #mutationHistory = [];
  #entropyValues = new Float32Array(16);
  #debug = false;

  /**
   * Constructor
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    this.#config = {
      autoInitialize: true,
      coherenceThreshold: 0.5,
      debugMode: false,
      defaultProfile: 'CyberLotus',
      mutationInterval: 5000,
      coherenceDecayRate: 0.05,
      traumaIntensityMultiplier: 1.5,
      userInteractionWeight: 0.3,
      recursionDepthLimit: 5,
      ...config
    };
    
    this.#debug = this.#config.debugMode;
    
    if (this.#config.autoInitialize) {
      this.initialize();
    }
  }
  
  /**
   * Initialize the QEAR system
   */
  initialize() {
    if (this.#initialized) return this;
    
    this.#log('Initializing QEAR Core');
    
    // Generate initial entropy
    this.#generateEntropy();
    
    // Set up decision matrix
    this.#initializeDecisionMatrix();
    
    // Load any stored state
    this.#loadState();
    
    // Connect to Neural Bus
    this.#connectToNeuralBus();
    
    // Start decision loop
    this.#startDecisionLoop();
    
    this.#initialized = true;
    return this;
  }
  
  /**
   * Generate entropy for randomness
   * @private
   */
  #generateEntropy() {
    try {
      if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(this.#entropyValues);
      } else {
        // Fallback for environments without crypto
        for (let i = 0; i < this.#entropyValues.length; i++) {
          this.#entropyValues[i] = Math.random();
        }
      }
    } catch (error) {
      this.#log('Error generating entropy:', error);
      
      // Fallback
      for (let i = 0; i < this.#entropyValues.length; i++) {
        this.#entropyValues[i] = Math.random();
      }
    }
  }
  
  /**
   * Initialize the decision matrix with mutation profiles
   * @private
   */
  #initializeDecisionMatrix() {
    // Initialize with trauma-specific mutation rules
    this.#decisionMatrix.set('trauma_dissolution', {
      priority: 9,
      mutationTypes: ['fade', 'blur', 'ghost_trail'],
      coherenceRange: [0.1, 0.6],
      phase: 'rolling-virus',
      visualEffects: ['opacity-pulse', 'blur-transition'],
      audioEffects: ['low-frequency-hum'],
      intensity: 0.8
    });
    
    this.#decisionMatrix.set('trauma_recursion', {
      priority: 8,
      mutationTypes: ['echo_text', 'self-replicate', 'ui_loop'],
      triggerKeywords: ['memory', 'loop', 'again'],
      phase: 'cyber-lotus',
      visualEffects: ['text-repetition', 'fractal-echo'],
      audioEffects: ['echo-delay'],
      intensity: 0.7
    });
    
    this.#decisionMatrix.set('trauma_fragmentation', {
      priority: 7,
      mutationTypes: ['shatter', 'slice', 'fragment_ui'],
      coherenceRange: [0.2, 0.5],
      phase: 'obsidian-bloom',
      visualEffects: ['split-elements', 'pixel-sorting'],
      audioEffects: ['glitch-stutter'],
      intensity: 0.9
    });
    
    this.#decisionMatrix.set('trauma_surveillance', {
      priority: 6,
      mutationTypes: ['scan_lines', 'data_leak', 'glitch_text'],
      triggerKeywords: ['watching', 'seen', 'observed'],
      phase: 'neon-vortex',
      visualEffects: ['scan-line', 'static-noise'],
      audioEffects: ['transmission-static'],
      intensity: 0.6
    });
    
    this.#decisionMatrix.set('trauma_abandonment', {
      priority: 5,
      mutationTypes: ['fade_out', 'isolation', 'desaturate'],
      coherenceRange: [0.3, 0.7],
      phase: 'void-bloom',
      visualEffects: ['desaturation', 'vignette'],
      audioEffects: ['distant-reverb'],
      intensity: 0.5
    });
    
    // Profile-specific mutations
    this.#decisionMatrix.set('profile_cyberlotus', {
      priority: 4,
      mutationTypes: ['illuminate', 'transcend', 'neural_matrix'],
      coherenceRange: [0.5, 1.0],
      profile: 'CyberLotus',
      visualEffects: ['glow', 'brightness-pulse'],
      audioEffects: ['harmonic-tones'],
      intensity: 0.7
    });
    
    this.#decisionMatrix.set('profile_obsidianbloom', {
      priority: 4,
      mutationTypes: ['shadow', 'crystallize', 'depth_shift'],
      coherenceRange: [0.4, 0.8],
      profile: 'ObsidianBloom',
      visualEffects: ['shadow-pulse', 'crystalline-overlay'],
      audioEffects: ['deep-resonance'],
      intensity: 0.4
    });
    
    this.#decisionMatrix.set('profile_voidbloom', {
      priority: 5,
      mutationTypes: ['void_pulse', 'recursive_descent', 'echo_chamber'],
      coherenceRange: [0.2, 0.6],
      profile: 'VoidBloom',
      visualEffects: ['void-ripple', 'fractal-recursion'],
      audioEffects: ['void-whispers'],
      intensity: 0.85
    });
    
    this.#decisionMatrix.set('profile_neonvortex', {
      priority: 4,
      mutationTypes: ['energy_surge', 'spiral', 'amplify'],
      coherenceRange: [0.3, 0.9],
      profile: 'NeonVortex',
      visualEffects: ['neon-glow', 'spiral-motion'],
      audioEffects: ['rising-tone'],
      intensity: 0.6
    });
  }
  
  /**
   * Load saved state from storage
   * @private
   */
  #loadState() {
    try {
      const savedState = localStorage.getItem('qear_memory_cache');
      if (savedState) {
        const parsedState = JSON.parse(savedState);
        
        // Restore relevant state properties
        if (parsedState.activeProfile) {
          this.#currentState.activeProfile = parsedState.activeProfile;
        }
        
        if (parsedState.coherence !== undefined) {
          this.#currentState.coherence = parsedState.coherence;
        }
        
        if (parsedState.mutationHistory) {
          this.#mutationHistory = parsedState.mutationHistory.slice(0, 10);
        }
        
        this.#log('Loaded state from memory cache', this.#currentState.activeProfile);
      }
    } catch (error) {
      this.#log('Error loading state:', error);
    }
  }
  
  /**
   * Save current state to storage
   * @private
   */
  #saveState() {
    try {
      const stateToSave = {
        activeProfile: this.#currentState.activeProfile,
        coherence: this.#currentState.coherence,
        lastMutation: this.#currentState.lastMutation,
        mutationHistory: this.#mutationHistory.slice(0, 10),
        timestamp: Date.now()
      };
      
      localStorage.setItem('qear_memory_cache', JSON.stringify(stateToSave));
    } catch (error) {
      this.#log('Error saving state:', error);
    }
  }
  
  /**
   * Connect to Neural Bus for event communication
   * @private
   */
  #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('qear-core', {
          version: '1.0.0',
          capabilities: {
            autonomousMutation: true,
            traumaResponsive: true,
            decisionMatrix: Array.from(this.#decisionMatrix.keys())
          }
        });
        
        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;
        
        // Subscribe to relevant events
        NeuralBus.subscribe('trauma:activated', this.#handleTraumaEvent.bind(this));
        NeuralBus.subscribe('coherence:changed', this.#handleCoherenceChange.bind(this));
        NeuralBus.subscribe('user:interaction', this.#handleUserInteraction.bind(this));
        NeuralBus.subscribe('memory:node:viewed', this.#handleMemoryNodeViewed.bind(this));
        
        this.#log('Connected to Neural Bus');
      }
    } catch (error) {
      this.#log('Failed to connect to Neural Bus:', error);
    }
  }
  
  /**
   * Start the decision loop for autonomous mutations
   * @private
   */
  #startDecisionLoop() {
    // Set initial profile if none is active
    if (!this.#currentState.activeProfile) {
      this.#currentState.activeProfile = this.#config.defaultProfile;
    }
    
    // Process any pending mutations
    this.#processPendingMutations();
    
    // Start interval for coherence decay and periodic decisions
    setInterval(() => {
      // Gradually decay coherence
      this.#updateCoherence();
      
      // Make periodic decisions based on current state
      this.#makeDecision();
      
      // Save state periodically
      this.#saveState();
    }, this.#config.mutationInterval);
  }
  
  /**
   * Update coherence value with natural decay
   * @private
   */
  #updateCoherence() {
    // Natural coherence recovery over time (unless traumas are active)
    if (this.#currentState.activeTraumas.size === 0) {
      this.#currentState.coherence += this.#config.coherenceDecayRate / 2;
      
      // Cap at 1.0
      if (this.#currentState.coherence > 1.0) {
        this.#currentState.coherence = 1.0;
      }
    } else {
      // Decrease coherence when traumas are active
      this.#currentState.coherence -= this.#config.coherenceDecayRate;
      
      // Ensure coherence doesn't go below 0.1
      if (this.#currentState.coherence < 0.1) {
        this.#currentState.coherence = 0.1;
      }
    }
  }
  
  /**
   * Make a decision about whether to trigger a mutation
   * @private
   */
  #makeDecision() {
    // Skip if we already have pending mutations
    if (this.#currentState.pendingMutations.length > 0) {
      return this.#processPendingMutations();
    }
    
    // Get active traumas sorted by priority
    const activeTraumas = Array.from(this.#currentState.activeTraumas.values())
      .sort((a, b) => {
        const priorityA = this.#decisionMatrix.get(`trauma_${a.type}`)?.priority || 0;
        const priorityB = this.#decisionMatrix.get(`trauma_${b.type}`)?.priority || 0;
        return priorityB - priorityA;
      });
    
    // Check if we have active traumas that should trigger a mutation
    if (activeTraumas.length > 0) {
      const highestTrauma = activeTraumas[0];
      const traumaMatrix = this.#decisionMatrix.get(`trauma_${highestTrauma.type}`);
      
      if (traumaMatrix) {
        // Check if coherence is in range for this trauma
        const [minCoherence, maxCoherence] = traumaMatrix.coherenceRange || [0, 1];
        
        if (this.#currentState.coherence >= minCoherence && 
            this.#currentState.coherence <= maxCoherence) {
          
          // Determine which profile to use based on the trauma's phase
          const profile = this.#getProfileForPhase(traumaMatrix.phase);
          
          // Add mutation to pending queue
          this.#currentState.pendingMutations.push({
            type: traumaMatrix.mutationTypes[Math.floor(Math.random() * traumaMatrix.mutationTypes.length)],
            profile: profile,
            source: 'trauma',
            traumaType: highestTrauma.type,
            intensity: traumaMatrix.intensity,
            timestamp: Date.now()
          });
          
          this.#log(`Trauma-based mutation decision: ${highestTrauma.type}`);
          return this.#processPendingMutations();
        }
      }
    }
    
    // Check for profile-based mutations if no trauma mutations
    // This creates ambient/atmospheric mutations when no traumas are active
    const currentProfileMatrix = this.#decisionMatrix.get(`profile_${this.#currentState.activeProfile.toLowerCase()}`);
    
    if (currentProfileMatrix) {
      const [minCoherence, maxCoherence] = currentProfileMatrix.coherenceRange || [0, 1];
      
      // Only trigger if coherence is in range and we pass a random chance check
      if (this.#currentState.coherence >= minCoherence && 
          this.#currentState.coherence <= maxCoherence &&
          Math.random() < 0.3) { // 30% chance for ambient mutations
        
        // Add profile-based mutation to pending queue
        this.#currentState.pendingMutations.push({
          type: currentProfileMatrix.mutationTypes[Math.floor(Math.random() * currentProfileMatrix.mutationTypes.length)],
          profile: currentProfileMatrix.profile,
          source: 'ambient',
          intensity: currentProfileMatrix.intensity * (0.5 + Math.random() * 0.5), // Randomize intensity
          timestamp: Date.now()
        });
        
        this.#log(`Ambient mutation decision: ${currentProfileMatrix.profile}`);
        return this.#processPendingMutations();
      }
    }
  }
  
  /**
   * Process any pending mutations
   * @private
   */
  #processPendingMutations() {
    if (this.#currentState.pendingMutations.length === 0) return;
    
    // Get the next mutation to process
    const mutation = this.#currentState.pendingMutations.shift();
    
    // Execute the mutation
    this.#executeMutation(mutation);
    
    // Record the mutation
    this.#recordMutation(mutation);
  }
  
  /**
   * Execute a mutation by publishing to Neural Bus
   * @private
   * @param {Object} mutation - Mutation details
   */
  #executeMutation(mutation) {
    if (!this.#neuralBusConnected) return;
    
    // Prepare mutation data
    const mutationData = {
      profile: mutation.profile,
      type: mutation.type,
      intensity: mutation.intensity,
      source: 'qear-core',
      traumaType: mutation.traumaType,
      timestamp: Date.now(),
      coherence: this.#currentState.coherence,
      metadata: {
        decisionSource: mutation.source,
        recursionDepth: this.#getRecursionDepth()
      }
    };
    
    // Add trauma codes if trauma-based
    if (mutation.traumaType) {
      mutationData.traumaCodes = this.#generateTraumaCodes(mutation.traumaType);
    }
    
    // Publish quantum mutation event
    NeuralBus.publish('quantum:mutation', mutationData);
    
    // Update current state
    this.#currentState.activeProfile = mutation.profile;
    this.#currentState.lastMutation = {
      type: mutation.type,
      timestamp: Date.now()
    };
    
    this.#log('Executed mutation:', mutation.type, 'profile:', mutation.profile);
  }
  
  /**
   * Record a mutation in history
   * @private
   * @param {Object} mutation - Mutation details
   */
  #recordMutation(mutation) {
    // Add to history
    this.#mutationHistory.unshift({
      type: mutation.type,
      profile: mutation.profile,
      source: mutation.source,
      traumaType: mutation.traumaType,
      timestamp: Date.now(),
      coherence: this.#currentState.coherence
    });
    
    // Limit history size
    if (this.#mutationHistory.length > 20) {
      this.#mutationHistory.pop();
    }
  }
  
  /**
   * Generate trauma codes for a specific trauma type
   * @private
   * @param {string} traumaType - Type of trauma
   * @returns {Array} Array of trauma codes
   */
  #generateTraumaCodes(traumaType) {
    const codes = [];
    
    // Generate 1-3 trauma codes
    const codeCount = 1 + Math.floor(Math.random() * 3);
    
    for (let i = 0; i < codeCount; i++) {
      // Generate a unique code based on trauma type
      const codeBase = traumaType.substring(0, 4).toUpperCase();
      const entropyIndex = i % this.#entropyValues.length;
      const entropyValue = Math.floor(this.#entropyValues[entropyIndex] * 1000);
      
      codes.push(`${codeBase}-${entropyValue}`);
    }
    
    return codes;
  }
  
  /**
   * Handle trauma event from Neural Bus
   * @private
   * @param {Object} data - Trauma event data
   */
  #handleTraumaEvent(data) {
    if (!data || !data.type) return;
    
    // Add/update trauma in active traumas map
    this.#currentState.activeTraumas.set(data.type, {
      type: data.type,
      intensity: data.intensity || 0.5,
      timestamp: Date.now()
    });
    
    // Reduce coherence based on trauma intensity
    const coherenceDrop = (data.intensity || 0.5) * this.#config.traumaIntensityMultiplier;
    this.#currentState.coherence -= coherenceDrop;
    
    // Ensure coherence doesn't go below 0.1
    if (this.#currentState.coherence < 0.1) {
      this.#currentState.coherence = 0.1;
    }
    
    // Force immediate decision for high-intensity traumas
    if (data.intensity > 0.7) {
      this.#makeDecision();
    }
    
    this.#log('Trauma registered:', data.type, 'intensity:', data.intensity);
  }
  
  /**
   * Handle coherence change event from Neural Bus
   * @private
   * @param {Object} data - Coherence event data
   */
  #handleCoherenceChange(data) {
    if (!data || data.coherence === undefined) return;
    
    this.#currentState.coherence = data.coherence;
    this.#log('Coherence updated:', data.coherence);
    
    // Force decision if coherence drops below threshold
    if (data.coherence <= this.#config.coherenceThreshold) {
      this.#makeDecision();
    }
  }
  
  /**
   * Handle user interaction event from Neural Bus
   * @private
   * @param {Object} data - User interaction data
   */
  #handleUserInteraction(data) {
    if (!data) return;
    
    // Slightly boost coherence on positive interactions
    if (data.type === 'click' || data.type === 'hover') {
      this.#currentState.coherence += this.#config.userInteractionWeight * 0.1;
      
      // Cap at 1.0
      if (this.#currentState.coherence > 1.0) {
        this.#currentState.coherence = 1.0;
      }
    }
    
    // Check for specific interaction patterns that could trigger mutations
    if (data.productId && data.action === 'trauma_node_viewed') {
      // This might add a pending mutation based on the viewed node
      if (data.traumaType) {
        const traumaMatrix = this.#decisionMatrix.get(`trauma_${data.traumaType}`);
        
        if (traumaMatrix && Math.random() < 0.4) { // 40% chance to trigger on view
          const profile = this.#getProfileForPhase(traumaMatrix.phase);
          
          // Add mutation to pending queue
          this.#currentState.pendingMutations.push({
            type: traumaMatrix.mutationTypes[Math.floor(Math.random() * traumaMatrix.mutationTypes.length)],
            profile: profile,
            source: 'interaction',
            traumaType: data.traumaType,
            intensity: traumaMatrix.intensity * (data.recursionDepth || 1),
            timestamp: Date.now()
          });
          
          this.#log(`Interaction-based mutation triggered: ${data.traumaType}`);
          this.#processPendingMutations();
        }
      }
    }
  }
  
  /**
   * Handle memory node viewed event from Neural Bus
   * @private
   * @param {Object} data - Memory node data
   */
  #handleMemoryNodeViewed(data) {
    if (!data) return;
    
    // Process memory node view - similar to user interaction but specific to memory nodes
    if (data.nodeType === 'trauma') {
      // Reduce coherence slightly when viewing trauma nodes
      this.#currentState.coherence -= 0.05;
      
      // Ensure coherence doesn't go below 0.1
      if (this.#currentState.coherence < 0.1) {
        this.#currentState.coherence = 0.1;
      }
      
      this.#log('Memory node viewed:', data.nodeType, 'id:', data.nodeId);
    }
  }
  
  /**
   * Get appropriate profile for a specific phase
   * @private
   * @param {string} phase - Phase name
   * @returns {string} Profile name
   */
  #getProfileForPhase(phase) {
    switch (phase) {
    case 'cyber-lotus':
      return 'CyberLotus';
    case 'obsidian-bloom':
      return 'ObsidianBloom';
    case 'void-bloom':
      return 'VoidBloom';
    case 'rolling-virus':
    case 'neon-vortex':
      return 'NeonVortex';
    default:
      return this.#currentState.activeProfile || this.#config.defaultProfile;
    }
  }
  
  /**
   * Calculate current recursion depth
   * @private
   * @returns {number} Recursion depth
   */
  #getRecursionDepth() {
    // Count mutations of the same type in the recent history
    if (this.#mutationHistory.length === 0 || !this.#currentState.lastMutation) {
      return 1; // Base recursion level
    }
    
    const lastType = this.#currentState.lastMutation.type;
    let depth = 1;
    
    // Count consecutive mutations of the same type
    for (const mutation of this.#mutationHistory) {
      if (mutation.type === lastType) {
        depth++;
      } else {
        break;
      }
    }
    
    // Cap at configured limit
    return Math.min(depth, this.#config.recursionDepthLimit);
  }
  
  /**
   * Log debug messages
   * @private
   * @param  {...any} args - Log arguments
   */
  #log(...args) {
    if (this.#debug) {
      console.log('[QEAR]', ...args);
    }
  }
  
  /**
   * Get current QEAR state
   * @returns {Object} Current state
   */
  getState() {
    return {
      activeProfile: this.#currentState.activeProfile,
      coherence: this.#currentState.coherence,
      lastMutation: this.#currentState.lastMutation,
      activeTraumas: Array.from(this.#currentState.activeTraumas.values()),
      pendingMutations: this.#currentState.pendingMutations.length,
      mutationHistory: this.#mutationHistory.slice(0, 5)
    };
  }
  
  /**
   * Set debug mode
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    this.#debug = !!enabled;
    return this;
  }
  
  /**
   * Force a specific mutation to occur
   * @param {string} traumaType - Type of trauma
   * @param {number} intensity - Intensity (0-1)
   */
  forceMutation(traumaType, intensity = 0.7) {
    if (!this.#initialized) return;
    
    const traumaMatrix = this.#decisionMatrix.get(`trauma_${traumaType}`);
    
    if (traumaMatrix) {
      const profile = this.#getProfileForPhase(traumaMatrix.phase);
      
      // Add mutation to pending queue with high priority
      this.#currentState.pendingMutations.unshift({
        type: traumaMatrix.mutationTypes[Math.floor(Math.random() * traumaMatrix.mutationTypes.length)],
        profile: profile,
        source: 'manual',
        traumaType: traumaType,
        intensity: intensity,
        timestamp: Date.now()
      });
      
      // Process immediately
      this.#processPendingMutations();
    }
    
    return this;
  }
}

// Create global instance
window.QEARCore = QEARCore;
export default QEARCore;