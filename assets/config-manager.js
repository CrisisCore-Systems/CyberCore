/**
 * CONFIG-MANAGER.JS
 * Centralized configuration management system for CyberCore components
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-optimized
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { ErrorCategory, ErrorHandler } from './error-handler.js';
import { NeuralBus } from './neural-bus.js';

/**
 * Configuration domains for organization
 * @enum {string}
 */
export const ConfigDomain = {
  SYSTEM: 'system',
  USER_INTERFACE: 'ui',
  VISUALIZATION: 'visualization',
  TRAUMA: 'trauma',
  COHERENCE: 'coherence',
  QUANTUM: 'quantum',
  NETWORK: 'network',
  PERFORMANCE: 'performance',
  SECURITY: 'security',
  DIAGNOSTICS: 'diagnostics',
  USER_PREFERENCES: 'user-preferences',
};

/**
 * Configuration priority levels
 * Higher priority settings override lower priority ones
 * @enum {number}
 */
export const ConfigPriority = {
  DEFAULT: 0,          // Default values, lowest priority
  USER: 100,           // User preferences
  COHERENCE: 200,      // Coherence-based settings
  TRAUMA: 300,         // Trauma-based settings
  PERFORMANCE: 400,    // Performance optimizations
  SECURITY: 500,       // Security policies
  OVERRIDE: 1000,      // Manual overrides, highest priority
};

/**
 * Configuration persistence levels
 * @enum {string}
 */
export const ConfigPersistence = {
  SESSION: 'session',  // Persists for current session only
  LOCAL: 'local',      // Persists locally across sessions
  REMOTE: 'remote',    // Persists on server (if available)
  NONE: 'none',        // No persistence
};

/**
 * Configuration change types
 * @enum {string}
 */
export const ConfigChangeType = {
  SET: 'set',          // Single value set
  SET_MULTIPLE: 'set-multiple', // Multiple values set
  RESET: 'reset',      // Reset to default
  REMOVE: 'remove',    // Remove config key
  SCHEMA_UPDATED: 'schema-updated', // Schema changed
};

/**
 * Configuration manager for CyberCore systems
 * Provides a centralized way to manage settings across components
 */
export class ConfigManager {
  // Static instance for singleton pattern
  static #instance = null;

  // Private properties
  #config = {};
  #schemas = {};
  #defaults = {};
  #observers = {};
  #observerIdCounter = 0;
  #errorHandler = null;
  #neuralBusConnected = false;
  #neuralNonce = null;
  #storage = null;
  #persistenceEnabled = true;

  /**
   * Create a new ConfigManager (or return existing instance)
   * @param {Object} options - Configuration options
   */
  constructor(options = {}) {
    // Singleton pattern - return existing instance if available
    if (ConfigManager.#instance) {
      return ConfigManager.#instance;
    }

    // Set up error handler
    this.#errorHandler = options.errorHandler || new ErrorHandler({
      componentName: 'config-manager',
    });

    // Initialize configuration storage
    this.#initializeStorage(options.persistence || ConfigPersistence.LOCAL);

    // Set up domains
    this.#initializeConfigDomains();

    // Connect to NeuralBus
    this.#connectToNeuralBus();

    // Set as singleton instance
    ConfigManager.#instance = this;

    this.#log('ConfigManager initialized');
  }

  /**
   * Register configuration schema for a domain
   * @param {string} domain - Configuration domain
   * @param {Object} schema - JSON Schema for validation
   * @param {Object} defaults - Default values
   */
  registerSchema(domain, schema, defaults = {}) {
    try {
      if (!domain || typeof domain !== 'string') {
        throw new Error('Invalid domain');
      }

      if (!schema || typeof schema !== 'object') {
        throw new Error('Invalid schema');
      }

      // Ensure domain exists
      if (!this.#config[domain]) {
        this.#config[domain] = {};
      }

      // Store schema
      this.#schemas[domain] = schema;

      // Store defaults
      this.#defaults[domain] = defaults;

      // Set default values
      for (const [key, value] of Object.entries(defaults)) {
        this.set(domain, key, value, ConfigPriority.DEFAULT, false);
      }

      this.#log(`Schema registered for domain: ${domain}`);

      // Publish schema update event
      this.#publishConfigEvent(ConfigChangeType.SCHEMA_UPDATED, domain, null, null);

      return true;
    } catch (error) {
      this.#errorHandler.logError(`Failed to register schema for domain: ${domain}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_SCHEMA_REGISTRATION_FAILED',
        error,
        domain,
      });
      return false;
    }
  }

  /**
   * Set a configuration value
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} value - Configuration value
   * @param {number} priority - Priority level
   * @param {boolean} persist - Whether to persist the value
   * @returns {boolean} Whether the value was set
   */
  set(domain, key, value, priority = ConfigPriority.DEFAULT, persist = true) {
    try {
      if (!domain || !key) {
        throw new Error('Invalid domain or key');
      }

      // Ensure domain exists
      if (!this.#config[domain]) {
        this.#config[domain] = {};
      }

      // Ensure key exists
      if (!this.#config[domain][key]) {
        this.#config[domain][key] = {
          value: undefined,
          priority: ConfigPriority.DEFAULT,
        };
      }

      // Check if current priority is higher
      if (this.#config[domain][key].priority > priority) {
        this.#log(`Ignoring lower priority config change: ${domain}.${key}`, true);
        return false;
      }

      // Validate value against schema if available
      if (this.#schemas[domain]) {
        const isValid = this.#validateValue(domain, key, value);
        if (!isValid) {
          this.#log(`Invalid value for ${domain}.${key}: ${JSON.stringify(value)}`, true);
          return false;
        }
      }

      // Store previous value for reporting changes
      const previousValue = this.#config[domain][key].value;

      // Update value
      this.#config[domain][key] = {
        value,
        priority,
      };

      // Persist if requested
      if (persist && this.#persistenceEnabled) {
        this.#persistValue(domain, key, value, priority);
      }

      this.#log(`Config set: ${domain}.${key} = ${JSON.stringify(value)} (priority: ${priority})`);

      // Notify observers
      this.#notifyObservers(domain, key, value, previousValue);

      // Publish config event
      this.#publishConfigEvent(ConfigChangeType.SET, domain, key, value);

      return true;
    } catch (error) {
      this.#errorHandler.logError(`Failed to set config: ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_SET_FAILED',
        error,
        domain,
        key,
        value,
      });
      return false;
    }
  }

  /**
   * Set multiple configuration values at once
   * @param {string} domain - Configuration domain
   * @param {Object} values - Configuration values object
   * @param {number} priority - Priority level
   * @param {boolean} persist - Whether to persist the values
   * @returns {boolean} Whether all values were set
   */
  setMultiple(domain, values, priority = ConfigPriority.DEFAULT, persist = true) {
    try {
      if (!domain || !values || typeof values !== 'object') {
        throw new Error('Invalid domain or values');
      }

      let allSucceeded = true;
      const changes = {};

      // Set each value
      for (const [key, value] of Object.entries(values)) {
        const success = this.set(domain, key, value, priority, false); // Don't persist individual values
        if (success) {
          changes[key] = value;
        } else {
          allSucceeded = false;
        }
      }

      // Persist all changes at once if requested
      if (persist && this.#persistenceEnabled && Object.keys(changes).length > 0) {
        this.#persistDomain(domain);
      }

      // Publish config event for multiple values
      if (Object.keys(changes).length > 0) {
        this.#publishConfigEvent(ConfigChangeType.SET_MULTIPLE, domain, null, changes);
      }

      return allSucceeded;
    } catch (error) {
      this.#errorHandler.logError(`Failed to set multiple configs for domain: ${domain}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_SET_MULTIPLE_FAILED',
        error,
        domain,
        values,
      });
      return false;
    }
  }

  /**
   * Get a configuration value
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} defaultValue - Default value if not found
   * @returns {any} Configuration value
   */
  get(domain, key, defaultValue = undefined) {
    try {
      if (!domain || !key) {
        return defaultValue;
      }

      // Check if domain and key exist
      if (!this.#config[domain] || !this.#config[domain][key]) {
        // Return domain default if available
        if (this.#defaults[domain] && this.#defaults[domain][key] !== undefined) {
          return this.#defaults[domain][key];
        }
        return defaultValue;
      }

      return this.#config[domain][key].value;
    } catch (error) {
      this.#errorHandler.logError(`Failed to get config: ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_GET_FAILED',
        error,
        domain,
        key,
      });
      return defaultValue;
    }
  }

  /**
   * Get all configuration values for a domain
   * @param {string} domain - Configuration domain
   * @returns {Object} Configuration values
   */
  getDomain(domain) {
    try {
      if (!domain) {
        return {};
      }

      // Check if domain exists
      if (!this.#config[domain]) {
        // Return domain defaults if available
        if (this.#defaults[domain]) {
          return { ...this.#defaults[domain] };
        }
        return {};
      }

      // Convert domain config to simple object
      const result = {};
      for (const [key, entry] of Object.entries(this.#config[domain])) {
        result[key] = entry.value;
      }

      return result;
    } catch (error) {
      this.#errorHandler.logError(`Failed to get config domain: ${domain}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_GET_DOMAIN_FAILED',
        error,
        domain,
      });
      return {};
    }
  }

  /**
   * Get priority of a configuration value
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @returns {number} Priority level or -1 if not found
   */
  getPriority(domain, key) {
    try {
      if (!domain || !key) {
        return -1;
      }

      // Check if domain and key exist
      if (!this.#config[domain] || !this.#config[domain][key]) {
        return -1;
      }

      return this.#config[domain][key].priority;
    } catch (error) {
      this.#errorHandler.logError(`Failed to get config priority: ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_GET_PRIORITY_FAILED',
        error,
        domain,
        key,
      });
      return -1;
    }
  }

  /**
   * Reset configuration to default values
   * @param {string} domain - Configuration domain (optional)
   * @param {string} key - Configuration key (optional)
   * @returns {boolean} Whether the reset was successful
   */
  reset(domain = null, key = null) {
    try {
      // Reset specific key
      if (domain && key) {
        if (this.#defaults[domain] && this.#defaults[domain][key] !== undefined) {
          return this.set(domain, key, this.#defaults[domain][key], ConfigPriority.DEFAULT);
        }

        // Remove key if no default
        if (this.#config[domain] && this.#config[domain][key]) {
          delete this.#config[domain][key];

          // Persist changes
          if (this.#persistenceEnabled) {
            this.#persistDomain(domain);
          }

          // Notify observers
          this.#notifyObservers(domain, key, undefined, this.#config[domain][key]?.value);

          // Publish config event
          this.#publishConfigEvent(ConfigChangeType.REMOVE, domain, key, null);

          return true;
        }

        return false;
      }

      // Reset specific domain
      if (domain) {
        if (this.#defaults[domain]) {
          return this.setMultiple(domain, this.#defaults[domain], ConfigPriority.DEFAULT);
        }

        // Clear domain if no defaults
        if (this.#config[domain]) {
          this.#config[domain] = {};

          // Persist changes
          if (this.#persistenceEnabled) {
            this.#persistDomain(domain);
          }

          // Publish config event
          this.#publishConfigEvent(ConfigChangeType.RESET, domain, null, null);

          return true;
        }

        return false;
      }

      // Reset all domains
      for (const domainName of Object.keys(this.#config)) {
        if (this.#defaults[domainName]) {
          this.setMultiple(domainName, this.#defaults[domainName], ConfigPriority.DEFAULT);
        } else {
          this.#config[domainName] = {};
        }
      }

      // Persist all changes
      if (this.#persistenceEnabled) {
        this.#persistAll();
      }

      // Publish config event
      this.#publishConfigEvent(ConfigChangeType.RESET, null, null, null);

      return true;
    } catch (error) {
      this.#errorHandler.logError(`Failed to reset config: ${domain}${key ? '.' + key : ''}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_RESET_FAILED',
        error,
        domain,
        key,
      });
      return false;
    }
  }

  /**
   * Check if a configuration key exists
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @returns {boolean} Whether the key exists
   */
  has(domain, key) {
    if (!domain || !key) {
      return false;
    }

    return !!(this.#config[domain] && this.#config[domain][key]);
  }

  /**
   * Get a list of all domains
   * @returns {string[]} List of domain names
   */
  getDomains() {
    return Object.keys(this.#config);
  }

  /**
   * Get a list of all keys in a domain
   * @param {string} domain - Configuration domain
   * @returns {string[]} List of key names
   */
  getKeys(domain) {
    if (!domain || !this.#config[domain]) {
      return [];
    }

    return Object.keys(this.#config[domain]);
  }

  /**
   * Observe changes to a configuration value
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {Function} callback - Callback function(value, previousValue)
   * @returns {Function} Function to remove observer
   */
  observe(domain, key, callback) {
    try {
      if (!domain || !key || typeof callback !== 'function') {
        throw new Error('Invalid parameters for observe');
      }

      // Generate observer ID
      const observerId = this.#observerIdCounter++;

      // Ensure observer arrays exist
      if (!this.#observers[domain]) {
        this.#observers[domain] = {};
      }

      if (!this.#observers[domain][key]) {
        this.#observers[domain][key] = [];
      }

      // Add observer
      this.#observers[domain][key].push({
        id: observerId,
        callback,
      });

      this.#log(`Observer added for ${domain}.${key} (id: ${observerId})`);

      // Immediately notify observer with current value
      if (this.has(domain, key)) {
        const value = this.get(domain, key);
        try {
          callback(value, value);
        } catch (error) {
          this.#errorHandler.logError(`Observer callback error for ${domain}.${key}`, {
            category: ErrorCategory.CONFIGURATION,
            code: 'CONFIG_OBSERVER_CALLBACK_ERROR',
            error,
            domain,
            key,
            value,
          });
        }
      }

      // Return function to remove observer
      return () => {
        if (this.#observers[domain] && this.#observers[domain][key]) {
          const index = this.#observers[domain][key].findIndex(o => o.id === observerId);
          if (index !== -1) {
            this.#observers[domain][key].splice(index, 1);
            this.#log(`Observer removed for ${domain}.${key} (id: ${observerId})`);
          }
        }
      };
    } catch (error) {
      this.#errorHandler.logError(`Failed to add observer for ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_OBSERVE_FAILED',
        error,
        domain,
        key,
      });
      // Return no-op function
      return () => {};
    }
  }

  /**
   * Observe all changes to a domain
   * @param {string} domain - Configuration domain
   * @param {Function} callback - Callback function(key, value, previousValue)
   * @returns {Function} Function to remove observer
   */
  observeDomain(domain, callback) {
    try {
      if (!domain || typeof callback !== 'function') {
        throw new Error('Invalid parameters for observeDomain');
      }

      // Generate observer ID
      const observerId = this.#observerIdCounter++;

      // Ensure domain observer array exists
      if (!this.#observers[domain]) {
        this.#observers[domain] = {};
      }

      if (!this.#observers[domain]['*']) {
        this.#observers[domain]['*'] = [];
      }

      // Add domain observer
      this.#observers[domain]['*'].push({
        id: observerId,
        callback,
      });

      this.#log(`Domain observer added for ${domain} (id: ${observerId})`);

      // Return function to remove observer
      return () => {
        if (this.#observers[domain] && this.#observers[domain]['*']) {
          const index = this.#observers[domain]['*'].findIndex(o => o.id === observerId);
          if (index !== -1) {
            this.#observers[domain]['*'].splice(index, 1);
            this.#log(`Domain observer removed for ${domain} (id: ${observerId})`);
          }
        }
      };
    } catch (error) {
      this.#errorHandler.logError(`Failed to add domain observer for ${domain}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_OBSERVE_DOMAIN_FAILED',
        error,
        domain,
      });
      // Return no-op function
      return () => {};
    }
  }

  /**
   * Enable or disable configuration persistence
   * @param {boolean} enabled - Whether persistence is enabled
   */
  setPersistenceEnabled(enabled) {
    this.#persistenceEnabled = !!enabled;
    this.#log(`Persistence ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Import configuration from object
   * @param {Object} config - Configuration object
   * @param {number} priority - Priority level
   * @returns {boolean} Whether import was successful
   */
  import(config, priority = ConfigPriority.DEFAULT) {
    try {
      if (!config || typeof config !== 'object') {
        throw new Error('Invalid configuration object');
      }

      let success = true;

      // Import each domain
      for (const [domain, values] of Object.entries(config)) {
        if (typeof values === 'object') {
          const domainSuccess = this.setMultiple(domain, values, priority);
          if (!domainSuccess) {
            success = false;
          }
        }
      }

      return success;
    } catch (error) {
      this.#errorHandler.logError('Failed to import configuration', {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_IMPORT_FAILED',
        error,
      });
      return false;
    }
  }

  /**
   * Export configuration to object
   * @param {string[]} domains - Domains to export (null for all)
   * @returns {Object} Configuration object
   */
  export(domains = null) {
    try {
      const result = {};

      // Determine domains to export
      const domainsToExport = domains || Object.keys(this.#config);

      // Export each domain
      for (const domain of domainsToExport) {
        if (this.#config[domain]) {
          result[domain] = this.getDomain(domain);
        }
      }

      return result;
    } catch (error) {
      this.#errorHandler.logError('Failed to export configuration', {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_EXPORT_FAILED',
        error,
      });
      return {};
    }
  }

  /**
   * Get schema for a domain
   * @param {string} domain - Configuration domain
   * @returns {Object} JSON Schema
   */
  getSchema(domain) {
    if (!domain || !this.#schemas[domain]) {
      return null;
    }

    return { ...this.#schemas[domain] };
  }

  /**
   * Get default values for a domain
   * @param {string} domain - Configuration domain
   * @returns {Object} Default values
   */
  getDefaults(domain) {
    if (!domain || !this.#defaults[domain]) {
      return null;
    }

    return { ...this.#defaults[domain] };
  }

  /**
   * Initialize configuration domains
   * @private
   */
  #initializeConfigDomains() {
    // Initialize empty objects for each domain
    for (const domain of Object.values(ConfigDomain)) {
      this.#config[domain] = {};
      this.#observers[domain] = {};
    }
  }

  /**
   * Initialize storage for persistence
   * @private
   * @param {string} persistenceMode - Storage persistence mode
   */
  #initializeStorage(persistenceMode) {
    try {
      this.#persistenceEnabled = true;

      // Determine storage type
      switch (persistenceMode) {
      case ConfigPersistence.SESSION:
        if (typeof sessionStorage !== 'undefined') {
          this.#storage = {
            getItem: key => sessionStorage.getItem(key),
            setItem: (key, value) => sessionStorage.setItem(key, value),
            removeItem: key => sessionStorage.removeItem(key),
          };
        }
        break;

      case ConfigPersistence.LOCAL:
        if (typeof localStorage !== 'undefined') {
          this.#storage = {
            getItem: key => localStorage.getItem(key),
            setItem: (key, value) => localStorage.setItem(key, value),
            removeItem: key => localStorage.removeItem(key),
          };
        }
        break;

      case ConfigPersistence.REMOTE:
        // Remote storage would be implemented based on specific backend
        // This is a placeholder for future implementation
        this.#storage = null;
        this.#persistenceEnabled = false;
        break;

      case ConfigPersistence.NONE:
      default:
        this.#storage = null;
        this.#persistenceEnabled = false;
        break;
      }

      // Load persisted configuration
      if (this.#storage) {
        this.#loadPersistedConfig();
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to initialize storage', {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_STORAGE_INIT_FAILED',
        error,
        persistenceMode,
      });
      this.#storage = null;
      this.#persistenceEnabled = false;
    }
  }

  /**
   * Load persisted configuration from storage
   * @private
   */
  #loadPersistedConfig() {
    try {
      // Load each domain
      for (const domain of Object.keys(ConfigDomain)) {
        const storedData = this.#storage.getItem(`cybercore-config-${domain}`);
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);

            // Import values with their priorities
            for (const [key, entry] of Object.entries(parsedData)) {
              if (entry && entry.value !== undefined && entry.priority !== undefined) {
                // Create entry if it doesn't exist
                if (!this.#config[domain]) {
                  this.#config[domain] = {};
                }

                this.#config[domain][key] = {
                  value: entry.value,
                  priority: entry.priority,
                };
              }
            }
          } catch (parseError) {
            this.#errorHandler.logError(`Failed to parse persisted config for domain: ${domain}`, {
              category: ErrorCategory.CONFIGURATION,
              code: 'CONFIG_PARSE_FAILED',
              error: parseError,
              domain,
            });
          }
        }
      }

      this.#log('Loaded persisted configuration');
    } catch (error) {
      this.#errorHandler.logError('Failed to load persisted configuration', {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_LOAD_FAILED',
        error,
      });
    }
  }

  /**
   * Persist a configuration value to storage
   * @private
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} value - Configuration value
   * @param {number} priority - Priority level
   */
  #persistValue(domain, key, value, priority) {
    if (!this.#storage || !domain || !key) {
      return;
    }

    try {
      // Get current domain data
      const storedData = this.#storage.getItem(`cybercore-config-${domain}`);
      let parsedData = {};

      if (storedData) {
        try {
          parsedData = JSON.parse(storedData);
        } catch (parseError) {
          // If parsing fails, start with empty object
          parsedData = {};
        }
      }

      // Update value
      parsedData[key] = {
        value,
        priority,
      };

      // Store updated data
      this.#storage.setItem(`cybercore-config-${domain}`, JSON.stringify(parsedData));
    } catch (error) {
      this.#errorHandler.logError(`Failed to persist config: ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_PERSIST_FAILED',
        error,
        domain,
        key,
      });
    }
  }

  /**
   * Persist an entire configuration domain to storage
   * @private
   * @param {string} domain - Configuration domain
   */
  #persistDomain(domain) {
    if (!this.#storage || !domain || !this.#config[domain]) {
      return;
    }

    try {
      // Store domain data
      this.#storage.setItem(`cybercore-config-${domain}`, JSON.stringify(this.#config[domain]));
    } catch (error) {
      this.#errorHandler.logError(`Failed to persist config domain: ${domain}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_PERSIST_DOMAIN_FAILED',
        error,
        domain,
      });
    }
  }

  /**
   * Persist all configuration to storage
   * @private
   */
  #persistAll() {
    if (!this.#storage) {
      return;
    }

    try {
      // Store each domain
      for (const [domain, values] of Object.entries(this.#config)) {
        this.#storage.setItem(`cybercore-config-${domain}`, JSON.stringify(values));
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to persist all configuration', {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_PERSIST_ALL_FAILED',
        error,
      });
    }
  }

  /**
   * Validate a value against the schema
   * @private
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} value - Value to validate
   * @returns {boolean} Whether the value is valid
   */
  #validateValue(domain, key, value) {
    // Skip validation if no schema
    if (!this.#schemas[domain]) {
      return true;
    }

    try {
      const schema = this.#schemas[domain];

      // Check if schema has properties
      if (schema.properties && schema.properties[key]) {
        const propertySchema = schema.properties[key];

        // Type validation
        if (propertySchema.type) {
          const valueType = typeof value;
          const schemaType = propertySchema.type;

          // Handle array type specially
          if (schemaType === 'array' && !Array.isArray(value)) {
            return false;
          }

          // Handle number type specially (integer or number)
          if (schemaType === 'number' || schemaType === 'integer') {
            if (valueType !== 'number') {
              return false;
            }

            if (schemaType === 'integer' && !Number.isInteger(value)) {
              return false;
            }
          } else if (valueType !== schemaType && schemaType !== 'array') {
            // For other types, simple comparison
            return false;
          }
        }

        // Enum validation
        if (propertySchema.enum && !propertySchema.enum.includes(value)) {
          return false;
        }

        // Number range validation
        if (typeof value === 'number') {
          if (propertySchema.minimum !== undefined && value < propertySchema.minimum) {
            return false;
          }

          if (propertySchema.maximum !== undefined && value > propertySchema.maximum) {
            return false;
          }
        }

        // String length validation
        if (typeof value === 'string') {
          if (propertySchema.minLength !== undefined && value.length < propertySchema.minLength) {
            return false;
          }

          if (propertySchema.maxLength !== undefined && value.length > propertySchema.maxLength) {
            return false;
          }
        }

        // Array validation
        if (Array.isArray(value)) {
          if (propertySchema.minItems !== undefined && value.length < propertySchema.minItems) {
            return false;
          }

          if (propertySchema.maxItems !== undefined && value.length > propertySchema.maxItems) {
            return false;
          }
        }
      }

      return true;
    } catch (error) {
      this.#errorHandler.logError(`Validation error for ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_VALIDATION_ERROR',
        error,
        domain,
        key,
        value,
      });
      return false;
    }
  }

  /**
   * Notify observers of configuration changes
   * @private
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} value - New value
   * @param {any} previousValue - Previous value
   */
  #notifyObservers(domain, key, value, previousValue) {
    try {
      // Skip if no observers for this domain
      if (!this.#observers[domain]) {
        return;
      }

      // Notify key observers
      if (this.#observers[domain][key]) {
        for (const observer of this.#observers[domain][key]) {
          try {
            observer.callback(value, previousValue);
          } catch (error) {
            this.#errorHandler.logError(`Observer callback error for ${domain}.${key}`, {
              category: ErrorCategory.CONFIGURATION,
              code: 'CONFIG_OBSERVER_CALLBACK_ERROR',
              error,
              domain,
              key,
              value,
            });
          }
        }
      }

      // Notify domain observers
      if (this.#observers[domain]['*']) {
        for (const observer of this.#observers[domain]['*']) {
          try {
            observer.callback(key, value, previousValue);
          } catch (error) {
            this.#errorHandler.logError(`Domain observer callback error for ${domain}`, {
              category: ErrorCategory.CONFIGURATION,
              code: 'CONFIG_DOMAIN_OBSERVER_CALLBACK_ERROR',
              error,
              domain,
              key,
              value,
            });
          }
        }
      }
    } catch (error) {
      this.#errorHandler.logError(`Failed to notify observers for ${domain}.${key}`, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_NOTIFY_OBSERVERS_FAILED',
        error,
        domain,
        key,
        value,
      });
    }
  }

  /**
   * Connect to NeuralBus for event communication
   * @private
   */
  #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('config-manager', {
          version: '1.0.0',
          capabilities: {
            configurationManagement: true,
            schemaValidation: true,
          },
        });

        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;

        // Subscribe to configuration events
        NeuralBus.subscribe('config:request', this.#handleConfigRequest.bind(this));
        NeuralBus.subscribe('config:set', this.#handleConfigSet.bind(this));
        NeuralBus.subscribe('config:reset', this.#handleConfigReset.bind(this));

        this.#log('Connected to Neural Bus');
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to connect to Neural Bus', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'CONFIG_NEURALBUS_CONNECTION_FAILED',
        error,
      });
      this.#neuralBusConnected = false;
    }
  }

  /**
   * Publish configuration event to NeuralBus
   * @private
   * @param {string} changeType - Type of change
   * @param {string} domain - Configuration domain
   * @param {string} key - Configuration key
   * @param {any} value - Configuration value
   */
  #publishConfigEvent(changeType, domain, key, value) {
    if (!this.#neuralBusConnected) {
      return;
    }

    try {
      NeuralBus.publish('config:changed', {
        type: changeType,
        domain: domain,
        key: key,
        value: value,
        timestamp: Date.now(),
      });
    } catch (error) {
      this.#errorHandler.logError('Failed to publish config event', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'CONFIG_PUBLISH_EVENT_FAILED',
        error,
        changeType,
        domain,
        key,
      });
    }
  }

  /**
   * Handle configuration request from NeuralBus
   * @private
   * @param {Object} data - Request data
   */
  #handleConfigRequest(data) {
    if (!data || !this.#neuralBusConnected) {
      return;
    }

    try {
      let responseData = {};

      // Handle specific domain and key request
      if (data.domain && data.key) {
        responseData = {
          domain: data.domain,
          key: data.key,
          value: this.get(data.domain, data.key),
          priority: this.getPriority(data.domain, data.key),
        };
      }
      // Handle domain request
      else if (data.domain) {
        responseData = {
          domain: data.domain,
          values: this.getDomain(data.domain),
        };
      }
      // Handle schema request
      else if (data.schema) {
        const domain = data.schema;
        responseData = {
          schema: domain,
          definition: this.getSchema(domain),
          defaults: this.getDefaults(domain),
        };
      }
      // Handle all domains request
      else {
        responseData = {
          domains: this.getDomains(),
          config: this.export(),
        };
      }

      // Publish response
      NeuralBus.publish('config:response', {
        requestId: data.requestId,
        ...responseData,
        timestamp: Date.now(),
      });
    } catch (error) {
      this.#errorHandler.logError('Failed to handle config request', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'CONFIG_HANDLE_REQUEST_FAILED',
        error,
        request: data,
      });
    }
  }

  /**
   * Handle configuration set request from NeuralBus
   * @private
   * @param {Object} data - Set data
   */
  #handleConfigSet(data) {
    if (!data || !this.#neuralBusConnected) {
      return;
    }

    try {
      let success = false;

      // Handle multiple values
      if (data.domain && data.values && typeof data.values === 'object') {
        success = this.setMultiple(
          data.domain,
          data.values,
          data.priority || ConfigPriority.DEFAULT,
          data.persist !== false
        );
      }
      // Handle single value
      else if (data.domain && data.key) {
        success = this.set(
          data.domain,
          data.key,
          data.value,
          data.priority || ConfigPriority.DEFAULT,
          data.persist !== false
        );
      }

      // Publish response if request expects one
      if (data.requestId) {
        NeuralBus.publish('config:set:response', {
          requestId: data.requestId,
          success,
          timestamp: Date.now(),
        });
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to handle config set', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'CONFIG_HANDLE_SET_FAILED',
        error,
        request: data,
      });
    }
  }

  /**
   * Handle configuration reset request from NeuralBus
   * @private
   * @param {Object} data - Reset data
   */
  #handleConfigReset(data) {
    if (!data || !this.#neuralBusConnected) {
      return;
    }

    try {
      let success = false;

      // Handle domain and key reset
      if (data.domain && data.key) {
        success = this.reset(data.domain, data.key);
      }
      // Handle domain reset
      else if (data.domain) {
        success = this.reset(data.domain);
      }
      // Handle full reset
      else {
        success = this.reset();
      }

      // Publish response if request expects one
      if (data.requestId) {
        NeuralBus.publish('config:reset:response', {
          requestId: data.requestId,
          success,
          timestamp: Date.now(),
        });
      }
    } catch (error) {
      this.#errorHandler.logError('Failed to handle config reset', {
        category: ErrorCategory.NEURAL_BUS,
        code: 'CONFIG_HANDLE_RESET_FAILED',
        error,
        request: data,
      });
    }
  }

  /**
   * Log a message
   * @private
   * @param {string} message - Message to log
   * @param {boolean} isWarning - Whether this is a warning message
   */
  #log(message, isWarning = false) {
    if (isWarning) {
      this.#errorHandler.logWarning(message, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_WARNING',
      });
    } else {
      this.#errorHandler.logDebug(message, {
        category: ErrorCategory.CONFIGURATION,
        code: 'CONFIG_DEBUG',
      });
    }
  }
}

// Export default instance
export default new ConfigManager();
