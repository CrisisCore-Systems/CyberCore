/**
 * ERROR-HANDLER.JS
 * Unified error handling system for CyberCore components
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-resilient
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * CyberCore error levels
 * @enum {number}
 */
export const ErrorLevel = {
  DEBUG: 0,
  INFO: 1,
  WARNING: 2,
  ERROR: 3,
  CRITICAL: 4,
};

/**
 * Error categories for classification
 * @enum {string}
 */
export const ErrorCategory = {
  NEURAL_BUS: 'neural-bus',
  VISUALIZATION: 'visualization',
  PERSISTENCE: 'persistence',
  COHERENCE: 'coherence',
  TRAUMA: 'trauma',
  QUANTUM: 'quantum',
  SECURITY: 'security',
  NETWORKING: 'networking',
  PERFORMANCE: 'performance',
  MUTATION: 'mutation',
  SYSTEM: 'system',
  RENDERER: 'renderer',
  UNKNOWN: 'unknown',
};

/**
 * Error handler for CyberCore systems
 * Provides consistent error handling, recovery strategies, and reporting
 */
export class ErrorHandler {
  // Static instance for singleton pattern
  static #instance = null;

  // Private properties
  #config = {
    logToConsole: true,
    publishToNeuralBus: true,
    recoveryEnabled: true,
    errorHistoryLimit: 100,
    neuralBusErrorEvent: 'system:error',
    neuralBusWarningEvent: 'system:warning',
    suppressedErrors: new Set(),
    alertThresholds: {
      [ErrorLevel.WARNING]: 5,  // Warn after 5 warnings of same type
      [ErrorLevel.ERROR]: 3,    // Alert after 3 errors of same type
      [ErrorLevel.CRITICAL]: 1, // Immediate alert on critical errors
    },
    recoveryStrategies: new Map(),
    componentName: 'unknown',
  };

  #errorHistory = [];
  #errorCounts = new Map();
  #neuralBusConnected = false;
  #neuralNonce = null;

  /**
   * Create a new ErrorHandler (or return existing instance)
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    // Singleton pattern - return existing instance if available
    if (ErrorHandler.#instance) {
      // Update config if provided
      if (Object.keys(config).length > 0) {
        ErrorHandler.#instance.updateConfig(config);
      }
      return ErrorHandler.#instance;
    }

    // Configure new instance
    this.updateConfig(config);

    // Connect to NeuralBus if available
    this.#connectToNeuralBus();

    // Set as singleton instance
    ErrorHandler.#instance = this;

    // Log initialization
    this.logDebug('ErrorHandler initialized', {
      componentName: this.#config.componentName,
      recoveryEnabled: this.#config.recoveryEnabled
    });
  }

  /**
   * Update error handler configuration
   * @param {Object} config - New configuration options
   */
  updateConfig(config = {}) {
    // Merge with existing config
    this.#config = {
      ...this.#config,
      ...config,
      // Preserve object and map properties
      suppressedErrors: config.suppressedErrors
        ? new Set([...this.#config.suppressedErrors, ...config.suppressedErrors])
        : this.#config.suppressedErrors,
      alertThresholds: {
        ...this.#config.alertThresholds,
        ...(config.alertThresholds || {})
      },
      recoveryStrategies: config.recoveryStrategies
        ? new Map([...this.#config.recoveryStrategies, ...config.recoveryStrategies])
        : this.#config.recoveryStrategies,
    };
  }

  /**
   * Add a recovery strategy for a specific error
   * @param {string} errorCode - Error code or name to match
   * @param {Function} strategy - Recovery function to execute
   */
  addRecoveryStrategy(errorCode, strategy) {
    if (typeof strategy !== 'function') {
      throw new Error('Recovery strategy must be a function');
    }

    this.#config.recoveryStrategies.set(errorCode, strategy);
  }

  /**
   * Suppress a specific error code
   * @param {string} errorCode - Error code to suppress
   */
  suppressError(errorCode) {
    this.#config.suppressedErrors.add(errorCode);
  }

  /**
   * Restore a previously suppressed error
   * @param {string} errorCode - Error code to restore
   */
  restoreError(errorCode) {
    this.#config.suppressedErrors.delete(errorCode);
  }

  /**
   * Handle an error with appropriate logging and recovery
   * @param {Error|string} error - Error object or message
   * @param {Object} metadata - Additional error metadata
   * @param {string} metadata.category - Error category
   * @param {string} metadata.code - Error code
   * @param {number} metadata.level - Error level
   * @returns {boolean} Whether error was handled successfully
   */
  handleError(error, metadata = {}) {
    // Normalize error object
    const errorObj = this.#normalizeError(error, metadata);

    // Check if this error should be suppressed
    if (this.#config.suppressedErrors.has(errorObj.code)) {
      return true;
    }

    // Track error count for this code
    this.#incrementErrorCount(errorObj.code);

    // Store in history
    this.#addToHistory(errorObj);

    // Log to console if enabled
    if (this.#config.logToConsole) {
      this.#logToConsole(errorObj);
    }

    // Publish to NeuralBus if connected and enabled
    if (this.#neuralBusConnected && this.#config.publishToNeuralBus) {
      this.#publishToNeuralBus(errorObj);
    }

    // Check if we should trigger an alert based on thresholds
    this.#checkAlertThreshold(errorObj);

    // Attempt recovery if enabled
    let recoverySuccess = false;
    if (this.#config.recoveryEnabled) {
      recoverySuccess = this.#attemptRecovery(errorObj);
    }

    return recoverySuccess;
  }

  /**
   * Log a debug message
   * @param {string} message - Debug message
   * @param {Object} data - Additional debug data
   */
  logDebug(message, data = {}) {
    this.handleError(message, {
      level: ErrorLevel.DEBUG,
      category: data.category || ErrorCategory.UNKNOWN,
      code: data.code || 'DEBUG',
      ...data
    });
  }

  /**
   * Log an info message
   * @param {string} message - Info message
   * @param {Object} data - Additional info data
   */
  logInfo(message, data = {}) {
    this.handleError(message, {
      level: ErrorLevel.INFO,
      category: data.category || ErrorCategory.UNKNOWN,
      code: data.code || 'INFO',
      ...data
    });
  }

  /**
   * Log a warning
   * @param {string|Error} warning - Warning message or error
   * @param {Object} data - Additional warning data
   */
  logWarning(warning, data = {}) {
    this.handleError(warning, {
      level: ErrorLevel.WARNING,
      category: data.category || ErrorCategory.UNKNOWN,
      code: data.code || 'WARNING',
      ...data
    });
  }

  /**
   * Log an error
   * @param {string|Error} error - Error message or object
   * @param {Object} data - Additional error data
   */
  logError(error, data = {}) {
    this.handleError(error, {
      level: ErrorLevel.ERROR,
      category: data.category || ErrorCategory.UNKNOWN,
      code: data.code || 'ERROR',
      ...data
    });
  }

  /**
   * Log a critical error
   * @param {string|Error} error - Critical error message or object
   * @param {Object} data - Additional error data
   */
  logCritical(error, data = {}) {
    this.handleError(error, {
      level: ErrorLevel.CRITICAL,
      category: data.category || ErrorCategory.UNKNOWN,
      code: data.code || 'CRITICAL',
      ...data
    });
  }

  /**
   * Get error history
   * @param {Object} filters - Optional filters
   * @param {number} filters.level - Minimum error level to include
   * @param {string} filters.category - Filter by category
   * @param {number} filters.limit - Limit number of results
   * @returns {Array} Filtered error history
   */
  getErrorHistory(filters = {}) {
    let results = [...this.#errorHistory];

    // Apply filters
    if (filters.level !== undefined) {
      results = results.filter(error => error.level >= filters.level);
    }

    if (filters.category) {
      results = results.filter(error => error.category === filters.category);
    }

    // Apply limit (default to all)
    const limit = filters.limit || results.length;
    return results.slice(0, limit);
  }

  /**
   * Get current error counts by code
   * @returns {Map} Map of error counts by code
   */
  getErrorCounts() {
    return new Map(this.#errorCounts);
  }

  /**
   * Connect to NeuralBus for event communication
   * @private
   */
  #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('error-handler', {
          version: '1.0.0',
          capabilities: {
            errorHandling: true,
            recoveryStrategies: true,
            errorReporting: true,
          },
        });

        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;

        // Subscribe to error-related events
        NeuralBus.subscribe('system:recovery:request', this.#handleRecoveryRequest.bind(this));
        NeuralBus.subscribe('system:error:suppress', this.#handleErrorSuppress.bind(this));

        this.logDebug('Connected to Neural Bus', {
          category: ErrorCategory.NEURAL_BUS,
          code: 'NB_CONNECTED',
        });
      }
    } catch (error) {
      console.warn('Failed to connect ErrorHandler to Neural Bus:', error);
      this.#neuralBusConnected = false;
    }
  }

  /**
   * Handle a recovery request from NeuralBus
   * @private
   * @param {Object} data - Recovery request data
   */
  #handleRecoveryRequest(data) {
    if (!data || !data.errorCode) return;

    const strategy = this.#config.recoveryStrategies.get(data.errorCode);
    if (strategy) {
      try {
        strategy(data);

        this.logInfo(`Recovery triggered for ${data.errorCode}`, {
          category: ErrorCategory.SYSTEM,
          code: 'RECOVERY_TRIGGERED',
          source: 'neural-bus',
          errorCode: data.errorCode,
        });
      } catch (error) {
        this.logError('Recovery strategy failed', {
          category: ErrorCategory.SYSTEM,
          code: 'RECOVERY_FAILED',
          originalError: error,
          errorCode: data.errorCode,
        });
      }
    }
  }

  /**
   * Handle an error suppression request from NeuralBus
   * @private
   * @param {Object} data - Suppression request data
   */
  #handleErrorSuppress(data) {
    if (!data || !data.errorCode) return;

    if (data.suppress) {
      this.suppressError(data.errorCode);

      this.logDebug(`Error suppressed: ${data.errorCode}`, {
        category: ErrorCategory.SYSTEM,
        code: 'ERROR_SUPPRESSED',
      });
    } else {
      this.restoreError(data.errorCode);

      this.logDebug(`Error restored: ${data.errorCode}`, {
        category: ErrorCategory.SYSTEM,
        code: 'ERROR_RESTORED',
      });
    }
  }

  /**
   * Normalize error into standard format
   * @private
   * @param {Error|string} error - Error object or message
   * @param {Object} metadata - Additional error metadata
   * @returns {Object} Normalized error object
   */
  #normalizeError(error, metadata = {}) {
    const now = Date.now();

    // Base error object
    const errorObj = {
      message: '',
      stack: null,
      timestamp: now,
      category: metadata.category || ErrorCategory.UNKNOWN,
      level: metadata.level !== undefined ? metadata.level : ErrorLevel.ERROR,
      code: metadata.code || 'UNKNOWN_ERROR',
      component: this.#config.componentName,
      ...metadata,
    };

    // Handle different error types
    if (error instanceof Error) {
      errorObj.message = error.message;
      errorObj.stack = error.stack;
      errorObj.name = error.name;
      // Use error name as code if none provided
      if (!metadata.code) {
        errorObj.code = error.name;
      }
    } else if (typeof error === 'string') {
      errorObj.message = error;
    } else if (typeof error === 'object') {
      Object.assign(errorObj, error);
    }

    return errorObj;
  }

  /**
   * Increment error count for a specific code
   * @private
   * @param {string} errorCode - Error code
   */
  #incrementErrorCount(errorCode) {
    const currentCount = this.#errorCounts.get(errorCode) || 0;
    this.#errorCounts.set(errorCode, currentCount + 1);
  }

  /**
   * Add error to history
   * @private
   * @param {Object} error - Error object
   */
  #addToHistory(error) {
    this.#errorHistory.push(error);

    // Trim history if over limit
    if (this.#errorHistory.length > this.#config.errorHistoryLimit) {
      this.#errorHistory.shift();
    }
  }

  /**
   * Log error to console
   * @private
   * @param {Object} error - Error object
   */
  #logToConsole(error) {
    const prefix = `[CyberCore:${error.component}]`;

    switch (error.level) {
    case ErrorLevel.DEBUG:
      console.debug(prefix, error.message, error);
      break;
    case ErrorLevel.INFO:
      console.info(prefix, error.message, error);
      break;
    case ErrorLevel.WARNING:
      console.warn(prefix, error.message, error);
      break;
    case ErrorLevel.ERROR:
      console.error(prefix, error.message, error);
      break;
    case ErrorLevel.CRITICAL:
      console.error(`${prefix} [CRITICAL]`, error.message, error);
      break;
    default:
      console.log(prefix, error.message, error);
    }
  }

  /**
   * Publish error to NeuralBus
   * @private
   * @param {Object} error - Error object
   */
  #publishToNeuralBus(error) {
    try {
      if (!this.#neuralBusConnected) return;

      // Use warning or error events based on level
      const eventName = error.level >= ErrorLevel.ERROR
        ? this.#config.neuralBusErrorEvent
        : this.#config.neuralBusWarningEvent;

      NeuralBus.publish(eventName, {
        timestamp: error.timestamp,
        message: error.message,
        level: error.level,
        category: error.category,
        code: error.code,
        component: error.component,
        data: error.data,
      });
    } catch (e) {
      // Don't use handleError here to avoid recursion
      console.error('Failed to publish error to NeuralBus:', e);
    }
  }

  /**
   * Check if an alert threshold has been reached
   * @private
   * @param {Object} error - Error object
   */
  #checkAlertThreshold(error) {
    const threshold = this.#config.alertThresholds[error.level];
    if (!threshold) return;

    const count = this.#errorCounts.get(error.code) || 0;

    if (count === threshold) {
      // Alert threshold reached
      try {
        if (this.#neuralBusConnected) {
          NeuralBus.publish('system:alert', {
            timestamp: Date.now(),
            errorCode: error.code,
            count: count,
            level: error.level,
            message: `Alert threshold reached for ${error.code} (${count} occurrences)`,
            category: error.category,
            component: error.component,
          });
        }
      } catch (e) {
        console.error('Failed to publish alert to NeuralBus:', e);
      }
    }
  }

  /**
   * Attempt to recover from an error
   * @private
   * @param {Object} error - Error object
   * @returns {boolean} Whether recovery was successful
   */
  #attemptRecovery(error) {
    // Check if we have a recovery strategy for this error code
    const strategy = this.#config.recoveryStrategies.get(error.code);
    if (!strategy) return false;

    try {
      // Execute recovery strategy
      strategy(error);

      this.logInfo(`Recovery successful for ${error.code}`, {
        category: ErrorCategory.SYSTEM,
        code: 'RECOVERY_SUCCESS',
        recoveredError: error.code,
      });

      return true;
    } catch (recoveryError) {
      this.logError('Recovery strategy failed', {
        category: ErrorCategory.SYSTEM,
        code: 'RECOVERY_FAILED',
        originalError: error,
        recoveryError: recoveryError,
      });

      return false;
    }
  }
}

/**
 * Get the global error handler instance
 * @param {Object} config - Configuration to apply
 * @returns {ErrorHandler} Error handler instance
 */
export function getErrorHandler(config = {}) {
  return new ErrorHandler(config);
}

// Create default instance
const defaultErrorHandler = new ErrorHandler({
  componentName: 'system',
});

export default defaultErrorHandler;
