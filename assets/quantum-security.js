/**
 * QUANTUM-SECURITY.JS
 * Security utilities for CyberCore platform
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

/**
 * QuantumSecurity
 * Security utilities for protecting against XSS, CSRF, and other vulnerabilities
 */
export class QuantumSecurity {
  // Private static properties
  static #initialized = false;
  static #cspNonce = null;
  static #version = '1.0.0';
  static #debugMode = false;
  
  /**
   * Initialize the security module
   * @param {Object} options - Configuration options
   */
  static initialize(options = {}) {
    if (this.#initialized) return;
    
    this.#debugMode = options.debug || false;
    
    // Capture CSP nonce from meta tag
    const nonceElement = document.querySelector('meta[property="csp-nonce"]');
    if (nonceElement) {
      this.#cspNonce = nonceElement.getAttribute('content');
    }
    
    // Apply input sanitization to all forms
    this.#applyFormSanitization();
    
    // Hook into DOM mutations to sanitize any new content
    this.#observeDOMChanges();
    
    this.#initialized = true;
    this.#log('QuantumSecurity initialized', 'version', this.#version);
    
    // Patch NeuralBus if it exists to sanitize all published data
    if (typeof window !== 'undefined' && window.NeuralBus) {
      this.#patchNeuralBus();
    }
    
    return this;
  }
  
  /**
   * Apply input sanitization to all forms
   * @private
   */
  static #applyFormSanitization() {
    document.querySelectorAll('form').forEach(form => {
      form.addEventListener('submit', (event) => {
        const inputs = form.querySelectorAll('input[type="text"], input[type="search"], textarea');
        
        inputs.forEach(input => {
          input.value = this.sanitizeInput(input.value);
        });
      });
    });
    
    this.#log('Form sanitization applied');
  }
  
  /**
   * Observe DOM changes to sanitize new content
   * @private
   */
  static #observeDOMChanges() {
    if (!window.MutationObserver) return;
    
    const observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        if (mutation.type === 'childList' && mutation.addedNodes.length) {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) { // Element node
              this.#sanitizeElement(node);
            }
          });
        }
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    this.#log('DOM observer initialized');
  }
  
  /**
   * Sanitize a DOM element and its children
   * @private
   * @param {HTMLElement} element - Element to sanitize
   */
  static #sanitizeElement(element) {
    // Sanitize attributes
    if (element.hasAttributes()) {
      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes[i];
        
        // Check for potentially dangerous attributes
        if (attr.name.startsWith('on') || 
            attr.name === 'href' && attr.value.startsWith('javascript:') ||
            attr.name === 'src' && attr.value.startsWith('javascript:') || 
            attr.name === 'data-eval') {
            
          element.removeAttribute(attr.name);
          this.#log(`Removed dangerous attribute: ${attr.name}`);
        }
      }
    }
    
    // Recursively sanitize children
    if (element.children.length) {
      Array.from(element.children).forEach(child => {
        this.#sanitizeElement(child);
      });
    }
  }
  
  /**
   * Patch NeuralBus to sanitize all published data
   * @private
   */
  static #patchNeuralBus() {
    const originalPublish = window.NeuralBus.publish;
    
    window.NeuralBus.publish = (event, data, options = {}) => {
      // Sanitize data before publishing
      const sanitizedData = this.sanitizeObject(data);
      
      return originalPublish.call(window.NeuralBus, event, sanitizedData, options);
    };
    
    this.#log('NeuralBus patched for data sanitization');
  }
  
  /**
   * Sanitize user input to prevent XSS
   * @param {string} input - User input to sanitize
   * @returns {string} Sanitized input
   */
  static sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/`/g, '&#96;')
      .replace(/\$/g, '&#36;');
  }
  
  /**
   * Sanitize an HTML string
   * @param {string} html - HTML string to sanitize
   * @returns {string} Sanitized HTML
   */
  static sanitizeHTML(html) {
    if (typeof html !== 'string') return html;
    
    // Create a temporary element
    const temp = document.createElement('div');
    temp.textContent = html;
    
    // Return the sanitized HTML
    return temp.innerHTML;
  }
  
  /**
   * Sanitize an object or array recursively
   * @param {Object|Array} obj - Object to sanitize
   * @returns {Object|Array} Sanitized object
   */
  static sanitizeObject(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.sanitizeObject(item));
    }
    
    const sanitized = {};
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        sanitized[key] = this.sanitizeInput(value);
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeObject(value);
      } else {
        sanitized[key] = value;
      }
    }
    
    return sanitized;
  }
  
  /**
   * Generate a nonce for inline scripts
   * @returns {string} CSP nonce
   */
  static getNonce() {
    return this.#cspNonce;
  }
  
  /**
   * Validate a URL for safety
   * @param {string} url - URL to validate
   * @returns {boolean} Whether the URL is safe
   */
  static isSafeURL(url) {
    if (typeof url !== 'string') return false;
    
    // Trim the URL
    url = url.trim();
    
    // Check for javascript: protocol
    if (/^javascript:/i.test(url)) return false;
    
    // Check for data: protocol with HTML or script content
    if (/^data:text\/(html|javascript)/i.test(url)) return false;
    
    // Allow relative URLs and common protocols
    return /^(https?:\/\/|\/|#|mailto:|tel:)/.test(url) || url === '';
  }
  
  /**
   * Sanitize a URL for use in attributes
   * @param {string} url - URL to sanitize
   * @returns {string} Sanitized URL
   */
  static sanitizeURL(url) {
    if (typeof url !== 'string') return '#';
    
    return this.isSafeURL(url) ? url : '#';
  }
  
  /**
   * Add security headers to AJAX requests
   * @param {Object} options - Fetch options or XMLHttpRequest
   * @returns {Object} Options with security headers
   */
  static secureRequest(options = {}) {
    const secureOptions = { ...options };
    
    if (!secureOptions.headers) {
      secureOptions.headers = {};
    }
    
    // Add CSRF token if available
    const csrfToken = document.querySelector('meta[name="csrf-token"]');
    if (csrfToken) {
      secureOptions.headers['X-CSRF-Token'] = csrfToken.getAttribute('content');
    }
    
    // Set secure headers
    secureOptions.headers['X-Content-Type-Options'] = 'nosniff';
    
    return secureOptions;
  }
  
  /**
   * Log debug messages when debug mode is enabled
   * @private
   * @param {string} message - Message to log
   * @param {...any} args - Additional arguments to log
   */
  static #log(message, ...args) {
    if (!this.#debugMode) return;
    
    console.log(`[QuantumSecurity] ${message}`, ...args);
  }
  
  /**
   * Get version information
   * @returns {string} Version string
   */
  static getVersion() {
    return this.#version;
  }
}

// Auto-initialize when loaded if in browser environment
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    QuantumSecurity.initialize({ debug: window.location.search.includes('debug=true') });
    
    // Expose to global scope for external access
    window.QuantumSecurity = QuantumSecurity;
  });
}