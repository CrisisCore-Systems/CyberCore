/**
 * AR-BRIDGE.JS
 * Bridge for interacting with mobile AR capabilities
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * ARBridge
 * Provides a bridge between the web interface and device AR capabilities
 * 
 * Key Features:
 * - AR Quick Look integration for iOS
 * - Scene Viewer integration for Android
 * - AR mode state management
 * - Fallback for non-AR capable devices
 * - Integration with NeuralBus events
 */
export class ARBridge {
  // Private static fields
  static #initialized = false;
  static #config = {
    debug: false,
    autoInitialize: true,
    useQuantumEffects: true,
    arIndicatorSelector: '.ar-active-indicator',
    usdzExtension: 'usdz',
    glbExtension: 'glb',
    defaultModelPath: '/assets/models/',
    preferredFormat: 'glb',
    fallbackImagePath: '/assets/images/ar-fallback/',
    iosRedirectUrl: null,
    androidRedirectUrl: null
  };
  
  static #isARSupported = false;
  static #isQuickLookSupported = false;
  static #isSceneViewerSupported = false;
  static #currentARSession = null;
  static #activeModels = new Map();
  static #modelCache = new Map();
  static #arIndicator = null;
  static #neuralBusConnected = false;
  
  /**
   * Initialize the AR Bridge
   * @param {Object} options - Configuration options
   * @returns {Object} - ARBridge instance
   */
  static initialize(options = {}) {
    if (this.#initialized) {
      return this;
    }
    
    // Merge options with defaults
    this.#config = { ...this.#config, ...options };
    
    // Check AR support
    this.#checkARSupport();
    
    // Find AR indicator
    this.#arIndicator = document.querySelector(this.#config.arIndicatorSelector);
    
    // Connect to Neural Bus if available
    this.#connectToNeuralBus();
    
    // Set initialized flag
    this.#initialized = true;
    
    if (this.#config.debug) {
      console.log('[ARBridge] Initialized:', {
        arSupported: this.#isARSupported,
        quickLookSupported: this.#isQuickLookSupported,
        sceneViewerSupported: this.#isSceneViewerSupported
      });
    }
    
    // Return instance for chaining
    return this;
  }
  
  /**
   * Get AR support status
   * @returns {boolean} - Whether AR is supported
   */
  static isARSupported() {
    return this.#isARSupported;
  }
  
  /**
   * Check if a specific product has AR models
   * @param {string|number} productId - Product ID
   * @returns {boolean} - Whether product has AR models
   */
  static hasARModel(productId) {
    const product = this.#activeModels.get(productId.toString());
    return product !== undefined;
  }
  
  /**
   * Launch AR viewer for a product
   * @param {string|number} productId - Product ID
   * @param {Object} options - Launch options
   * @returns {boolean} - Whether AR viewer was launched
   */
  static launchAR(productId, options = {}) {
    if (!this.#initialized || !this.#isARSupported) {
      if (this.#config.debug) {
        console.warn('[ARBridge] Cannot launch AR: not initialized or not supported');
      }
      return false;
    }
    
    const id = productId.toString();
    
    // Get product model information
    const product = this.#activeModels.get(id);
    if (!product) {
      // Try to find model information from the DOM
      const modelUrl = this.#findModelUrlInDOM(id);
      if (modelUrl) {
        this.registerModel(id, modelUrl);
      } else {
        if (this.#config.debug) {
          console.warn(`[ARBridge] No model found for product ${id}`);
        }
        return false;
      }
    }
    
    // Get updated product information
    const updatedProduct = this.#activeModels.get(id) || {};
    
    // Merge with options
    const launchOptions = {
      modelUrl: updatedProduct.modelUrl,
      usdzUrl: updatedProduct.usdzUrl || updatedProduct.modelUrl,
      fallbackUrl: updatedProduct.fallbackUrl || this.#config.fallbackImagePath + id + '.jpg',
      title: options.title || updatedProduct.title || `Product ${id}`,
      variant: options.variant || updatedProduct.variant || null,
      ...options
    };
    
    // Show AR indicator
    this.#showARIndicator();
    
    // Launch appropriate AR viewer
    let launchResult = false;
    
    if (this.#isQuickLookSupported && launchOptions.usdzUrl) {
      launchResult = this.#launchQuickLook(launchOptions);
    } else if (this.#isSceneViewerSupported && launchOptions.modelUrl) {
      launchResult = this.#launchSceneViewer(launchOptions);
    } else {
      // Fallback
      launchResult = this.#launchARFallback(launchOptions);
    }
    
    // Publish event if successful
    if (launchResult) {
      this.#publishAREvent('ar:launched', {
        productId: id,
        options: launchOptions
      });
      
      // Set current AR session
      this.#currentARSession = {
        productId: id,
        startTime: Date.now(),
        options: launchOptions
      };
    }
    
    return launchResult;
  }
  
  /**
   * Register a 3D model for AR
   * @param {string|number} productId - Product ID
   * @param {string} modelUrl - URL to the 3D model
   * @param {Object} options - Additional options
   * @returns {Object} - ARBridge instance
   */
  static registerModel(productId, modelUrl, options = {}) {
    if (!this.#initialized) {
      this.initialize();
    }
    
    const id = productId.toString();
    
    // Determine USDZ URL for iOS
    let usdzUrl = options.usdzUrl || null;
    
    if (!usdzUrl && modelUrl) {
      // Try to infer USDZ URL from model URL
      if (modelUrl.endsWith(this.#config.glbExtension)) {
        usdzUrl = modelUrl.replace(
          `.${this.#config.glbExtension}`, 
          `.${this.#config.usdzExtension}`
        );
      }
    }
    
    // Store model information
    this.#activeModels.set(id, {
      id,
      modelUrl,
      usdzUrl,
      title: options.title || null,
      variant: options.variant || null,
      fallbackUrl: options.fallbackUrl || null,
      timestamp: Date.now()
    });
    
    if (this.#config.debug) {
      console.log(`[ARBridge] Registered model for product ${id}:`, {
        modelUrl,
        usdzUrl
      });
    }
    
    // Publish event
    this.#publishAREvent('ar:model:registered', {
      productId: id,
      modelUrl,
      usdzUrl
    });
    
    return this;
  }
  
  /**
   * Close current AR session
   * @returns {boolean} - Whether session was closed
   */
  static closeARSession() {
    if (!this.#currentARSession) {
      return false;
    }
    
    // Hide AR indicator
    this.#hideARIndicator();
    
    // Calculate session duration
    const duration = Date.now() - this.#currentARSession.startTime;
    
    // Publish event
    this.#publishAREvent('ar:closed', {
      productId: this.#currentARSession.productId,
      duration,
      options: this.#currentARSession.options
    });
    
    // Clear current session
    this.#currentARSession = null;
    
    return true;
  }
  
  /**
   * Notify that a product was added to cart
   * @param {string|number} productId - Product ID
   * @returns {boolean} - Whether notification was successful
   */
  static notifyProductAdded(productId) {
    if (!this.#initialized) {
      return false;
    }
    
    const id = productId.toString();
    
    // Check if product has AR model
    if (!this.hasARModel(id)) {
      return false;
    }
    
    // Publish event
    this.#publishAREvent('ar:product:added', {
      productId: id,
      hasActiveSession: this.#currentARSession !== null && this.#currentARSession.productId === id,
      timestamp: Date.now()
    });
    
    return true;
  }
  
  /**
   * Get a list of all registered models
   * @returns {Array} - Array of registered models
   */
  static getRegisteredModels() {
    return Array.from(this.#activeModels.values());
  }
  
  /**
   * Check if AR is currently active
   * @returns {boolean} - Whether AR is active
   */
  static isARActive() {
    return this.#currentARSession !== null;
  }
  
  /**
   * Find a model URL in the DOM
   * @private
   * @param {string} productId - Product ID
   * @returns {string|null} - Model URL or null if not found
   */
  static #findModelUrlInDOM(productId) {
    // Look for model URL in data attributes
    const modelElements = document.querySelectorAll(`[data-product-id="${productId}"][data-model-url]`);
    if (modelElements.length > 0) {
      return modelElements[0].dataset.modelUrl;
    }
    
    // Look for model URL in meta tags
    const metaTags = document.querySelectorAll(`meta[property="product:model:${productId}"]`);
    if (metaTags.length > 0) {
      return metaTags[0].getAttribute('content');
    }
    
    // Look for model URL in JSON script tags
    const scriptTags = document.querySelectorAll('script[type="application/json"]');
    for (const script of scriptTags) {
      try {
        const data = JSON.parse(script.textContent);
        if (data && data.models && data.models[productId]) {
          return data.models[productId].url;
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }
  
  /**
   * Check AR support on current device
   * @private
   */
  static #checkARSupport() {
    // Check if running in a browser
    if (typeof window === 'undefined' || typeof navigator === 'undefined') {
      this.#isARSupported = false;
      return;
    }
    
    // Check for iOS Quick Look support
    const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
    this.#isQuickLookSupported = isIOS && 'supporting' in HTMLLinkElement.prototype;
    
    // Check for Android Scene Viewer support
    const isAndroid = /Android/.test(navigator.userAgent);
    this.#isSceneViewerSupported = isAndroid && 'supportedProfiles' in navigator;
    
    // Overall AR support
    this.#isARSupported = this.#isQuickLookSupported || this.#isSceneViewerSupported;
  }
  
  /**
   * Launch iOS Quick Look
   * @private
   * @param {Object} options - Launch options
   * @returns {boolean} - Whether Quick Look was launched
   */
  static #launchQuickLook(options) {
    // Create anchor element
    const anchor = document.createElement('a');
    
    // Set AR attributes
    anchor.setAttribute('rel', 'ar');
    
    // Set USDZ source
    const usdzUrl = options.usdzUrl;
    if (!usdzUrl) {
      return false;
    }
    
    anchor.setAttribute('href', usdzUrl);
    
    // Set optional attributes
    if (options.title) {
      anchor.setAttribute('data-ar-title', options.title);
    }
    
    // Hide anchor
    anchor.style.display = 'none';
    document.body.appendChild(anchor);
    
    // Trigger click
    anchor.click();
    
    // Clean up
    setTimeout(() => {
      document.body.removeChild(anchor);
    }, 2000);
    
    return true;
  }
  
  /**
   * Launch Android Scene Viewer
   * @private
   * @param {Object} options - Launch options
   * @returns {boolean} - Whether Scene Viewer was launched
   */
  static #launchSceneViewer(options) {
    // Create intent URL
    const modelUrl = options.modelUrl;
    if (!modelUrl) {
      return false;
    }
    
    // Build Scene Viewer URL
    let sceneViewerUrl = `intent://arvr.google.com/scene-viewer/1.0?file=${encodeURIComponent(modelUrl)}`;
    
    // Add optional parameters
    if (options.title) {
      sceneViewerUrl += `&title=${encodeURIComponent(options.title)}`;
    }
    
    // Add mode
    sceneViewerUrl += '&mode=ar_preferred';
    
    // Add intent details
    sceneViewerUrl += '#Intent;scheme=https;package=com.google.android.googlequicksearchbox;action=android.intent.action.VIEW;end;';
    
    // Open URL
    window.location = sceneViewerUrl;
    
    return true;
  }
  
  /**
   * Launch fallback for devices without AR support
   * @private
   * @param {Object} options - Launch options
   * @returns {boolean} - Whether fallback was launched
   */
  static #launchARFallback(options) {
    // Create modal or redirect to fallback URL
    if (options.fallbackUrl) {
      // Create modal with 3D viewer
      this.#createFallbackModal(options);
      return true;
    } else if (this.#config.iosRedirectUrl && /iPhone|iPad|iPod/.test(navigator.userAgent)) {
      window.location = this.#config.iosRedirectUrl.replace('{id}', options.productId);
      return true;
    } else if (this.#config.androidRedirectUrl && /Android/.test(navigator.userAgent)) {
      window.location = this.#config.androidRedirectUrl.replace('{id}', options.productId);
      return true;
    }
    
    return false;
  }
  
  /**
   * Create fallback modal with 3D viewer
   * @private
   * @param {Object} options - Options
   */
  static #createFallbackModal(options) {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'ar-fallback-modal';
    
    // Create modal content
    modal.innerHTML = `
      <div class="ar-fallback-content">
        <div class="ar-fallback-header">
          <h3>${options.title || 'Product View'}</h3>
          <button class="ar-fallback-close">&times;</button>
        </div>
        <div class="ar-fallback-body">
          <img src="${options.fallbackUrl}" alt="${options.title || 'Product'}">
          <p class="ar-fallback-message">
            AR is not available on your device. 
            <br>Using fallback 2D view instead.
          </p>
        </div>
      </div>
    `;
    
    // Style the modal
    const style = document.createElement('style');
    style.textContent = `
      .ar-fallback-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }
      
      .ar-fallback-content {
        background-color: #1a1a1a;
        border-radius: 8px;
        max-width: 90%;
        width: 500px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }
      
      .ar-fallback-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #121212;
        border-bottom: 1px solid #333;
      }
      
      .ar-fallback-header h3 {
        margin: 0;
        color: #fff;
        font-size: 18px;
      }
      
      .ar-fallback-close {
        background: none;
        border: none;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      
      .ar-fallback-close:hover {
        opacity: 1;
      }
      
      .ar-fallback-body {
        padding: 20px;
        text-align: center;
      }
      
      .ar-fallback-body img {
        max-width: 100%;
        max-height: 300px;
        margin-bottom: 15px;
      }
      
      .ar-fallback-message {
        color: #999;
        font-size: 14px;
        margin: 0;
      }
    `;
    
    // Add style to document
    document.head.appendChild(style);
    
    // Add modal to document
    document.body.appendChild(modal);
    
    // Add close handler
    const closeButton = modal.querySelector('.ar-fallback-close');
    closeButton.addEventListener('click', () => {
      document.body.removeChild(modal);
      document.head.removeChild(style);
      this.closeARSession();
    });
  }
  
  /**
   * Show AR indicator
   * @private
   */
  static #showARIndicator() {
    if (this.#arIndicator) {
      this.#arIndicator.classList.add('active');
    }
  }
  
  /**
   * Hide AR indicator
   * @private
   */
  static #hideARIndicator() {
    if (this.#arIndicator) {
      this.#arIndicator.classList.remove('active');
    }
  }
  
  /**
   * Connect to Neural Bus
   * @private
   */
  static #connectToNeuralBus() {
    if (typeof NeuralBus !== 'undefined') {
      try {
        // Register with Neural Bus
        NeuralBus.register('ar-bridge', {
          version: '1.0.0',
          capabilities: {
            ar: this.#isARSupported,
            quicklook: this.#isQuickLookSupported,
            sceneviewer: this.#isSceneViewerSupported
          }
        });
        
        this.#neuralBusConnected = true;
        
        // Subscribe to relevant events
        NeuralBus.subscribe('product:view', (data) => {
          if (data && data.product && data.product.id) {
            // Check for model information in the product data
            const product = data.product;
            
            if (product.media && Array.isArray(product.media)) {
              const modelMedia = product.media.find(m => m.media_type === 'model');
              if (modelMedia && modelMedia.sources) {
                const glbSource = modelMedia.sources.find(s => s.format === 'glb');
                const usdzSource = modelMedia.sources.find(s => s.format === 'usdz');
                
                if (glbSource) {
                  this.registerModel(product.id, glbSource.url, {
                    usdzUrl: usdzSource ? usdzSource.url : null,
                    title: product.title
                  });
                }
              }
            }
          }
        });
        
        // Listen for AR launch requests
        NeuralBus.subscribe('ar:request:launch', (data) => {
          if (data && data.productId) {
            this.launchAR(data.productId, data.options || {});
          }
        });
        
        // Listen for AR close requests
        NeuralBus.subscribe('ar:request:close', () => {
          this.closeARSession();
        });
        
        if (this.#config.debug) {
          console.log('[ARBridge] Connected to Neural Bus');
        }
      } catch (error) {
        console.warn('[ARBridge] Failed to connect to Neural Bus:', error);
      }
    }
  }
  
  /**
   * Publish AR event to Neural Bus
   * @private
   * @param {string} eventName - Event name
   * @param {Object} data - Event data
   */
  static #publishAREvent(eventName, data) {
    if (this.#neuralBusConnected) {
      try {
        NeuralBus.publish(eventName, {
          ...data,
          timestamp: Date.now(),
          source: 'ar-bridge'
        });
        
        // Also dispatch DOM event
        const event = new CustomEvent(eventName, {
          detail: {
            ...data,
            timestamp: Date.now(),
            source: 'ar-bridge'
          }
        });
        
        document.dispatchEvent(event);
      } catch (error) {
        console.warn(`[ARBridge] Failed to publish event ${eventName}:`, error);
      }
    } else {
      // Just dispatch DOM event
      const event = new CustomEvent(eventName, {
        detail: {
          ...data,
          timestamp: Date.now(),
          source: 'ar-bridge'
        }
      });
      
      document.dispatchEvent(event);
    }
  }
}

// Auto-initialize if enabled
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      ARBridge.initialize();
    });
  } else {
    ARBridge.initialize();
  }
}