/**
 * ENHANCED-CART.JS
 * Advanced cart management with WebGL hologram integration
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { CartSystem } from './cart-system.js';
import HologramRenderer from './hologram-renderer.js';
import { NeuralBus } from './neural-bus.js';

// Define TypeScript-style interface for enhanced configuration
/**
 * @typedef {Object} EnhancedCartConfig
 * @property {boolean} useHolographicPreviews - Whether to use holographic previews
 * @property {boolean} useQuantumEffects - Whether to use quantum effects
 * @property {boolean} useWebGL - Whether to use WebGL for rendering
 * @property {boolean} useWorkers - Whether to use Web Workers for calculations
 * @property {string} profile - Mutation profile to use
 * @property {number} intensity - Effect intensity
 * @property {boolean} debug - Whether to enable debug mode
 */

/**
 * EnhancedCart
 * Advanced cart management with WebGL hologram integration
 */
export class EnhancedCart {
  // Static private properties
  static #config = {
    useHolographicPreviews: true,
    useQuantumEffects: true,
    useWebGL: true,
    useWorkers: true,
    profile: 'CyberLotus',
    intensity: 1.0,
    debug: false,
  };

  static #initialized = false;
  static #hologramComponents = new Map();
  static #worker = null;
  static #activeProduct = null;
  static #traumaCodes = [];
  static #currentProfile = 'CyberLotus';

  /**
   * Initialize the enhanced cart system
   * @param {EnhancedCartConfig} config - Configuration options
   * @returns {EnhancedCart} EnhancedCart instance
   */
  static initialize(config = {}) {
    // Only initialize once
    if (this.#initialized) return this;

    // Merge config with defaults
    this.#config = { ...this.#config, ...config };
    this.#currentProfile = this.#config.profile;

    // Initialize cart system first if not already initialized
    if (!CartSystem.initialized) {
      CartSystem.initialize({
        useHolographicPreviews: this.#config.useHolographicPreviews,
        useQuantumEffects: this.#config.useQuantumEffects,
        debug: this.#config.debug,
      });
    }

    // Initialize quantum worker if enabled
    if (this.#config.useWorkers) {
      this.#initWorker();
    }

    // Connect to NeuralBus
    this.#connectNeuralBus();

    // Find and initialize hologram components
    this.#initHologramComponents();

    // Apply current profile to the document
    this.applyProfile(this.#currentProfile);

    // Initialize WebGL if enabled
    if (this.#config.useWebGL && typeof HologramRenderer !== 'undefined') {
      // WebGL will be initialized when needed
      if (this.#config.debug) {
        console.log('[EnhancedCart] WebGL support available');
      }
    }

    this.#initialized = true;

    if (this.#config.debug) {
      console.log('[EnhancedCart] Initialized with config:', this.#config);
    }

    return this;
  }

  /**
   * Add a product to cart with enhanced effects
   * @param {Object} product - Product to add
   * @param {Object} options - Additional options
   * @returns {Promise} Promise that resolves when the product is added
   */
  static async addToCart(product, options = {}) {
    if (!this.#initialized) {
      this.initialize();
    }

    try {
      // Apply quantum effects if enabled
      if (this.#config.useQuantumEffects) {
        this.#triggerQuantumEffect('add', product);
      }

      // Add to cart using base CartSystem
      const result = await CartSystem.addItem({
        id: product.id,
        quantity: options.quantity || 1,
        properties: options.properties || {},
      });

      // Apply 3D preview if enabled and available
      if (this.#config.useHolographicPreviews && this.#config.useWebGL) {
        this.#updateHolographicPreview(product);
      }

      // Publish to NeuralBus
      NeuralBus.publish('enhanced-cart:item-added', {
        product,
        options,
        result,
        timestamp: Date.now(),
        profile: this.#currentProfile,
      });

      return result;
    } catch (error) {
      console.error('[EnhancedCart] Error adding product to cart:', error);

      // Publish error
      NeuralBus.publish('enhanced-cart:error', {
        error,
        context: 'addToCart',
        product,
        timestamp: Date.now(),
      });

      throw error;
    }
  }

  /**
   * Apply a mutation profile to the cart and UI
   * @param {string} profile - Profile name
   * @returns {EnhancedCart} EnhancedCart instance
   */
  static applyProfile(profile) {
    if (!profile) return this;

    this.#currentProfile = profile;

    // Apply to document body for CSS variables
    document.documentElement.classList.remove(
      'profile-cyberlotus',
      'profile-obsidianbloom',
      'profile-voidbloom',
      'profile-neonvortex'
    );
    document.documentElement.classList.add(`profile-${profile.toLowerCase()}`);
    document.documentElement.dataset.profile = profile.toLowerCase();

    // Update hologram components
    this.#hologramComponents.forEach((component) => {
      component.setAttribute('profile', profile);
    });

    // Apply to WebGL renderer if active
    if (this.#config.useWebGL && HologramRenderer.initialized) {
      HologramRenderer.applyQuantumEffects({
        profile,
        intensity: this.#config.intensity,
      });
    }

    // Notify via NeuralBus
    NeuralBus.publish('enhanced-cart:profile-changed', {
      profile,
      timestamp: Date.now(),
    });

    if (this.#config.debug) {
      console.log(`[EnhancedCart] Applied profile: ${profile}`);
    }

    return this;
  }

  /**
   * Set active trauma codes
   * @param {Array<string>} traumaCodes - Trauma effect codes
   * @returns {EnhancedCart} EnhancedCart instance
   */
  static setTraumaCodes(traumaCodes) {
    this.#traumaCodes = traumaCodes || [];

    // Apply trauma classes to document
    document.documentElement.classList.remove(
      'trauma-state-glitch',
      'trauma-state-void',
      'trauma-state-echo',
      'trauma-state-fracture'
    );

    // Add trauma classes based on codes
    this.#traumaCodes.forEach((code) => {
      const traumaType = code.split('-')[0];
      document.documentElement.classList.add(`trauma-state-${traumaType}`);
      document.documentElement.dataset.trauma = traumaType;
    });

    // Apply to hologram components
    this.#hologramComponents.forEach((component) => {
      if (typeof component.setTraumaCodes === 'function') {
        component.setTraumaCodes(traumaCodes);
      }
    });

    // Apply to WebGL renderer if active
    if (this.#config.useWebGL && HologramRenderer.initialized) {
      HologramRenderer.setTraumaCodes(traumaCodes);
    }

    // Process trauma patterns in worker if available
    if (this.#worker) {
      this.#worker.postMessage({
        type: 'process-trauma-patterns',
        data: {
          traumaCodes: this.#traumaCodes,
          intensity: this.#config.intensity,
        },
      });
    }

    return this;
  }

  /**
   * Initialize Web Worker
   * @private
   */
  static #initWorker() {
    try {
      this.#worker = new Worker('/assets/quantum-worker.js');

      this.#worker.addEventListener('message', (event) => {
        const { type, result, error } = event.data;

        if (error) {
          console.error('[EnhancedCart] Worker error:', error);
          return;
        }

        switch (type) {
          case 'quantum-state-result':
            this.#applyQuantumState(result);
            break;

          case 'trauma-patterns-result':
            this.#applyTraumaPatterns(result);
            break;

          case 'mutation-profile-result':
            this.#applyMutationProfile(result);
            break;
        }
      });

      if (this.#config.debug) {
        console.log('[EnhancedCart] Worker initialized');
      }
    } catch (error) {
      console.warn('[EnhancedCart] Web Worker initialization failed:', error);
      this.#config.useWorkers = false;
    }
  }

  /**
   * Initialize hologram components
   * @private
   */
  static #initHologramComponents() {
    // Find all custom elements
    const hologramElements = document.querySelectorAll('quantum-hologram');

    hologramElements.forEach((element, index) => {
      // Store reference
      this.#hologramComponents.set(`hologram-${index}`, element);

      // Configure element
      element.configure({
        intensity: this.#config.intensity,
        renderMode: this.#config.useWebGL ? 'quantum' : 'standard',
        enableGlitch: this.#config.useQuantumEffects,
        profile: this.#currentProfile,
      });

      // Set attributes
      element.setAttribute('profile', this.#currentProfile);

      if (this.#config.useQuantumEffects) {
        element.setAttribute('enable-glitch', '');
      }

      if (this.#config.debug) {
        console.log(`[EnhancedCart] Initialized hologram component #${index}`);
      }
    });

    // Watch for new hologram components with MutationObserver
    this.#observeHologramComponents();
  }

  /**
   * Connect to NeuralBus
   * @private
   */
  static #connectNeuralBus() {
    // Subscribe to relevant events
    NeuralBus.subscribe('cart:item-added', (data) => {
      if (this.#config.useQuantumEffects) {
        this.#triggerQuantumEffect('add', data.product);
      }
    });

    NeuralBus.subscribe('quantum:mutation', (data) => {
      if (data && data.profile) {
        this.applyProfile(data.profile);
      }

      if (data && data.traumaCodes) {
        this.setTraumaCodes(data.traumaCodes);
      }
    });

    NeuralBus.subscribe('product:view', (data) => {
      if (data && data.product) {
        this.#activeProduct = data.product;
        this.#updateHolographicPreview(data.product);
      }
    });

    // Register with NeuralBus
    NeuralBus.register('enhanced-cart', {
      version: '2.0.0',
      capabilities: {
        webgl: this.#config.useWebGL,
        workers: this.#config.useWorkers,
        quantumEffects: this.#config.useQuantumEffects,
        holographicPreviews: this.#config.useHolographicPreviews,
      },
    });
  }

  /**
   * Observe DOM for new hologram components
   * @private
   */
  static #observeHologramComponents() {
    // Create MutationObserver to watch for new hologram components
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName && node.nodeName.toLowerCase() === 'quantum-hologram') {
              const index = this.#hologramComponents.size;
              this.#hologramComponents.set(`hologram-${index}`, node);

              // Configure element
              node.configure({
                intensity: this.#config.intensity,
                renderMode: this.#config.useWebGL ? 'quantum' : 'standard',
                enableGlitch: this.#config.useQuantumEffects,
                profile: this.#currentProfile,
              });

              if (this.#config.debug) {
                console.log(`[EnhancedCart] Detected new hologram component #${index}`);
              }
            }
          });
        }
      });
    });

    // Start observing
    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  /**
   * Trigger a quantum effect
   * @private
   * @param {string} effectType - Type of effect
   * @param {Object} data - Effect data
   */
  static #triggerQuantumEffect(effectType, data) {
    // Apply effect to hologram components
    this.#hologramComponents.forEach((component) => {
      switch (effectType) {
        case 'add':
          component.classList.add('cart-added-pulse');
          setTimeout(() => {
            component.classList.remove('cart-added-pulse');
          }, 1000);

          if (component.glitchEnabled) {
            component.triggerGlitch(0.7, 300);
          }
          break;

        case 'remove':
          if (component.glitchEnabled) {
            component.triggerGlitch(0.5, 200);
          }
          break;

        case 'update':
          if (component.glitchEnabled) {
            component.triggerGlitch(0.3, 150);
          }
          break;
      }
    });

    // Apply effect to WebGL renderer if active
    if (this.#config.useWebGL && HologramRenderer.initialized) {
      switch (effectType) {
        case 'add':
          HologramRenderer.applyGlitch(0.7, 300);
          break;

        case 'remove':
          HologramRenderer.applyGlitch(0.5, 200);
          break;

        case 'update':
          HologramRenderer.applyGlitch(0.3, 150);
          break;
      }
    }

    // Publish event to NeuralBus
    NeuralBus.publish('enhanced-cart:effect-triggered', {
      type: effectType,
      data,
      timestamp: Date.now(),
    });
  }

  /**
   * Update holographic preview with product
   * @private
   * @param {Object} product - Product data
   */
  static #updateHolographicPreview(product) {
    if (!product) return;

    // Find product model URL
    const modelUrl = this.#findProductModelUrl(product);

    // Update WebGL renderer if available
    if (this.#config.useWebGL && HologramRenderer.initialized && modelUrl) {
      HologramRenderer.loadModel(modelUrl)
        .then(() => {
          HologramRenderer.applyQuantumEffects({
            profile: this.#currentProfile,
            intensity: this.#config.intensity,
            traumaCodes: this.#traumaCodes,
          });

          if (this.#config.debug) {
            console.log('[EnhancedCart] Updated holographic preview with model:', modelUrl);
          }
        })
        .catch((error) => {
          console.error('[EnhancedCart] Error loading model:', error);
        });
    }

    // Update hologram components
    this.#hologramComponents.forEach((component) => {
      if (typeof component.setProduct === 'function') {
        component.setProduct(product);
      }
    });
  }

  /**
   * Find 3D model URL in product data
   * @private
   * @param {Object} product - Product data
   * @returns {string|null} - Model URL or null if not found
   */
  static #findProductModelUrl(product) {
    if (!product) return null;

    // Check for model URL in product media
    if (product.media && Array.isArray(product.media)) {
      const modelMedia = product.media.find(
        (m) =>
          m.media_type === 'model' || m.media_type === '3d' || (m.alt && m.alt.includes('3d-model'))
      );

      if (modelMedia) {
        if (modelMedia.sources) {
          const glbSource = modelMedia.sources.find(
            (s) => s.format === 'glb' || s.url.endsWith('.glb')
          );
          if (glbSource) return glbSource.url;

          const gltfSource = modelMedia.sources.find(
            (s) => s.format === 'gltf' || s.url.endsWith('.gltf')
          );
          if (gltfSource) return gltfSource.url;
        }

        if (modelMedia.src) return modelMedia.src;
      }
    }

    // Check for model URL in product metafields
    if (product.metafields) {
      const modelMetafield = product.metafields.find(
        (m) =>
          (m.namespace === 'product' && m.key === 'model') ||
          (m.namespace === '3d' && m.key === 'model') ||
          (m.namespace === 'model' && m.key === 'url')
      );

      if (modelMetafield && modelMetafield.value) {
        return modelMetafield.value;
      }
    }

    // Fallback: Check for data attributes on product elements
    const productElement = document.querySelector(`[data-product-id="${product.id}"]`);
    if (productElement) {
      const modelUrl =
        productElement.dataset.modelUrl ||
        productElement.dataset.model ||
        productElement.getAttribute('data-3d-model');

      if (modelUrl) return modelUrl;
    }

    // No model found
    return null;
  }

  /**
   * Apply quantum state from worker
   * @private
   * @param {Object} state - Quantum state data
   */
  static #applyQuantumState(state) {
    // Apply to CSS variables
    if (state && state.particles) {
      document.documentElement.style.setProperty(
        '--quantum-stability',
        state.stabilityFactor.toFixed(2)
      );
    }

    // Publish to NeuralBus
    NeuralBus.publish('enhanced-cart:quantum-state-updated', {
      state,
      timestamp: Date.now(),
    });
  }

  /**
   * Apply trauma patterns from worker
   * @private
   * @param {Object} patterns - Trauma patterns data
   */
  static #applyTraumaPatterns(patterns) {
    // Apply to CSS variables
    if (patterns && patterns.stabilityIndex) {
      document.documentElement.style.setProperty(
        '--trauma-intensity',
        patterns.stabilityIndex.toFixed(2)
      );
    }

    // Publish to NeuralBus
    NeuralBus.publish('enhanced-cart:trauma-patterns-updated', {
      patterns,
      timestamp: Date.now(),
    });
  }

  /**
   * Apply mutation profile from worker
   * @private
   * @param {Object} profile - Mutation profile data
   */
  static #applyMutationProfile(profile) {
    if (!profile) return;

    // Apply CSS custom properties
    if (profile.colors) {
      Object.entries(profile.colors).forEach(([name, value]) => {
        document.documentElement.style.setProperty(`--color-${name}`, value);
      });
    }

    // Apply CSS animations
    if (profile.animations) {
      Object.entries(profile.animations).forEach(([name, value]) => {
        document.documentElement.style.setProperty(`--animation-${name}`, value);
      });
    }

    // Publish to NeuralBus
    NeuralBus.publish('enhanced-cart:profile-applied', {
      profile,
      timestamp: Date.now(),
    });
  }
}

// Auto-initialize when loaded if in browser environment
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    // Check if we should auto-initialize
    const shouldInit =
      !window.location.search.includes('disable-enhanced-cart') &&
      document.body.dataset.enhancedCart !== 'disabled';

    if (shouldInit) {
      EnhancedCart.initialize({
        debug: window.location.search.includes('debug=true'),
        profile: document.body.dataset.profile || 'CyberLotus',
      });

      // Expose to global scope
      window.EnhancedCart = EnhancedCart;
    }
  });
}

export default EnhancedCart;
