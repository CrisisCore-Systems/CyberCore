/**
 * QEAR-CONNECTOR.JS
 * Connector for QEAR system to interface with Neural Bus and track user interactions
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';
import QEARCore from './qear-core.js';

/**
 * QEARConnector
 * Connector module for the QEAR system that:
 * 1. Handles user interactions to track mutation traces
 * 2. Connects product views to the QEAR system
 * 3. Creates user-specific quantum memory tied to their session
 */
export class QEARConnector {
  // Private properties
  #config = null;
  #initialized = false;
  #qearCore = null;
  #userTracking = {
    interactions: [],
    viewedProducts: new Set(),
    traumaTrace: new Map(),
    sessionStartTime: Date.now(),
    interactionThreshold: 3
  };
  #debug = false;

  /**
   * Constructor
   * @param {Object} config - Configuration options
   * @param {QEARCore} qearInstance - Instance of QEAR Core or null to create new
   */
  constructor(config = {}, qearInstance = null) {
    this.#config = {
      autoInitialize: true,
      trackUserInteractions: true,
      interactionTraceLimit: 20,
      traumaMemoryLimit: 5,
      debugMode: false,
      trackingSelectors: {
        productCards: '.product-card, .product-item, [data-product-id]',
        traumaNodes: '[data-trauma], .trauma-node',
        userActions: 'a, button, .clickable, [role="button"]'
      },
      ...config
    };
    
    this.#debug = this.#config.debugMode;
    this.#qearCore = qearInstance || null;
    
    if (this.#config.autoInitialize) {
      this.initialize();
    }
  }
  
  /**
   * Initialize the connector
   */
  initialize() {
    if (this.#initialized) return this;
    
    this.#log('Initializing QEAR Connector');
    
    // Create QEAR Core instance if not provided
    if (!this.#qearCore) {
      this.#qearCore = new QEARCore({ 
        debugMode: this.#debug,
        autoInitialize: true
      });
    }
    
    // Set up event listeners
    this.#setupEventListeners();
    
    this.#initialized = true;
    return this;
  }
  
  /**
   * Set up event listeners for tracking user interactions
   * @private
   */
  #setupEventListeners() {
    if (typeof document === 'undefined') return;
    
    if (this.#config.trackUserInteractions) {
      // Track product views
      document.addEventListener('click', this.#handleUserClick.bind(this), { passive: true });
      document.addEventListener('mouseover', this.#handleUserHover.bind(this), { passive: true });
      
      // Set up mutation observer for dynamically added elements
      this.#setupMutationObserver();
      
      // Initial scan for visible trauma nodes
      this.#scanVisibleTraumaNodes();
    }
    
    // Listen for page visibility changes
    if (typeof document.visibilityState !== 'undefined') {
      document.addEventListener('visibilitychange', this.#handleVisibilityChange.bind(this));
    }
    
    // Listen for scroll events (throttled)
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      if (scrollTimeout) clearTimeout(scrollTimeout);
      
      scrollTimeout = setTimeout(() => {
        this.#handleUserScroll();
      }, 300); // Throttle to once every 300ms
    }, { passive: true });
    
    this.#log('Event listeners set up');
  }
  
  /**
   * Set up mutation observer to watch for DOM changes
   * @private
   */
  #setupMutationObserver() {
    if (typeof MutationObserver === 'undefined' || !document.body) return;
    
    const observer = new MutationObserver((mutations) => {
      // Check if any mutations added trauma nodes or product cards
      const shouldScan = mutations.some(mutation => {
        return Array.from(mutation.addedNodes).some(node => {
          if (node.nodeType !== Node.ELEMENT_NODE) return false;
          
          // Check if the node itself or any of its children match our selectors
          return node.matches?.(this.#config.trackingSelectors.traumaNodes) || 
                 node.querySelectorAll?.(this.#config.trackingSelectors.traumaNodes).length > 0 ||
                 node.matches?.(this.#config.trackingSelectors.productCards) ||
                 node.querySelectorAll?.(this.#config.trackingSelectors.productCards).length > 0;
        });
      });
      
      if (shouldScan) {
        this.#scanVisibleTraumaNodes();
      }
    });
    
    // Start observing
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  /**
   * Scan for visible trauma nodes
   * @private
   */
  #scanVisibleTraumaNodes() {
    if (typeof document === 'undefined') return;
    
    const traumaNodes = document.querySelectorAll(this.#config.trackingSelectors.traumaNodes);
    
    traumaNodes.forEach(node => {
      // Check if the node is visible in viewport
      const rect = node.getBoundingClientRect();
      const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
      
      if (isVisible) {
        this.#processTraumaNodeView(node);
      }
    });
  }
  
  /**
   * Process trauma node view
   * @private
   * @param {HTMLElement} node - Trauma node element
   */
  #processTraumaNodeView(node) {
    // Extract trauma data from node
    const traumaType = node.getAttribute('data-trauma') || 'unknown';
    const traumaIntensity = parseFloat(node.getAttribute('data-intensity') || '0.5');
    const productId = node.getAttribute('data-product-id') || null;
    const recursionDepth = parseInt(node.getAttribute('data-recursion-depth') || '1', 10);
    
    // Build trauma data
    const traumaData = {
      type: traumaType,
      intensity: traumaIntensity,
      productId: productId,
      recursionDepth: recursionDepth,
      nodeId: node.id || `trauma-${Math.random().toString(36).substring(2, 9)}`,
      timestamp: Date.now()
    };
    
    // Store in trauma trace
    this.#userTracking.traumaTrace.set(traumaType, traumaData);
    
    // Limit size of trauma trace
    if (this.#userTracking.traumaTrace.size > this.#config.traumaMemoryLimit) {
      // Remove oldest trauma (first item in the map)
      const firstKey = Array.from(this.#userTracking.traumaTrace.keys())[0];
      this.#userTracking.traumaTrace.delete(firstKey);
    }
    
    // Publish to Neural Bus
    if (typeof NeuralBus !== 'undefined') {
      NeuralBus.publish('trauma:activated', traumaData);
      
      // Also publish as user interaction with the specific action type
      NeuralBus.publish('user:interaction', {
        type: 'trauma_node_viewed',
        action: 'trauma_node_viewed',
        productId: productId,
        traumaType: traumaType,
        recursionDepth: recursionDepth,
        timestamp: Date.now()
      });
    }
    
    this.#log('Trauma node viewed:', traumaType, 'intensity:', traumaIntensity);
  }
  
  /**
   * Handle user click events
   * @private
   * @param {Event} event - Click event
   */
  #handleUserClick(event) {
    if (!event || !event.target) return;
    
    const target = event.target.closest(this.#config.trackingSelectors.userActions);
    
    if (target) {
      // Record interaction
      const interaction = {
        type: 'click',
        targetId: target.id || null,
        targetClass: target.className || null,
        href: target.getAttribute('href') || null,
        timestamp: Date.now()
      };
      
      // Add to interactions array
      this.#userTracking.interactions.push(interaction);
      
      // Limit size of interactions array
      if (this.#userTracking.interactions.length > this.#config.interactionTraceLimit) {
        this.#userTracking.interactions.shift();
      }
      
      // Check for product cards
      const productCard = event.target.closest(this.#config.trackingSelectors.productCards);
      if (productCard) {
        this.#handleProductInteraction(productCard, 'click');
      }
      
      // Check for trauma nodes
      const traumaNode = event.target.closest(this.#config.trackingSelectors.traumaNodes);
      if (traumaNode) {
        this.#processTraumaNodeView(traumaNode);
      }
      
      // Publish to Neural Bus
      if (typeof NeuralBus !== 'undefined') {
        NeuralBus.publish('user:interaction', {
          type: 'click',
          action: target.getAttribute('data-action') || 'click',
          targetId: target.id || null,
          timestamp: Date.now()
        });
      }
    }
  }
  
  /**
   * Handle user hover events
   * @private
   * @param {Event} event - Hover event
   */
  #handleUserHover(event) {
    if (!event || !event.target) return;
    
    // We only care about hovering over product cards and trauma nodes
    const productCard = event.target.closest(this.#config.trackingSelectors.productCards);
    if (productCard) {
      this.#handleProductInteraction(productCard, 'hover');
    }
    
    // Check for trauma nodes
    const traumaNode = event.target.closest(this.#config.trackingSelectors.traumaNodes);
    if (traumaNode) {
      // Only process if we haven't recently processed this same node
      // This prevents multiple events when hovering over the node
      const traumaType = traumaNode.getAttribute('data-trauma') || 'unknown';
      const lastProcessed = this.#userTracking.traumaTrace.get(traumaType)?.timestamp || 0;
      
      // If it's been at least 2 seconds since we last processed this trauma
      if (Date.now() - lastProcessed > 2000) {
        this.#processTraumaNodeView(traumaNode);
      }
    }
  }
  
  /**
   * Handle user scroll events
   * @private
   */
  #handleUserScroll() {
    // When the user scrolls, scan for visible trauma nodes
    this.#scanVisibleTraumaNodes();
    
    // Publish scroll interaction
    if (typeof NeuralBus !== 'undefined') {
      NeuralBus.publish('user:interaction', {
        type: 'scroll',
        scrollY: window.scrollY,
        timestamp: Date.now()
      });
    }
  }
  
  /**
   * Handle visibility change events
   * @private
   */
  #handleVisibilityChange() {
    if (document.visibilityState === 'visible') {
      // User has returned to the page
      this.#scanVisibleTraumaNodes();
      
      // Publish visibility event
      if (typeof NeuralBus !== 'undefined') {
        NeuralBus.publish('user:interaction', {
          type: 'visibility',
          action: 'page_visible',
          timestamp: Date.now()
        });
      }
    }
  }
  
  /**
   * Handle product interaction
   * @private
   * @param {HTMLElement} productElement - Product element
   * @param {string} interactionType - Type of interaction
   */
  #handleProductInteraction(productElement, interactionType) {
    if (!productElement) return;
    
    // Extract product data
    const productId = productElement.getAttribute('data-product-id') || 
                      productElement.getAttribute('id') ||
                      `product-${Math.random().toString(36).substring(2, 9)}`;
    
    // Build product data
    const productData = {
      productId: productId,
      interactionType: interactionType,
      timestamp: Date.now(),
      // Get any trauma data from the product
      traumaType: productElement.getAttribute('data-trauma') || null,
      traumaIntensity: parseFloat(productElement.getAttribute('data-intensity') || '0'),
      recursionDepth: parseInt(productElement.getAttribute('data-recursion-depth') || '1', 10)
    };
    
    // Mark product as viewed
    this.#userTracking.viewedProducts.add(productId);
    
    // Publish to Neural Bus
    if (typeof NeuralBus !== 'undefined') {
      // Publish product view
      NeuralBus.publish('product:view', productData);
      
      // Also publish as user interaction with the specific action type
      NeuralBus.publish('user:interaction', {
        type: interactionType,
        action: 'product_' + interactionType,
        productId: productId,
        traumaType: productData.traumaType,
        recursionDepth: productData.recursionDepth,
        timestamp: Date.now()
      });
      
      // If this product has trauma data, also emit a trauma event
      if (productData.traumaType) {
        NeuralBus.publish('trauma:activated', {
          type: productData.traumaType,
          intensity: productData.traumaIntensity,
          productId: productId,
          source: 'product_interaction',
          recursionDepth: productData.recursionDepth,
          timestamp: Date.now()
        });
      }
    }
    
    this.#log('Product interaction:', interactionType, 'product:', productId);
  }
  
  /**
   * Transmit user interaction data to Neural Bus
   * @param {string} action - Action name
   * @param {Object} data - Action data
   */
  transmit(action, data = {}) {
    if (!this.#initialized) return;
    
    const transmitData = {
      action: action,
      ...data,
      timestamp: Date.now()
    };
    
    // Add to interactions
    this.#userTracking.interactions.push({
      type: 'transmit',
      action: action,
      data: data,
      timestamp: Date.now()
    });
    
    // Limit size of interactions array
    if (this.#userTracking.interactions.length > this.#config.interactionTraceLimit) {
      this.#userTracking.interactions.shift();
    }
    
    // Publish to Neural Bus
    if (typeof NeuralBus !== 'undefined') {
      NeuralBus.publish('user:interaction', transmitData);
    }
    
    this.#log('Transmit:', action, data);
    return this;
  }
  
  /**
   * Get user tracking data
   * @returns {Object} User tracking data
   */
  getUserTrackingData() {
    return {
      interactions: [...this.#userTracking.interactions],
      viewedProducts: Array.from(this.#userTracking.viewedProducts),
      traumaTrace: Object.fromEntries(this.#userTracking.traumaTrace),
      sessionDuration: Date.now() - this.#userTracking.sessionStartTime
    };
  }
  
  /**
   * Get QEAR Core instance
   * @returns {QEARCore} QEAR Core instance
   */
  getQEARCore() {
    return this.#qearCore;
  }
  
  /**
   * Log debug messages
   * @private
   * @param  {...any} args - Log arguments
   */
  #log(...args) {
    if (this.#debug) {
      console.log('[QEAR Connector]', ...args);
    }
  }
  
  /**
   * Set debug mode
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    this.#debug = !!enabled;
    
    // Update QEAR Core debug mode as well
    if (this.#qearCore) {
      this.#qearCore.setDebugMode(enabled);
    }
    
    return this;
  }
}

// Create and export global instance
window.QEARConnector = QEARConnector;
export default QEARConnector;