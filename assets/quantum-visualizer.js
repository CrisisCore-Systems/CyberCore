/**
 * QUANTUM-VISUALIZER.JS
 * Quantum state visualization engine for CyberCore
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * QuantumVisualizer
 * Advanced visualization component for rendering quantum state data
 * with fractal patterns and dimensional shifting
 */
export class QuantumVisualizer {
  // Private properties
  #container = null;
  #canvas = null;
  #ctx = null;
  #neuralBusConnected = false;
  #config = null;
  #currentState = [];
  #rafId = null;
  #isRunning = false;
  #particles = [];
  #lastRenderTime = 0;
  #fpsLimit = 60;
  #neuralNonce = null;
  #colorMap = new Map();
  #profileColors = {
    'CyberLotus': ['#00ffff', '#0088ff', '#80ffff'],
    'ObsidianBloom': ['#ff00ff', '#8800ff', '#ff80ff'],
    'VoidBloom': ['#9900ff', '#6600cc', '#cc80ff'],
    'NeonVortex': ['#00ff66', '#00cc44', '#80ffaa']
  };
  #fractalPatterns = [];
  #hologramComponent = null;
  #dataHistory = [];
  #mutationHistory = [];
  
  /**
   * Constructor - Initialize with optional configuration
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    // Set initial configuration
    this.#config = {
      dimensions: config.dimensions || '3d',
      particleCount: config.particleCount || 1000,
      colorScheme: config.colorScheme || null,
      container: config.container || null,
      fractalMode: config.fractalMode || false,
      fractalDepth: config.fractalDepth || 3,
      neuralSynced: config.neuralSynced !== undefined ? config.neuralSynced : true,
      updateFrequency: config.updateFrequency || 16,
      onStateChange: config.onStateChange || (() => {}),
      debug: config.debug || false
    };
    
    // Initialize public properties for test compatibility
    this.initialized = true;
    this.dimensions = this.#config.dimensions;
    this.particleCount = this.#config.particleCount;
    this.colorScheme = this.#config.colorScheme;
    this.fractalMode = this.#config.fractalMode;
    this.currentState = [];
    
    // Initialize the visualizer if container provided
    if (this.#config.container) {
      this.render(this.#config.container);
    }
    
    // Connect to Neural Bus if enabled
    if (this.#config.neuralSynced) {
      this.connectToBus();
    }
    
    // Initialize fractal patterns if fractal mode enabled
    if (this.fractalMode) {
      this.#initFractalPatterns();
    }
    
    if (this.#config.debug) {
      console.log('QuantumVisualizer initialized with config:', this.#config);
    }
  }
  
  /**
   * Render visualizer in specified container
   * @param {HTMLElement} container - DOM element to render in
   */
  render(container) {
    if (!container) {
      console.error('No container provided for quantum visualization');
      return this;
    }
    
    this.#container = container;
    
    // Apply container styling
    this.#applyContainerStyles();
    
    // Create canvas for visualization
    this.#createCanvas();
    
    // Initialize particles
    this.#initParticles();
    
    // Start animation loop
    this.#startRenderLoop();
    
    return this;
  }
  
  /**
   * Update visualizer with new data
   * @param {Array} data - New quantum state data
   */
  update(data) {
    // Store previous state for transition effects
    const previousState = [...this.#currentState];
    
    // Update current state
    this.#currentState = data;
    this.currentState = data; // For test compatibility
    
    // Store in history (limited to 10 entries)
    this.#dataHistory.unshift(data);
    if (this.#dataHistory.length > 10) {
      this.#dataHistory.pop();
    }
    
    // Update particle properties based on new data
    this.#updateParticles(previousState);
    
    // Trigger callback
    if (this.#config.onStateChange) {
      this.#config.onStateChange(data);
    }
    
    return this;
  }
  
  /**
   * Update data and trigger callback
   * @param {Array} data - New quantum state data
   */
  updateData(data) {
    return this.update(data);
  }
  
  /**
   * Visualize quantum state data
   * @param {Array} data - Quantum state data to visualize
   */
  visualizeQuantumState(data) {
    // Update data
    this.#currentState = data;
    this.currentState = data; // For test compatibility
    
    // Render visualization
    this.render(this.#container || document.createElement('div'));
    
    // Apply fractal patterns if enabled
    if (this.fractalMode) {
      this.applyFractalPatterns();
    }
    
    return this;
  }
  
  /**
   * Apply fractal patterns to visualization
   */
  applyFractalPatterns() {
    if (!this.fractalMode || !this.#ctx) return this;
    
    // Get current data
    const data = this.#currentState;
    if (!data.length) return this;
    
    // Calculate base values from data
    const complexity = Math.min(data.length * 0.2, 1);
    const depth = this.#config.fractalDepth;
    
    // Apply patterns
    this.#renderFractalPatterns(complexity, depth);
    
    return this;
  }
  
  /**
   * Connect to Neural Bus
   */
  connectToBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('quantum-visualizer', {
          version: '2.0.0',
          capabilities: {
            fractalMode: this.fractalMode,
            dimensions: this.dimensions
          }
        });
        
        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;
        
        // Subscribe to quantum mutation events
        NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));
        
        // Subscribe to hologram events
        NeuralBus.subscribe('hologram:updated', this.#handleHologramUpdate.bind(this));
        
        // Subscribe to cart events
        NeuralBus.subscribe('cart:item:added', this.#handleCartEvent.bind(this));
        
        if (this.#config.debug) {
          console.log('QuantumVisualizer connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
    }
    
    return this;
  }
  
  /**
   * Connect to a hologram component
   * @param {HologramComponent} hologram - Hologram component
   */
  connectHologram(hologram) {
    if (!hologram) return this;
    
    // Store reference to hologram
    this.#hologramComponent = hologram;
    
    return this;
  }
  
  /**
   * Handle quantum mutation event
   * @private
   * @param {Object} data - Mutation event data
   */
  #handleQuantumMutation(data) {
    if (!data || !data.profile) return;
    
    // Record mutation history
    this.#mutationHistory.unshift({
      profile: data.profile,
      timestamp: data.timestamp || Date.now(),
      source: data.source
    });
    
    if (this.#mutationHistory.length > 5) {
      this.#mutationHistory.pop();
    }
    
    // Update color scheme based on profile
    if (this.#profileColors[data.profile]) {
      this.#updateColorScheme(data.profile);
    }
    
    // Generate visualization data from mutation
    const visualData = this.#generateQuantumData(data);
    
    // Update visualization
    this.update(visualData);
  }
  
  /**
   * Handle hologram update event
   * @private
   * @param {Object} data - Hologram event data
   */
  #handleHologramUpdate(data) {
    // Update visualization with hologram data
    if (data && data.quantumState) {
      this.update(data.quantumState);
    }
  }
  
  /**
   * Handle cart event
   * @private
   * @param {Object} data - Cart event data
   */
  #handleCartEvent(data) {
    if (!data || !data.item) return;
    
    // Generate visualization data from cart event
    const visualData = [
      {
        id: `item-${data.item.id}`,
        state: 'entangled',
        probability: 0.9,
        source: 'cart'
      }
    ];
    
    // Update visualization
    this.update([...this.#currentState, ...visualData]);
  }
  
  /**
   * Apply styles to container
   * @private
   */
  #applyContainerStyles() {
    if (!this.#container) return;
    
    // Add base class
    this.#container.classList.add('quantum-visualizer');
    
    // Add dimension class
    this.#container.classList.add(`dimension-${this.dimensions}`);
    
    // Set position relative for canvas positioning
    if (this.#container.style.position !== 'absolute' && 
        this.#container.style.position !== 'fixed') {
      this.#container.style.position = 'relative';
    }
  }
  
  /**
   * Create canvas element
   * @private
   */
  #createCanvas() {
    if (!this.#container) return;
    
    // Create canvas element
    this.#canvas = document.createElement('canvas');
    this.#canvas.className = 'quantum-canvas';
    
    // Set canvas size to match container
    this.#canvas.width = this.#container.clientWidth || 300;
    this.#canvas.height = this.#container.clientHeight || 300;
    
    // Add canvas to container
    this.#container.appendChild(this.#canvas);
    
    // Get rendering context
    this.#ctx = this.#canvas.getContext('2d');
    
    // Add resize listener
    window.addEventListener('resize', this.#handleResize.bind(this));
  }
  
  /**
   * Handle window resize
   * @private
   */
  #handleResize() {
    if (!this.#canvas || !this.#container) return;
    
    // Update canvas size
    this.#canvas.width = this.#container.clientWidth;
    this.#canvas.height = this.#container.clientHeight;
  }
  
  /**
   * Initialize particles
   * @private
   */
  #initParticles() {
    if (!this.#canvas) return;
    
    // Create particles based on configuration
    this.#particles = [];
    
    for (let i = 0; i < this.particleCount; i++) {
      this.#particles.push({
        x: Math.random() * this.#canvas.width,
        y: Math.random() * this.#canvas.height,
        z: Math.random() * 100, // For 3D effect
        radius: Math.random() * 3 + 1,
        color: this.#getRandomColor(),
        speed: Math.random() * 0.5 + 0.2,
        direction: Math.random() * Math.PI * 2,
        opacity: Math.random() * 0.5 + 0.5,
        state: null
      });
    }
  }
  
  /**
   * Start render loop
   * @private
   */
  #startRenderLoop() {
    if (this.#isRunning) return;
    
    this.#isRunning = true;
    this.#renderFrame();
  }
  
  /**
   * Render a frame
   * @private
   */
  #renderFrame() {
    if (!this.#isRunning) return;
    
    // Request next frame
    this.#rafId = requestAnimationFrame(this.#renderFrame.bind(this));
    
    // Limit fps
    const now = performance.now();
    const elapsed = now - this.#lastRenderTime;
    
    if (elapsed < 1000 / this.#fpsLimit) return;
    
    this.#lastRenderTime = now;
    
    // Clear canvas
    if (this.#ctx && this.#canvas) {
      this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
      
      // Draw background
      this.#drawBackground();
      
      // Update and draw particles
      this.#updateAndDrawParticles();
      
      // Draw fractal patterns if enabled
      if (this.fractalMode) {
        this.#drawFractalPatterns();
      }
      
      // Draw quantum connections
      this.#drawQuantumConnections();
    }
  }
  
  /**
   * Draw background
   * @private
   */
  #drawBackground() {
    if (!this.#ctx || !this.#canvas) return;
    
    // Create gradient background
    const gradient = this.#ctx.createLinearGradient(0, 0, 0, this.#canvas.height);
    
    // Set colors based on color scheme
    const colors = this.#getColorSchemeColors();
    
    gradient.addColorStop(0, this.#adjustColorOpacity(colors[0], 0.1));
    gradient.addColorStop(1, this.#adjustColorOpacity(colors[1], 0.2));
    
    this.#ctx.fillStyle = gradient;
    this.#ctx.fillRect(0, 0, this.#canvas.width, this.#canvas.height);
  }
  
  /**
   * Update and draw particles
   * @private
   */
  #updateAndDrawParticles() {
    if (!this.#ctx || !this.#canvas) return;
    
    const width = this.#canvas.width;
    const height = this.#canvas.height;
    
    // Update and draw each particle
    this.#particles.forEach(particle => {
      // Update position
      particle.x += Math.cos(particle.direction) * particle.speed;
      particle.y += Math.sin(particle.direction) * particle.speed;
      
      // Wrap around edges
      if (particle.x < 0) particle.x = width;
      if (particle.x > width) particle.x = 0;
      if (particle.y < 0) particle.y = height;
      if (particle.y > height) particle.y = 0;
      
      // Draw particle
      this.#ctx.beginPath();
      this.#ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
      this.#ctx.fillStyle = this.#adjustColorOpacity(particle.color, particle.opacity);
      this.#ctx.fill();
    });
  }
  
  /**
   * Draw quantum connections between particles
   * @private
   */
  #drawQuantumConnections() {
    if (!this.#ctx || !this.#canvas || this.#currentState.length < 2) return;
    
    // Get entangled particles
    const entangledStates = this.#currentState.filter(state => state.state === 'entangled');
    
    // Draw connections
    for (let i = 0; i < entangledStates.length; i++) {
      for (let j = i + 1; j < entangledStates.length; j++) {
        // Select particles to connect
        const startIdx = i * Math.floor(this.#particles.length / entangledStates.length);
        const endIdx = j * Math.floor(this.#particles.length / entangledStates.length);
        
        if (startIdx < this.#particles.length && endIdx < this.#particles.length) {
          const startParticle = this.#particles[startIdx];
          const endParticle = this.#particles[endIdx];
          
          // Draw line
          this.#ctx.beginPath();
          this.#ctx.moveTo(startParticle.x, startParticle.y);
          this.#ctx.lineTo(endParticle.x, endParticle.y);
          
          // Use color based on state
          const colors = this.#getColorSchemeColors();
          const connectionColor = this.#adjustColorOpacity(colors[2], 0.3);
          
          this.#ctx.strokeStyle = connectionColor;
          this.#ctx.lineWidth = 0.5;
          this.#ctx.stroke();
        }
      }
    }
  }
  
  /**
   * Initialize fractal patterns
   * @private
   */
  #initFractalPatterns() {
    // Generate base patterns
    this.#fractalPatterns = [
      {
        name: 'sierpinski',
        depth: this.#config.fractalDepth,
        angle: 0,
        scale: 1,
        color: '#00ffff'
      },
      {
        name: 'mandelbrot',
        depth: this.#config.fractalDepth,
        scale: 0.8,
        color: '#ff00ff'
      },
      {
        name: 'julia',
        depth: this.#config.fractalDepth,
        constant: { re: 0.285, im: 0.01 },
        color: '#9900ff'
      }
    ];
  }
  
  /**
   * Draw fractal patterns
   * @private
   */
  #drawFractalPatterns() {
    if (!this.#ctx || !this.#canvas || !this.fractalMode) return;
    
    // Draw each active pattern
    this.#fractalPatterns.forEach(pattern => {
      this.#ctx.save();
      
      // Set opacity for subtle effect
      this.#ctx.globalAlpha = 0.2;
      
      // Draw based on pattern type
      switch (pattern.name) {
        case 'sierpinski':
          this.#drawSierpinskiTriangle(
            this.#canvas.width / 2,
            this.#canvas.height / 4,
            this.#canvas.height / 2,
            pattern.depth,
            pattern.color
          );
          break;
        case 'mandelbrot':
          // Simplified representation - in a real visualizer, this would be more complex
          this.#drawFractalCircle(
            this.#canvas.width / 2,
            this.#canvas.height / 2,
            this.#canvas.height / 4,
            pattern.depth,
            pattern.color
          );
          break;
        case 'julia':
          // Simplified representation
          this.#drawSpiral(
            this.#canvas.width / 2,
            this.#canvas.height / 2,
            this.#canvas.height / 4,
            pattern.depth,
            pattern.color
          );
          break;
      }
      
      this.#ctx.restore();
    });
  }
  
  /**
   * Render fractal patterns
   * @private
   * @param {number} complexity - Pattern complexity (0-1)
   * @param {number} depth - Recursive depth
   */
  #renderFractalPatterns(complexity, depth) {
    if (!this.#ctx || !this.#canvas) return;
    
    // Update pattern properties based on parameters
    this.#fractalPatterns.forEach(pattern => {
      pattern.depth = Math.max(1, Math.floor(depth * complexity));
      pattern.scale = 0.5 + (complexity * 0.5);
      
      // Update color based on current color scheme
      const colors = this.#getColorSchemeColors();
      pattern.color = colors[Math.floor(Math.random() * colors.length)];
    });
    
    // Draw patterns
    this.#drawFractalPatterns();
  }
  
  /**
   * Draw Sierpinski triangle fractal
   * @private
   */
  #drawSierpinskiTriangle(x, y, size, depth, color) {
    if (depth <= 0) return;
    
    // Draw triangle
    this.#ctx.beginPath();
    this.#ctx.moveTo(x, y - size / 2);
    this.#ctx.lineTo(x - size / 2, y + size / 2);
    this.#ctx.lineTo(x + size / 2, y + size / 2);
    this.#ctx.closePath();
    
    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();
    
    // Recursive calls for sub-triangles
    const newSize = size / 2;
    this.#drawSierpinskiTriangle(x, y - newSize / 2, newSize, depth - 1, color);
    this.#drawSierpinskiTriangle(x - newSize / 2, y + newSize / 2, newSize, depth - 1, color);
    this.#drawSierpinskiTriangle(x + newSize / 2, y + newSize / 2, newSize, depth - 1, color);
  }
  
  /**
   * Draw fractal circle pattern
   * @private
   */
  #drawFractalCircle(x, y, radius, depth, color) {
    if (depth <= 0 || radius < 1) return;
    
    // Draw circle
    this.#ctx.beginPath();
    this.#ctx.arc(x, y, radius, 0, Math.PI * 2);
    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();
    
    // Recursive calls for sub-circles
    const newRadius = radius * 0.5;
    const offset = radius * 0.6;
    
    this.#drawFractalCircle(x + offset, y, newRadius, depth - 1, color);
    this.#drawFractalCircle(x - offset, y, newRadius, depth - 1, color);
    this.#drawFractalCircle(x, y + offset, newRadius, depth - 1, color);
    this.#drawFractalCircle(x, y - offset, newRadius, depth - 1, color);
  }
  
  /**
   * Draw spiral pattern
   * @private
   */
  #drawSpiral(x, y, radius, depth, color) {
    if (depth <= 0) return;
    
    this.#ctx.beginPath();
    
    const rotations = 2 + depth;
    const pointCount = 100;
    const radiusDecrement = radius / pointCount;
    
    let curRadius = radius;
    
    for (let i = 0; i <= pointCount; i++) {
      const angle = (i / pointCount) * Math.PI * 2 * rotations;
      const px = x + Math.cos(angle) * curRadius;
      const py = y + Math.sin(angle) * curRadius;
      
      if (i === 0) {
        this.#ctx.moveTo(px, py);
      } else {
        this.#ctx.lineTo(px, py);
      }
      
      curRadius -= radiusDecrement;
    }
    
    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();
  }
  
  /**
   * Update particles based on quantum state data
   * @private
   * @param {Array} previousState - Previous quantum state
   */
  #updateParticles(previousState) {
    if (!this.#particles.length || !this.#currentState.length) return;
    
    // Calculate number of particles per state
    const particlesPerState = Math.floor(this.#particles.length / this.#currentState.length);
    
    // Update particles based on states
    this.#currentState.forEach((stateData, index) => {
      const startIdx = index * particlesPerState;
      const endIdx = Math.min(startIdx + particlesPerState, this.#particles.length);
      
      // Determine color based on state
      const stateColor = this.#getStateColor(stateData.state, index);
      
      // Update particles for this state
      for (let i = startIdx; i < endIdx; i++) {
        const particle = this.#particles[i];
        
        // Color based on state
        particle.color = stateColor;
        
        // Size based on probability
        particle.radius = (stateData.probability || 0.5) * 4 + 1;
        
        // Speed based on state
        if (stateData.state === 'superposition') {
          particle.speed = Math.random() * 1 + 0.5;
          particle.direction = Math.random() * Math.PI * 2;
        } else if (stateData.state === 'entangled') {
          // Particles move in sync
          const groupDirection = Math.random() * Math.PI * 2;
          particle.direction = groupDirection;
          particle.speed = 0.8;
        } else {
          // Default behavior
          particle.speed = Math.random() * 0.5 + 0.2;
        }
        
        // Store state reference
        particle.state = stateData.id;
      }
    });
  }
  
  /**
   * Get color for quantum state
   * @private
   * @param {string} state - Quantum state name
   * @param {number} index - State index
   * @returns {string} Color value
   */
  #getStateColor(state, index) {
    const colors = this.#getColorSchemeColors();
    
    // Choose color based on state type
    switch (state) {
      case 'superposition':
        return colors[0];
      case 'entangled':
        return colors[1];
      case 'collapsed':
        return colors[2];
      default:
        // Rotate through available colors
        return colors[index % colors.length];
    }
  }
  
  /**
   * Get random color
   * @private
   * @returns {string} Random color
   */
  #getRandomColor() {
    const colors = this.#getColorSchemeColors();
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  /**
   * Get colors for current color scheme
   * @private
   * @returns {Array} Color values
   */
  #getColorSchemeColors() {
    // Use profile-based colors if available
    if (this.colorScheme && this.#profileColors[this.colorScheme]) {
      return this.#profileColors[this.colorScheme];
    }
    
    // Default color scheme (CyberLotus)
    return this.#profileColors.CyberLotus;
  }
  
  /**
   * Update color scheme
   * @private
   * @param {string} profile - Mutation profile name
   */
  #updateColorScheme(profile) {
    // Use profile as color scheme
    this.colorScheme = profile;
    
    // Update particles with new colors
    const colors = this.#getColorSchemeColors();
    
    this.#particles.forEach((particle, index) => {
      particle.color = colors[index % colors.length];
    });
  }
  
  /**
   * Adjust color opacity
   * @private
   * @param {string} color - Color value
   * @param {number} opacity - Opacity value (0-1)
   * @returns {string} Color with opacity
   */
  #adjustColorOpacity(color, opacity) {
    // Check if color is hex
    if (color.startsWith('#')) {
      // Convert hex to rgb
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    
    // Handle rgba or rgb
    if (color.startsWith('rgb')) {
      // Replace opacity in rgba or convert rgb to rgba
      if (color.startsWith('rgba')) {
        return color.replace(/rgba\((.+?), .+?\)/, `rgba($1, ${opacity})`);
      } else {
        return color.replace(/rgb\((.+?)\)/, `rgba($1, ${opacity})`);
      }
    }
    
    // Return original with opacity
    return `rgba(0, 255, 255, ${opacity})`;
  }
  
  /**
   * Generate quantum data from mutation event
   * @private
   * @param {Object} data - Mutation event data
   * @returns {Array} Quantum state data
   */
  #generateQuantumData(data) {
    const result = [];
    
    // Generate based on profile
    switch (data.profile) {
      case 'CyberLotus':
        result.push(
          { id: 'q1', state: 'superposition', probability: 0.7 },
          { id: 'q2', state: 'entangled', probability: 0.5 }
        );
        break;
      case 'ObsidianBloom':
        result.push(
          { id: 'q1', state: 'entangled', probability: 0.9 },
          { id: 'q2', state: 'entangled', probability: 0.9 },
          { id: 'q3', state: 'superposition', probability: 0.3 }
        );
        break;
      case 'VoidBloom':
        result.push(
          { id: 'q1', state: 'superposition', probability: 0.95 },
          { id: 'q2', state: 'collapsed', probability: 0.1 },
          { id: 'q3', state: 'superposition', probability: 0.8 }
        );
        break;
      case 'NeonVortex':
        result.push(
          { id: 'q1', state: 'entangled', probability: 0.6 },
          { id: 'q2', state: 'superposition', probability: 0.6 },
          { id: 'q3', state: 'entangled', probability: 0.6 },
          { id: 'q4', state: 'superposition', probability: 0.6 }
        );
        break;
      default:
        result.push(
          { id: 'q1', state: 'superposition', probability: 0.5 }
        );
    }
    
    // Add source data
    result.forEach(item => {
      item.source = data.source;
      item.timestamp = data.timestamp || Date.now();
      item.profile = data.profile;
    });
    
    return result;
  }
}

// CommonJS export for Jest compatibility
if (typeof module !== 'undefined' && module.exports) {
  module.exports = QuantumVisualizer;
}