/**
 * QUANTUM-VISUALIZER.JS
 * Quantum state visualization engine for CyberCore
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * QuantumVisualizer
 * Advanced visualization component for rendering quantum state data
 * with fractal patterns and dimensional shifting
 */
export class QuantumVisualizer {
  // Private properties
  #container = null;
  #canvas = null;
  #ctx = null;
  #neuralBusConnected = false;
  #config = null;
  #currentState = [];
  #rafId = null;
  #isRunning = false;
  #particles = [];
  #lastRenderTime = 0;
  #fpsLimit = 60;
  #neuralNonce = null;
  #colorMap = new Map();
  #profileColors = {
    CyberLotus: ['#00ffff', '#0088ff', '#80ffff'],
    ObsidianBloom: ['#ff00ff', '#8800ff', '#ff80ff'],
    VoidBloom: ['#9900ff', '#6600cc', '#cc80ff'],
    NeonVortex: ['#00ff66', '#00cc44', '#80ffaa'],
  };
  #fractalPatterns = [];
  #hologramComponent = null;
  #dataHistory = [];
  #mutationHistory = [];
  #is3dMode = false;
  #webglRenderer = null;
  #scene = null;
  #camera = null;
  #webglParticles = null;

  /**
   * Constructor - Initialize with optional configuration
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    // Set initial configuration
    this.#config = {
      dimensions: config.dimensions || '3d',
      particleCount: config.particleCount || 1000,
      colorScheme: config.colorScheme || null,
      container: config.container || null,
      fractalMode: config.fractalMode || false,
      fractalDepth: config.fractalDepth || 3,
      neuralSynced: config.neuralSynced !== undefined ? config.neuralSynced : true,
      updateFrequency: config.updateFrequency || 16,
      onStateChange: config.onStateChange || (() => {}),
      debug: config.debug || false,
      use3d: config.use3d || config.dimensions === '3d',
    };

    // Initialize public properties for test compatibility
    this.initialized = true;
    this.dimensions = this.#config.dimensions;
    this.particleCount = this.#config.particleCount;
    this.colorScheme = this.#config.colorScheme;
    this.fractalMode = this.#config.fractalMode;
    this.currentState = [];
    this.#is3dMode = this.#config.use3d;

    // Initialize private properties that weren't explicitly set
    this.#currentState = [];
    this.#isRunning = false;
    this.#particles = [];
    this.#lastRenderTime = 0;
    this.#dataHistory = [];
    this.#mutationHistory = [];

    // Initialize the visualizer if container provided
    if (this.#config.container) {
      this.render(this.#config.container);
    }

    // Connect to Neural Bus if enabled
    if (this.#config.neuralSynced) {
      this.connectToBus();
    }

    // Initialize fractal patterns if fractal mode enabled
    if (this.fractalMode) {
      this.#initFractalPatterns();
    }

    if (this.#config.debug) {
      console.log('QuantumVisualizer initialized with config:', this.#config);
    }
  }

  /**
   * Render visualizer in specified container
   * @param {HTMLElement} container - DOM element to render in
   */
  render(container) {
    if (!container) {
      console.error('No container provided for quantum visualization');
      return this;
    }

    this.#container = container;

    // Apply container styling
    this.#applyContainerStyles();

    if (this.#is3dMode) {
      this.#initWebGL();
    } else {
      // Create canvas for visualization
      this.#createCanvas();

      // Initialize particles
      this.#initParticles();

      // Start animation loop
      this.#startRenderLoop();
    }

    return this;
  }

  /**
   * Update visualizer with new data
   * @param {Array} data - New quantum state data
   */
  update(data) {
    // Store previous state for transition effects
    const previousState = [...this.#currentState];

    // Update current state
    this.#currentState = data;
    this.currentState = data; // For test compatibility

    // Store in history (limited to 10 entries)
    this.#dataHistory.unshift(data);
    if (this.#dataHistory.length > 10) {
      this.#dataHistory.pop();
    }

    // Update particle properties based on new data
    if (this.#is3dMode) {
      this.#update3DParticles(data);
    } else {
      this.#updateParticles(previousState);
    }

    // Trigger callback
    if (this.#config.onStateChange) {
      this.#config.onStateChange(data);
    }

    return this;
  }

  /**
   * Update data and trigger callback
   * @param {Array} data - New quantum state data
   */
  updateData(data) {
    return this.update(data);
  }

  /**
   * Visualize quantum state data
   * @param {Array} data - Quantum state data to visualize
   */
  visualizeQuantumState(data) {
    // Update data
    this.#currentState = data;
    this.currentState = data; // For test compatibility

    // Render visualization
    this.render(this.#container || document.createElement('div'));

    // Apply fractal patterns if enabled
    if (this.fractalMode) {
      this.applyFractalPatterns();
    }

    return this;
  }

  /**
   * Apply fractal patterns to visualization
   */
  applyFractalPatterns() {
    if (!this.fractalMode || !this.#ctx) return this;

    // Get current data
    const data = this.#currentState;
    if (!data.length) return this;

    // Calculate base values from data
    const complexity = Math.min(data.length * 0.2, 1);
    const depth = this.#config.fractalDepth;

    // Apply patterns
    this.#renderFractalPatterns(complexity, depth);

    return this;
  }

  /**
   * Connect to Neural Bus
   */
  connectToBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('quantum-visualizer', {
          version: '2.0.0',
          capabilities: {
            fractalMode: this.fractalMode,
            dimensions: this.dimensions,
          },
        });

        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;

        // Subscribe to quantum mutation events
        NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));

        // Subscribe to hologram events
        NeuralBus.subscribe('hologram:updated', this.#handleHologramUpdate.bind(this));

        // Subscribe to cart events
        NeuralBus.subscribe('cart:item:added', this.#handleCartEvent.bind(this));

        if (this.#config.debug) {
          console.log('QuantumVisualizer connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
    }

    return this;
  }

  /**
   * Disconnect from Neural Bus
   * Properly cleans up subscriptions and connections
   */
  disconnectFromNeuralBus() {
    try {
      if (this.#neuralBusConnected && typeof NeuralBus !== 'undefined') {
        // Unsubscribe from all events
        NeuralBus.unsubscribe('quantum:mutation', this.#handleQuantumMutation);
        NeuralBus.unsubscribe('hologram:updated', this.#handleHologramUpdate);
        NeuralBus.unsubscribe('cart:item:added', this.#handleCartEvent);

        // Unregister from Neural Bus
        if (this.#neuralNonce) {
          NeuralBus.unregister('quantum-visualizer', this.#neuralNonce);
        }

        this.#neuralBusConnected = false;
        this.#neuralNonce = null;

        if (this.#config.debug) {
          console.log('QuantumVisualizer disconnected from Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to disconnect from Neural Bus:', error);
    }

    return this;
  }

  /**
   * Connect to a hologram component
   * @param {HologramComponent} hologram - Hologram component
   */
  connectHologram(hologram) {
    if (!hologram) return this;

    // Store reference to hologram
    this.#hologramComponent = hologram;

    return this;
  }

  /**
   * Handle quantum mutation event
   * @private
   * @param {Object} data - Mutation event data
   */
  #handleQuantumMutation(data) {
    if (!data || !data.profile) return;

    // Record mutation history
    this.#mutationHistory.unshift({
      profile: data.profile,
      timestamp: data.timestamp || Date.now(),
      source: data.source,
    });

    if (this.#mutationHistory.length > 5) {
      this.#mutationHistory.pop();
    }

    // Update color scheme based on profile
    if (this.#profileColors[data.profile]) {
      this.#updateColorScheme(data.profile);
    }

    // Generate visualization data from mutation
    const visualData = this.#generateQuantumData(data);

    // Update visualization
    this.update(visualData);
  }

  /**
   * Handle quantum mutation event (exposed for testing)
   * @param {Object} data - Mutation event data
   */
  handleQuantumMutation(data) {
    return this.#handleQuantumMutation(data);
  }

  /**
   * Handle hologram update event
   * @private
   * @param {Object} data - Hologram event data
   */
  #handleHologramUpdate(data) {
    // Update visualization with hologram data
    if (data && data.quantumState) {
      this.update(data.quantumState);
    }
  }

  /**
   * Handle hologram update event (exposed for testing)
   * @param {Object} data - Hologram event data
   */
  handleHologramUpdate(data) {
    return this.#handleHologramUpdate(data);
  }

  /**
   * Handle cart event
   * @private
   * @param {Object} data - Cart event data
   */
  #handleCartEvent(data) {
    if (!data || !data.item) return;

    // Generate visualization data from cart event
    const visualData = [
      {
        id: `item-${data.item.id}`,
        state: 'entangled',
        probability: 0.9,
        source: 'cart',
      },
    ];

    // Update visualization
    this.update([...this.#currentState, ...visualData]);
  }

  /**
   * Handle cart event (exposed for testing)
   * @param {Object} data - Cart event data
   */
  handleCartEvent(data) {
    return this.#handleCartEvent(data);
  }

  /**
   * Apply styles to container
   * @private
   */
  #applyContainerStyles() {
    if (!this.#container) return;

    // Add base class
    this.#container.classList.add('quantum-visualizer');

    // Add dimension class
    this.#container.classList.add(`dimension-${this.dimensions}`);

    // Set position relative for canvas positioning
    if (
      this.#container.style.position !== 'absolute' &&
      this.#container.style.position !== 'fixed'
    ) {
      this.#container.style.position = 'relative';
    }
  }

  /**
   * Create canvas element
   * @private
   */
  #createCanvas() {
    if (!this.#container) return;

    // Create canvas element
    this.#canvas = document.createElement('canvas');
    this.#canvas.className = 'quantum-canvas';

    // Set canvas size to match container
    this.#canvas.width = this.#container.clientWidth || 300;
    this.#canvas.height = this.#container.clientHeight || 300;

    // Add canvas to container
    this.#container.appendChild(this.#canvas);

    // Get rendering context
    this.#ctx = this.#canvas.getContext('2d');

    // Add resize listener
    window.addEventListener('resize', this.#handleResize.bind(this));
  }

  /**
   * Handle window resize
   * @private
   */
  #handleResize() {
    if (!this.#canvas || !this.#container) return;

    // Update canvas size
    this.#canvas.width = this.#container.clientWidth;
    this.#canvas.height = this.#container.clientHeight;

    if (this.#is3dMode && this.#webglRenderer) {
      this.#webglRenderer.setSize(this.#container.clientWidth, this.#container.clientHeight);
    }
  }

  /**
   * Initialize particles
   * @private
   */
  #initParticles() {
    if (!this.#canvas) return;

    // Create particles based on configuration
    this.#particles = [];

    for (let i = 0; i < this.particleCount; i++) {
      this.#particles.push({
        x: Math.random() * this.#canvas.width,
        y: Math.random() * this.#canvas.height,
        z: Math.random() * 100, // For 3D effect
        radius: Math.random() * 3 + 1,
        color: this.#getRandomColor(),
        speed: Math.random() * 0.5 + 0.2,
        direction: Math.random() * Math.PI * 2,
        opacity: Math.random() * 0.5 + 0.5,
        state: null,
      });
    }
  }

  /**
   * Start render loop
   * @private
   */
  #startRenderLoop() {
    if (this.#isRunning) return;

    this.#isRunning = true;
    this.#renderFrame();
  }

  /**
   * Render a frame
   * @private
   */
  #renderFrame() {
    if (!this.#isRunning) return;

    // Request next frame
    this.#rafId = requestAnimationFrame(this.#renderFrame.bind(this));

    // Limit fps
    const now = performance.now();
    const elapsed = now - this.#lastRenderTime;

    if (elapsed < 1000 / this.#fpsLimit) return;

    this.#lastRenderTime = now;

    // Clear canvas
    if (this.#ctx && this.#canvas) {
      this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);

      // Draw background
      this.#drawBackground();

      // Update and draw particles
      this.#updateAndDrawParticles();

      // Draw fractal patterns if enabled
      if (this.fractalMode) {
        this.#drawFractalPatterns();
      }

      // Draw quantum connections
      this.#drawQuantumConnections();
    }
  }

  /**
   * Draw background
   * @private
   */
  #drawBackground() {
    if (!this.#ctx || !this.#canvas) return;

    // Create gradient background
    const gradient = this.#ctx.createLinearGradient(0, 0, 0, this.#canvas.height);

    // Set colors based on color scheme
    const colors = this.#getColorSchemeColors();

    gradient.addColorStop(0, this.#adjustColorOpacity(colors[0], 0.1));
    gradient.addColorStop(1, this.#adjustColorOpacity(colors[1], 0.2));

    this.#ctx.fillStyle = gradient;
    this.#ctx.fillRect(0, 0, this.#canvas.width, this.#canvas.height);
  }

  /**
   * Update and draw particles
   * @private
   */
  #updateAndDrawParticles() {
    if (!this.#ctx || !this.#canvas) return;

    const width = this.#canvas.width;
    const height = this.#canvas.height;

    // Update and draw each particle
    this.#particles.forEach((particle) => {
      // Update position
      particle.x += Math.cos(particle.direction) * particle.speed;
      particle.y += Math.sin(particle.direction) * particle.speed;

      // Wrap around edges
      if (particle.x < 0) particle.x = width;
      if (particle.x > width) particle.x = 0;
      if (particle.y < 0) particle.y = height;
      if (particle.y > height) particle.y = 0;

      // Draw particle
      this.#ctx.beginPath();
      this.#ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
      this.#ctx.fillStyle = this.#adjustColorOpacity(particle.color, particle.opacity);
      this.#ctx.fill();
    });
  }

  /**
   * Draw quantum connections between particles
   * @private
   */
  #drawQuantumConnections() {
    if (!this.#ctx || !this.#canvas || this.#currentState.length < 2) return;

    // Get entangled particles
    const entangledStates = this.#currentState.filter((state) => state.state === 'entangled');

    // Draw connections
    for (let i = 0; i < entangledStates.length; i++) {
      for (let j = i + 1; j < entangledStates.length; j++) {
        // Select particles to connect
        const startIdx = i * Math.floor(this.#particles.length / entangledStates.length);
        const endIdx = j * Math.floor(this.#particles.length / entangledStates.length);

        if (startIdx < this.#particles.length && endIdx < this.#particles.length) {
          const startParticle = this.#particles[startIdx];
          const endParticle = this.#particles[endIdx];

          // Draw line
          this.#ctx.beginPath();
          this.#ctx.moveTo(startParticle.x, startParticle.y);
          this.#ctx.lineTo(endParticle.x, endParticle.y);

          // Use color based on state
          const colors = this.#getColorSchemeColors();
          const connectionColor = this.#adjustColorOpacity(colors[2], 0.3);

          this.#ctx.strokeStyle = connectionColor;
          this.#ctx.lineWidth = 0.5;
          this.#ctx.stroke();
        }
      }
    }
  }

  /**
   * Initialize fractal patterns
   * @private
   */
  #initFractalPatterns() {
    // Generate base patterns
    this.#fractalPatterns = [
      {
        name: 'sierpinski',
        depth: this.#config.fractalDepth,
        angle: 0,
        scale: 1,
        color: '#00ffff',
      },
      {
        name: 'mandelbrot',
        depth: this.#config.fractalDepth,
        scale: 0.8,
        color: '#ff00ff',
      },
      {
        name: 'julia',
        depth: this.#config.fractalDepth,
        constant: { re: 0.285, im: 0.01 },
        color: '#9900ff',
      },
    ];
  }

  /**
   * Draw fractal patterns
   * @private
   */
  #drawFractalPatterns() {
    if (!this.#ctx || !this.#canvas || !this.fractalMode) return;

    // Draw each active pattern
    this.#fractalPatterns.forEach((pattern) => {
      this.#ctx.save();

      // Set opacity for subtle effect
      this.#ctx.globalAlpha = 0.2;

      // Draw based on pattern type
      switch (pattern.name) {
      case 'sierpinski':
        this.#drawSierpinskiTriangle(
          this.#canvas.width / 2,
          this.#canvas.height / 4,
          this.#canvas.height / 2,
          pattern.depth,
          pattern.color
        );
        break;
      case 'mandelbrot':
        // Simplified representation - in a real visualizer, this would be more complex
        this.#drawFractalCircle(
          this.#canvas.width / 2,
          this.#canvas.height / 2,
          this.#canvas.height / 4,
          pattern.depth,
          pattern.color
        );
        break;
      case 'julia':
        // Simplified representation
        this.#drawSpiral(
          this.#canvas.width / 2,
          this.#canvas.height / 2,
          this.#canvas.height / 4,
          pattern.depth,
          pattern.color
        );
        break;
      }

      this.#ctx.restore();
    });
  }

  /**
   * Render fractal patterns
   * @private
   * @param {number} complexity - Pattern complexity (0-1)
   * @param {number} depth - Recursive depth
   */
  #renderFractalPatterns(complexity, depth) {
    if (!this.#ctx || !this.#canvas) return;

    // Update pattern properties based on parameters
    this.#fractalPatterns.forEach((pattern) => {
      pattern.depth = Math.max(1, Math.floor(depth * complexity));
      pattern.scale = 0.5 + complexity * 0.5;

      // Update color based on current color scheme
      const colors = this.#getColorSchemeColors();
      pattern.color = colors[Math.floor(Math.random() * colors.length)];
    });

    // Draw patterns
    this.#drawFractalPatterns();
  }

  /**
   * Draw Sierpinski triangle fractal
   * @private
   */
  #drawSierpinskiTriangle(x, y, size, depth, color) {
    if (depth <= 0) return;

    // Draw triangle
    this.#ctx.beginPath();
    this.#ctx.moveTo(x, y - size / 2);
    this.#ctx.lineTo(x - size / 2, y + size / 2);
    this.#ctx.lineTo(x + size / 2, y + size / 2);
    this.#ctx.closePath();

    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();

    // Recursive calls for sub-triangles
    const newSize = size / 2;
    this.#drawSierpinskiTriangle(x, y - newSize / 2, newSize, depth - 1, color);
    this.#drawSierpinskiTriangle(x - newSize / 2, y + newSize / 2, newSize, depth - 1, color);
    this.#drawSierpinskiTriangle(x + newSize / 2, y + newSize / 2, newSize, depth - 1, color);
  }

  /**
   * Draw fractal circle pattern
   * @private
   */
  #drawFractalCircle(x, y, radius, depth, color) {
    if (depth <= 0 || radius < 1) return;

    // Draw circle
    this.#ctx.beginPath();
    this.#ctx.arc(x, y, radius, 0, Math.PI * 2);
    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();

    // Recursive calls for sub-circles
    const newRadius = radius * 0.5;
    const offset = radius * 0.6;

    this.#drawFractalCircle(x + offset, y, newRadius, depth - 1, color);
    this.#drawFractalCircle(x - offset, y, newRadius, depth - 1, color);
    this.#drawFractalCircle(x, y + offset, newRadius, depth - 1, color);
    this.#drawFractalCircle(x, y - offset, newRadius, depth - 1, color);
  }

  /**
   * Draw spiral pattern
   * @private
   */
  #drawSpiral(x, y, radius, depth, color) {
    if (depth <= 0) return;

    this.#ctx.beginPath();

    const rotations = 2 + depth;
    const pointCount = 100;
    const radiusDecrement = radius / pointCount;

    let curRadius = radius;

    for (let i = 0; i <= pointCount; i++) {
      const angle = (i / pointCount) * Math.PI * 2 * rotations;
      const px = x + Math.cos(angle) * curRadius;
      const py = y + Math.sin(angle) * curRadius;

      if (i === 0) {
        this.#ctx.moveTo(px, py);
      } else {
        this.#ctx.lineTo(px, py);
      }

      curRadius -= radiusDecrement;
    }

    this.#ctx.strokeStyle = color;
    this.#ctx.stroke();
  }

  /**
   * Update particles based on quantum state data
   * @private
   * @param {Array} previousState - Previous quantum state
   */
  #updateParticles(previousState) {
    if (!this.#particles.length || !this.#currentState.length) return;

    // Calculate number of particles per state
    const particlesPerState = Math.floor(this.#particles.length / this.#currentState.length);

    // Update particles based on states
    this.#currentState.forEach((stateData, index) => {
      const startIdx = index * particlesPerState;
      const endIdx = Math.min(startIdx + particlesPerState, this.#particles.length);

      // Determine color based on state
      const stateColor = this.#getStateColor(stateData.state, index);

      // Update particles for this state
      for (let i = startIdx; i < endIdx; i++) {
        const particle = this.#particles[i];

        // Color based on state
        particle.color = stateColor;

        // Size based on probability
        particle.radius = (stateData.probability || 0.5) * 4 + 1;

        // Speed based on state
        if (stateData.state === 'superposition') {
          particle.speed = Math.random() * 1 + 0.5;
          particle.direction = Math.random() * Math.PI * 2;
        } else if (stateData.state === 'entangled') {
          // Particles move in sync
          const groupDirection = Math.random() * Math.PI * 2;
          particle.direction = groupDirection;
          particle.speed = 0.8;
        } else {
          // Default behavior
          particle.speed = Math.random() * 0.5 + 0.2;
        }

        // Store state reference
        particle.state = stateData.id;
      }
    });
  }

  /**
   * Get color for quantum state
   * @private
   * @param {string} state - Quantum state name
   * @param {number} index - State index
   * @returns {string} Color value
   */
  #getStateColor(state, index) {
    const colors = this.#getColorSchemeColors();

    // Choose color based on state type
    switch (state) {
    case 'superposition':
      return colors[0];
    case 'entangled':
      return colors[1];
    case 'collapsed':
      return colors[2];
    default:
      // Rotate through available colors
      return colors[index % colors.length];
    }
  }

  /**
   * Get random color
   * @private
   * @returns {string} Random color
   */
  #getRandomColor() {
    const colors = this.#getColorSchemeColors();
    return colors[Math.floor(Math.random() * colors.length)];
  }

  /**
   * Get colors for current color scheme
   * @private
   * @returns {Array} Color values
   */
  #getColorSchemeColors() {
    // Use profile-based colors if available
    if (this.colorScheme && this.#profileColors[this.colorScheme]) {
      return this.#profileColors[this.colorScheme];
    }

    // Default color scheme (CyberLotus)
    return this.#profileColors.CyberLotus;
  }

  /**
   * Update color scheme
   * @private
   * @param {string} profile - Mutation profile name
   */
  #updateColorScheme(profile) {
    // Use profile as color scheme
    this.colorScheme = profile;

    // Update particles with new colors
    const colors = this.#getColorSchemeColors();

    this.#particles.forEach((particle, index) => {
      particle.color = colors[index % colors.length];
    });
  }

  /**
   * Adjust color opacity
   * @private
   * @param {string} color - Color value
   * @param {number} opacity - Opacity value (0-1)
   * @returns {string} Color with opacity
   */
  #adjustColorOpacity(color, opacity) {
    // Check if color is hex
    if (color.startsWith('#')) {
      // Convert hex to rgb
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);

      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }

    // Handle rgba or rgb
    if (color.startsWith('rgb')) {
      // Replace opacity in rgba or convert rgb to rgba
      if (color.startsWith('rgba')) {
        return color.replace(/rgba\((.+?), .+?\)/, `rgba($1, ${opacity})`);
      } else {
        return color.replace(/rgb\((.+?)\)/, `rgba($1, ${opacity})`);
      }
    }

    // Return original with opacity
    return `rgba(0, 255, 255, ${opacity})`;
  }

  /**
   * Generate quantum data from mutation event
   * @private
   * @param {Object} data - Mutation event data
   * @returns {Array} Quantum state data
   */
  #generateQuantumData(data) {
    const result = [];

    // Generate based on profile
    switch (data.profile) {
    case 'CyberLotus':
      result.push(
        { id: 'q1', state: 'superposition', probability: 0.7 },
        { id: 'q2', state: 'entangled', probability: 0.5 }
      );
      break;
    case 'ObsidianBloom':
      result.push(
        { id: 'q1', state: 'entangled', probability: 0.9 },
        { id: 'q2', state: 'entangled', probability: 0.9 },
        { id: 'q3', state: 'superposition', probability: 0.3 }
      );
      break;
    case 'VoidBloom':
      result.push(
        { id: 'q1', state: 'superposition', probability: 0.95 },
        { id: 'q2', state: 'collapsed', probability: 0.1 },
        { id: 'q3', state: 'superposition', probability: 0.8 }
      );
      break;
    case 'NeonVortex':
      result.push(
        { id: 'q1', state: 'entangled', probability: 0.6 },
        { id: 'q2', state: 'superposition', probability: 0.6 },
        { id: 'q3', state: 'entangled', probability: 0.6 },
        { id: 'q4', state: 'superposition', probability: 0.6 }
      );
      break;
    default:
      result.push({ id: 'q1', state: 'superposition', probability: 0.5 });
    }

    // Add source data
    result.forEach((item) => {
      item.source = data.source;
      item.timestamp = data.timestamp || Date.now();
      item.profile = data.profile;
    });

    return result;
  }

  /**
   * Initialize WebGL for 3D visualization
   * @private
   */
  #initWebGL() {
    if (!this.#is3dMode || !this.#container) return;

    try {
      // Dynamically import THREE.js
      import('./quantum-webgl.js')
        .then((module) => {
          const THREE = module.THREE;

          // Create WebGL renderer
          this.#webglRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          this.#webglRenderer.setSize(this.#container.clientWidth, this.#container.clientHeight);
          this.#webglRenderer.setPixelRatio(window.devicePixelRatio);

          // Add canvas to container
          this.#container.appendChild(this.#webglRenderer.domElement);

          // Create scene
          this.#scene = new THREE.Scene();

          // Create camera
          this.#camera = new THREE.PerspectiveCamera(
            75,
            this.#container.clientWidth / this.#container.clientHeight,
            0.1,
            1000
          );
          this.#camera.position.z = 50;

          // Add ambient light
          const ambientLight = new THREE.AmbientLight(0x404040);
          this.#scene.add(ambientLight);

          // Add directional light
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
          directionalLight.position.set(1, 1, 1);
          this.#scene.add(directionalLight);

          // Initialize particles
          this.#initWebGLParticles();

          // Start 3D render loop
          this.#render3D();

          if (this.#config.debug) {
            console.log('WebGL 3D mode initialized');
          }
        })
        .catch((error) => {
          console.error('Failed to initialize WebGL:', error);
          this.#is3dMode = false;

          // Fall back to 2D canvas
          this.#createCanvas();
          this.#initParticles();
          this.#startRenderLoop();
        });
    } catch (error) {
      console.error('WebGL initialization failed:', error);
      this.#is3dMode = false;

      // Fall back to 2D canvas
      this.#createCanvas();
      this.#initParticles();
      this.#startRenderLoop();
    }
  }

  /**
   * Initialize WebGL particles
   * @private
   */
  #initWebGLParticles() {
    if (!this.#scene || !this.#is3dMode) return;

    import('./quantum-webgl.js')
      .then((module) => {
        const THREE = module.THREE;

        // Create particle system
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = this.particleCount;

        // Create position array
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        // Initialize with random positions
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;

          // Position (random in a sphere)
          const radius = 30 * Math.cbrt(Math.random());
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);

          // Color (from color scheme)
          const colorScheme = this.#getColorSchemeColors();
          const colorHex = colorScheme[i % colorScheme.length];
          const color = new THREE.Color(colorHex);

          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;

          // Size
          sizes[i] = Math.random() * 2 + 1;
        }

        // Set attributes
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Create shader material
        const particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0.0 },
            pixelRatio: { value: window.devicePixelRatio },
          },
          vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float time;
            uniform float pixelRatio;

            void main() {
              vColor = color;
              vec3 pos = position;

              // Simple animation based on time
              float angle = time * 0.2;
              float cosA = cos(angle);
              float sinA = sin(angle);

              // Rotate around y-axis
              float x = pos.x * cosA - pos.z * sinA;
              float z = pos.x * sinA + pos.z * cosA;
              pos.x = x;
              pos.z = z;

              // Project to screen
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;

            void main() {
              // Draw circle
              vec2 xy = gl_PointCoord.xy - vec2(0.5);
              float radius = length(xy);

              if (radius > 0.5) {
                discard;
              }

              // Smooth edge
              float alpha = 1.0 - smoothstep(0.4, 0.5, radius);

              gl_FragColor = vec4(vColor, alpha);
            }
          `,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true,
        });

        // Create particle system
        this.#webglParticles = new THREE.Points(particleGeometry, particleMaterial);
        this.#scene.add(this.#webglParticles);

        // Add connections
        this.#createQuantumConnections3D();
      })
      .catch((error) => {
        console.error('Failed to initialize WebGL particles:', error);
      });
  }

  /**
   * Create quantum connections for 3D visualization
   * @private
   */
  #createQuantumConnections3D() {
    if (!this.#scene || !this.#is3dMode) return;

    import('./quantum-webgl.js')
      .then((module) => {
        const THREE = module.THREE;

        // Remove existing connections
        const existingConnections = this.#scene.children.filter(
          (child) => child.userData && child.userData.type === 'quantum-connection'
        );

        existingConnections.forEach((connection) => {
          this.#scene.remove(connection);
        });

        // Get colors from scheme
        const colorScheme = this.#getColorSchemeColors();
        const connectionColor = new THREE.Color(colorScheme[0]);

        // Create connection material
        const lineMaterial = new THREE.LineBasicMaterial({
          color: connectionColor,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });

        // Create connections between particles
        const particlePositions = this.#webglParticles.geometry.attributes.position.array;
        const particleCount = this.particleCount;
        const connectionCount = Math.min(20, Math.floor(particleCount / 10));

        for (let i = 0; i < connectionCount; i++) {
          const idx1 = Math.floor(Math.random() * particleCount);
          const idx2 = Math.floor(Math.random() * particleCount);

          if (idx1 === idx2) continue;

          const i1 = idx1 * 3;
          const i2 = idx2 * 3;

          const lineGeometry = new THREE.BufferGeometry();
          const vertices = new Float32Array([
            particlePositions[i1],
            particlePositions[i1 + 1],
            particlePositions[i1 + 2],
            particlePositions[i2],
            particlePositions[i2 + 1],
            particlePositions[i2 + 2],
          ]);

          lineGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

          const line = new THREE.Line(lineGeometry, lineMaterial);
          line.userData = { type: 'quantum-connection' };

          this.#scene.add(line);
        }
      })
      .catch((error) => {
        console.error('Failed to create quantum connections:', error);
      });
  }

  /**
   * Render 3D scene
   * @private
   */
  #render3D() {
    if (!this.#is3dMode || !this.#webglRenderer || !this.#scene || !this.#camera) return;

    // Request animation frame
    this.#rafId = requestAnimationFrame(this.#render3D.bind(this));

    // Limit fps
    const now = performance.now();
    const elapsed = now - this.#lastRenderTime;

    if (elapsed < 1000 / this.#fpsLimit) return;

    this.#lastRenderTime = now;

    // Animate particles
    if (this.#webglParticles) {
      this.#webglParticles.material.uniforms.time.value = now * 0.001;

      // Rotate particle system
      this.#webglParticles.rotation.y += 0.001;
    }

    // Update camera based on mouse position
    this.#updateCamera();

    // Render scene
    this.#webglRenderer.render(this.#scene, this.#camera);
  }

  /**
   * Update camera position
   * @private
   */
  #updateCamera() {
    if (!this.#camera) return;

    // Implementation for mouse-based camera movement would go here
  }

  /**
   * Update 3D particles with quantum state data
   * @private
   * @param {Array} stateData - Quantum state data
   */
  #update3DParticles(stateData) {
    if (!this.#is3dMode || !this.#webglParticles || !stateData.length) return;

    import('./quantum-webgl.js')
      .then((module) => {
        const THREE = module.THREE;

        // Get particle attributes
        const positions = this.#webglParticles.geometry.attributes.position;
        const colors = this.#webglParticles.geometry.attributes.color;
        const sizes = this.#webglParticles.geometry.attributes.size;

        // Calculate particles per state
        const particleCount = positions.count;
        const particlesPerState = Math.floor(particleCount / stateData.length);

        // Update particles based on state data
        stateData.forEach((state, stateIndex) => {
          const startIdx = stateIndex * particlesPerState;
          const endIdx = Math.min(startIdx + particlesPerState, particleCount);

          // Get color for this state
          const stateColor = new THREE.Color(this.#getStateColor(state.state, stateIndex));

          // Calculate base position for this state group (for entanglement)
          let baseX, baseY, baseZ;

          if (state.state === 'entangled') {
            // Entangled particles should be grouped
            const radius = 20 + 10 * Math.random();
            const theta = stateIndex * ((Math.PI * 2) / stateData.length);
            baseX = radius * Math.cos(theta);
            baseY = (Math.random() - 0.5) * 10;
            baseZ = radius * Math.sin(theta);
          }

          // Update particles in this state group
          for (let i = startIdx; i < endIdx; i++) {
            const i3 = i * 3;

            // Update color
            colors.array[i3] = stateColor.r;
            colors.array[i3 + 1] = stateColor.g;
            colors.array[i3 + 2] = stateColor.b;

            // Update size based on probability
            sizes.array[i] = 1 + (state.probability || 0.5) * 3;

            // Update position for entangled particles
            if (state.state === 'entangled') {
              // Add jitter within a small radius of the base position
              const jitter = 5;
              positions.array[i3] = baseX + (Math.random() - 0.5) * jitter;
              positions.array[i3 + 1] = baseY + (Math.random() - 0.5) * jitter;
              positions.array[i3 + 2] = baseZ + (Math.random() - 0.5) * jitter;
            } else if (state.state === 'superposition') {
              // Superposition particles should be more spread out
              const radius = 30 * Math.cbrt(Math.random());
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);

              positions.array[i3] = radius * Math.sin(phi) * Math.cos(theta);
              positions.array[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
              positions.array[i3 + 2] = radius * Math.cos(phi);
            }
          }
        });

        // Update attributes
        positions.needsUpdate = true;
        colors.needsUpdate = true;
        sizes.needsUpdate = true;

        // Update connections
        this.#createQuantumConnections3D();
      })
      .catch((error) => {
        console.error('Failed to update 3D particles:', error);
      });
  }

  /**
   * Clean up resources
   */
  dispose() {
    // Stop animation
    if (this.#rafId) {
      cancelAnimationFrame(this.#rafId);
      this.#rafId = null;
    }

    this.#isRunning = false;

    // Disconnect from Neural Bus
    this.disconnectFromNeuralBus();

    // Remove event listeners
    window.removeEventListener('resize', this.#handleResize);

    // Clean up WebGL resources
    if (this.#webglRenderer) {
      this.#webglRenderer.dispose();
      this.#webglRenderer = null;
    }

    if (this.#scene) {
      // Dispose of all geometries and materials
      this.#scene.traverse((object) => {
        if (object.geometry) {
          object.geometry.dispose();
        }

        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach((material) => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });

      this.#scene = null;
    }

    // Remove canvas
    if (this.#canvas && this.#canvas.parentNode) {
      this.#canvas.parentNode.removeChild(this.#canvas);
    }

    // Clear references
    this.#canvas = null;
    this.#ctx = null;
    this.#container = null;
    this.#particles = [];
    this.#currentState = [];
    this.#dataHistory = [];
    this.#mutationHistory = [];

    return this;
  }
}

// CommonJS export for Jest compatibility
if (typeof module !== 'undefined' && module.exports) {
  module.exports = QuantumVisualizer;
}
