/**
 * HOLOGRAM-RENDERER.JS
 * WebGL-powered renderer for holographic product previews
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

/**
 * @typedef {Object} HologramRendererOptions
 * @property {HTMLElement} container - DOM element to render in
 * @property {number} width - Width of the renderer
 * @property {number} height - Height of the renderer
 * @property {string} profile - Mutation profile name
 * @property {number} intensity - Hologram intensity
 * @property {boolean} enableGlitch - Whether to enable glitch effects
 * @property {Function} onReady - Callback when renderer is ready
 * @property {boolean} debug - Whether to enable debug mode
 */

/**
 * @typedef {Object} ModelOptions
 * @property {string} url - URL to the 3D model
 * @property {string} format - Format of the model (glb, gltf, obj)
 * @property {Object} materialOverrides - Material overrides
 * @property {Object} transformOverrides - Transform overrides
 */

/**
 * HologramRenderer
 * WebGL-powered renderer for holographic product previews
 */
export class HologramRenderer {
  /**
   * Initialize the hologram renderer
   * @param {HologramRendererOptions} options - Configuration options
   */
  static initialize(options) {
    // Only initialize once
    if (this.initialized) {
      return this;
    }

    this.options = {
      width: 300,
      height: 300,
      profile: 'CyberLotus',
      intensity: 1.0,
      enableGlitch: false,
      onReady: () => {},
      debug: false,
      ...options,
    };

    this.container = options.container;
    this.worker = null;
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.model = null;
    this.clock = null;
    this.animationFrameId = null;
    this.quantumParticles = [];
    this.traumaEffects = [];
    this.ready = false;

    // Initialize WebGL renderer
    this._initWebGL();

    // Initialize quantum worker
    this._initQuantumWorker();

    this.initialized = true;

    if (this.options.debug) {
      console.log('[HologramRenderer] Initialized with options:', this.options);
    }

    return this;
  }

  /**
   * Load a 3D model
   * @param {string|ModelOptions} model - Model URL or options
   * @returns {Promise} Promise that resolves when the model is loaded
   */
  static loadModel(model) {
    if (!this.initialized) {
      throw new Error('HologramRenderer must be initialized before loading a model');
    }

    return new Promise((resolve, reject) => {
      try {
        // Clear existing model if any
        if (this.model) {
          this.scene.remove(this.model);
          this.model = null;
        }

        const modelOptions =
          typeof model === 'string' ? { url: model, format: this._detectFormat(model) } : model;

        // Use THREE.js loaders based on format
        const loader = this._getLoader(modelOptions.format);

        loader.load(
          // URL
          modelOptions.url,

          // onLoad callback
          (loadedModel) => {
            this._setupModel(loadedModel, modelOptions);
            this.model = loadedModel;
            this._startAnimation();

            if (this.options.debug) {
              console.log('[HologramRenderer] Model loaded:', modelOptions.url);
            }

            resolve(loadedModel);
          },

          // onProgress callback
          (xhr) => {
            if (this.options.debug) {
              console.log(
                `[HologramRenderer] Model ${Math.round((xhr.loaded / xhr.total) * 100)}% loaded`
              );
            }
          },

          // onError callback
          (error) => {
            console.error('[HologramRenderer] Error loading model:', error);
            reject(error);
          }
        );
      } catch (error) {
        console.error('[HologramRenderer] Failed to load model:', error);
        reject(error);
      }
    });
  }

  /**
   * Apply quantum effects to the model
   * @param {Object} effectOptions - Effect options
   */
  static applyQuantumEffects(effectOptions = {}) {
    if (!this.initialized || !this.model) return this;

    const options = {
      intensity: this.options.intensity,
      profile: this.options.profile,
      traumaCodes: [],
      ...effectOptions,
    };

    // Send to worker for calculation
    this.worker.postMessage({
      type: 'calculate-quantum-state',
      data: options,
    });

    return this;
  }

  /**
   * Apply a glitch effect
   * @param {number} intensity - Glitch intensity (0-1)
   * @param {number} duration - Glitch duration in ms
   */
  static applyGlitch(intensity = 0.5, duration = 500) {
    if (!this.initialized || !this.model) return this;

    // Apply shader-based glitch effect
    if (this.renderer && this.model) {
      // Set up glitch effect using postprocessing
      this._setupGlitchEffect(intensity);

      // Reset after duration
      setTimeout(() => {
        this._removeGlitchEffect();
      }, duration);
    }

    return this;
  }

  /**
   * Set active trauma codes
   * @param {Array<string>} traumaCodes - Trauma effect codes
   */
  static setTraumaCodes(traumaCodes) {
    if (!this.initialized) return this;

    this.traumaEffects = traumaCodes;

    // Apply trauma effects to shader parameters
    if (this.model) {
      this.worker.postMessage({
        type: 'process-trauma-patterns',
        data: {
          traumaCodes,
          intensity: this.options.intensity,
        },
      });
    }

    return this;
  }

  /**
   * Update renderer size
   * @param {number} width - Width in pixels
   * @param {number} height - Height in pixels
   */
  static updateSize(width, height) {
    if (!this.initialized) return this;

    this.options.width = width;
    this.options.height = height;

    if (this.renderer && this.camera) {
      this.renderer.setSize(width, height);
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
    }

    return this;
  }

  /**
   * Dispose of renderer resources
   */
  static dispose() {
    if (!this.initialized) return;

    // Stop animation loop
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    // Dispose of THREE.js resources
    if (this.renderer) {
      this.renderer.dispose();
      this.renderer = null;
    }

    // Dispose of worker
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }

    // Clear scene
    if (this.scene) {
      this._disposeScene(this.scene);
      this.scene = null;
    }

    this.model = null;
    this.camera = null;
    this.clock = null;
    this.ready = false;
    this.initialized = false;

    if (this.options.debug) {
      console.log('[HologramRenderer] Disposed');
    }
  }

  /**
   * Initialize WebGL renderer
   * @private
   */
  static _initWebGL() {
    // Dynamically import THREE.js
    if (typeof window === 'undefined' || !window.THREE) {
      console.error('[HologramRenderer] THREE.js not available');
      return;
    }

    const THREE = window.THREE;

    // Create renderer
    this.renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true,
    });
    this.renderer.setSize(this.options.width, this.options.height);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;

    // Create scene
    this.scene = new THREE.Scene();

    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      45,
      this.options.width / this.options.height,
      0.1,
      1000
    );
    this.camera.position.set(0, 0, 5);
    this.camera.lookAt(0, 0, 0);

    // Create lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    this.scene.add(directionalLight);

    // Add renderer to container
    if (this.container) {
      this.container.appendChild(this.renderer.domElement);
    }

    // Initialize clock for animations
    this.clock = new THREE.Clock();

    // Add quantum particle system
    this._setupParticleSystem();
  }

  /**
   * Initialize quantum worker
   * @private
   */
  static _initQuantumWorker() {
    try {
      this.worker = new Worker('/assets/quantum-worker.js');

      this.worker.addEventListener('message', (event) => {
        const { type, result, error } = event.data;

        switch (type) {
        case 'quantum-state-result':
          this._updateQuantumState(result);
          break;

        case 'trauma-patterns-result':
          this._applyTraumaPatterns(result);
          break;

        case 'mutation-profile-result':
          this._applyMutationProfile(result);
          break;

        case 'error':
          console.error('[HologramRenderer] Worker error:', error);
          break;
        }
      });
    } catch (error) {
      console.error('[HologramRenderer] Failed to initialize worker:', error);

      // Fallback to synchronous calculation
      this.worker = null;
    }
  }

  /**
   * Set up particle system
   * @private
   */
  static _setupParticleSystem() {
    if (!this.scene || !window.THREE) return;

    const THREE = window.THREE;

    // Create particle geometry
    const particleCount = 1000;
    const particleGeometry = new THREE.BufferGeometry();

    // Position attribute
    const positions = new Float32Array(particleCount * 3);

    // Create particles in a spherical volume
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;

      // Random position in a sphere
      const radius = 3 * Math.random() + 1;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i3 + 2] = radius * Math.cos(phi);
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Create color attribute
    const colors = new Float32Array(particleCount * 3);
    const baseColor = this._getProfileColor(this.options.profile);
    const color = new THREE.Color(baseColor);

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;

      // Slight variations of the base color
      const hsl = { h: 0, s: 0, l: 0 };
      color.getHSL(hsl);

      // Add slight hue variation
      const newColor = new THREE.Color().setHSL(
        hsl.h + (Math.random() * 0.1 - 0.05),
        hsl.s + Math.random() * 0.2,
        hsl.l + (Math.random() * 0.2 - 0.1)
      );

      colors[i3] = newColor.r;
      colors[i3 + 1] = newColor.g;
      colors[i3 + 2] = newColor.b;
    }

    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create size attribute
    const sizes = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
      sizes[i] = Math.random() * 0.1 + 0.05;
    }

    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Create particle material
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        intensity: { value: this.options.intensity },
      },
      vertexShader: `
        attribute float size;
        varying vec3 vColor;
        uniform float time;
        uniform float intensity;

        void main() {
          vColor = color;

          // Oscillate particles
          vec3 pos = position;
          float offset = time * 0.5 + length(position);
          pos.x += sin(offset) * 0.1 * intensity;
          pos.y += cos(offset * 0.8) * 0.1 * intensity;
          pos.z += sin(offset * 0.6) * 0.1 * intensity;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z) * intensity;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;

        void main() {
          // Calculate distance from center of point
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);

          // Discard pixels outside of circle
          if (dist > 0.5) {
            discard;
          }

          // Add glow effect at the edges
          float alpha = 1.0 - smoothstep(0.3, 0.5, dist);

          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true,
    });

    // Create particle system
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    particleSystem.userData.isQuantumParticles = true;

    // Add to scene
    this.scene.add(particleSystem);

    // Store reference
    this.quantumParticles = particleSystem;
  }

  /**
   * Set up model with materials and transforms
   * @private
   */
  static _setupModel(model, options) {
    // Apply material overrides
    if (options.materialOverrides) {
      // Apply material overrides to model
    }

    // Apply transform overrides
    if (options.transformOverrides) {
      // Apply position, rotation, scale
    }

    // Center model
    this._centerModel(model);

    // Add to scene
    this.scene.add(model);

    // Apply profile effects
    this._applyProfileToModel(model, this.options.profile);
  }

  /**
   * Start animation loop
   * @private
   */
  static _startAnimation() {
    const animate = () => {
      this.animationFrameId = requestAnimationFrame(animate);

      const delta = this.clock.getDelta();

      // Rotate model
      if (this.model && this.options.autoRotate) {
        this.model.rotation.y += delta * 0.5;
      }

      // Update particle animations
      this._updateParticles(delta);

      // Render scene
      this.renderer.render(this.scene, this.camera);
    };

    animate();
  }

  /**
   * Update particle system
   * @private
   */
  static _updateParticles(delta) {
    // Update quantum particles
    if (this.quantumParticles && this.quantumParticles.material) {
      // Update time uniform
      if (this.quantumParticles.material.uniforms) {
        this.quantumParticles.material.uniforms.time.value += delta;
      }

      // Add rotation effect for some profiles
      if (this.options.profile === 'NeonVortex' || this.options.profile === 'VoidBloom') {
        this.quantumParticles.rotation.y += delta * 0.2;
      }
    }
  }

  /**
   * Update quantum state based on worker results
   * @private
   */
  static _updateQuantumState(result) {
    const { particles, stabilityFactor } = result;

    // Update quantum particle system
    // This would modify the THREE.js particle system
  }

  /**
   * Apply trauma patterns from worker results
   * @private
   */
  static _applyTraumaPatterns(result) {
    const { patterns, combinedEffect } = result;

    // Apply trauma effects to shaders
    // This would modify material uniforms
  }

  /**
   * Apply mutation profile from worker results
   * @private
   */
  static _applyMutationProfile(result) {
    // Apply profile-specific effects to materials and scene
  }

  /**
   * Set up glitch effect
   * @private
   */
  static _setupGlitchEffect(intensity) {
    if (!this.model || !window.THREE) return;

    const THREE = window.THREE;

    // Create glitch effect uniforms
    const glitchUniforms = {
      time: { value: 0 },
      intensity: { value: intensity },
      resolution: { value: new THREE.Vector2(this.options.width, this.options.height) },
    };

    // Apply glitch effect to all model materials
    this.model.traverse((object) => {
      if (object.isMesh && object.material) {
        const materials = Array.isArray(object.material) ? object.material : [object.material];

        materials.forEach((material) => {
          // Save original material state
          if (!material.userData.originalBeforeGlitch) {
            material.userData.originalBeforeGlitch = {
              onBeforeCompile: material.onBeforeCompile || null,
            };
          }

          // Set up the shader modification
          material.onBeforeCompile = (shader) => {
            // Call original handler if it exists
            if (material.userData.originalBeforeGlitch.onBeforeCompile) {
              material.userData.originalBeforeGlitch.onBeforeCompile(shader);
            }

            // Add glitch uniforms
            shader.uniforms.glitchTime = glitchUniforms.time;
            shader.uniforms.glitchIntensity = glitchUniforms.intensity;
            shader.uniforms.glitchResolution = glitchUniforms.resolution;

            // Add function definitions to vertex shader
            shader.vertexShader = shader.vertexShader.replace(
              'void main() {',
              `
              uniform float glitchTime;
              uniform float glitchIntensity;

              // Random functions for glitch effect
              float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
              }

              // Glitch displacement function
              vec3 glitchOffset(vec3 pos, float time, float intensity) {
                float noise = random(vec2(time * 0.01, pos.y * 0.1));

                vec3 offset = vec3(0.0);
                if (noise > 0.98) {
                  offset.x = (random(vec2(time, pos.y)) * 2.0 - 1.0) * 0.1 * intensity;
                }
                return offset;
              }

              void main() {
              `
            );

            // Add position modification
            shader.vertexShader = shader.vertexShader.replace(
              '#include <begin_vertex>',
              `
              #include <begin_vertex>

              // Apply glitch effect
              vec3 glitchPos = transformed;
              transformed += glitchOffset(position, glitchTime.x, glitchIntensity.x);

              // Add block displacement based on noise
              float blockNoise = random(vec2(floor(position.y * 10.0) * 0.1, glitchTime.x * 0.1));
              if (blockNoise > 0.95) {
                transformed.x += (random(vec2(glitchTime.x * 0.2, blockNoise)) * 2.0 - 1.0) * 0.1 * glitchIntensity.x;
              }
              `
            );

            // Add color modification to fragment shader
            shader.fragmentShader = shader.fragmentShader.replace(
              'void main() {',
              `
              uniform float glitchTime;
              uniform float glitchIntensity;
              uniform vec2 glitchResolution;

              // RGB shift function
              vec3 rgbShift(sampler2D textureMap, vec2 uv, vec2 offset) {
                float r = texture2D(textureMap, uv + offset).r;
                vec2 gb = texture2D(textureMap, uv).gb;
                return vec3(r, gb);
              }

              // Random functions
              float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
              }

              void main() {
              `
            );

            // Only modify fragment color if the shader has gl_FragColor
            if (shader.fragmentShader.includes('gl_FragColor = ')) {
              shader.fragmentShader = shader.fragmentShader.replace(
                'gl_FragColor = ',
                `
                // Apply scan line effect
                float scanLine = sin(gl_FragCoord.y * 0.1 + glitchTime.x * 2.0) * 0.1 * glitchIntensity.x;

                // Apply color shift on random blocks
                float colorShiftNoise = random(vec2(floor(gl_FragCoord.y / 4.0) * 0.02, glitchTime.x * 0.1));
                vec3 colorShift = vec3(1.0);

                if (colorShiftNoise > 0.98) {
                  colorShift.r = 1.0 + 0.3 * glitchIntensity.x;
                  colorShift.b = 1.0 - 0.3 * glitchIntensity.x;
                }

                gl_FragColor =
                `
              );

              // Add intensity modification to the final color
              shader.fragmentShader = shader.fragmentShader.replace(
                /gl_FragColor(\s+)=(\s+)(.+?);/,
                `gl_FragColor = $3;

                // Apply glitch effects to final color
                gl_FragColor.rgb = gl_FragColor.rgb * colorShift;
                gl_FragColor.rgb += vec3(scanLine);

                // Add noise on strong glitches
                if (glitchIntensity.x > 0.8 && random(vec2(gl_FragCoord.xy)) > 0.97) {
                  gl_FragColor.rgb = vec3(random(gl_FragCoord.xy + glitchTime.x));
                }
                `
              );
            }

            // Set needsUpdate to apply changes
            material.needsUpdate = true;
          };
        });
      }
    });

    // Store glitch uniforms for animation updates
    this.glitchUniforms = glitchUniforms;

    // Start glitch animation
    this._animateGlitch();
  }

  /**
   * Remove glitch effect
   * @private
   */
  static _removeGlitchEffect() {
    if (!this.model) return;

    // Restore original materials
    this.model.traverse((object) => {
      if (object.isMesh && object.material) {
        const materials = Array.isArray(object.material) ? object.material : [object.material];

        materials.forEach((material) => {
          if (material.userData.originalBeforeGlitch) {
            material.onBeforeCompile = material.userData.originalBeforeGlitch.onBeforeCompile;
            material.userData.originalBeforeGlitch = null;
            material.needsUpdate = true;
          }
        });
      }
    });

    // Stop glitch animation
    if (this.glitchAnimationId) {
      cancelAnimationFrame(this.glitchAnimationId);
      this.glitchAnimationId = null;
    }

    this.glitchUniforms = null;
  }

  /**
   * Animate glitch effect
   * @private
   */
  static _animateGlitch() {
    if (!this.glitchUniforms) return;

    const updateGlitch = () => {
      this.glitchAnimationId = requestAnimationFrame(updateGlitch);

      // Update time uniform
      this.glitchUniforms.time.value += 0.05;

      // Add random intensity spikes
      if (Math.random() > 0.9) {
        const spike = Math.random() * 0.5 + 0.5;
        this.glitchUniforms.intensity.value = spike * this.options.intensity;
      } else {
        this.glitchUniforms.intensity.value = this.options.intensity;
      }
    };

    updateGlitch();
  }

  /**
   * Center the model in the scene
   * @private
   */
  static _centerModel(model) {
    if (!model || !window.THREE) return;

    const THREE = window.THREE;

    // Create a bounding box for the model
    const boundingBox = new THREE.Box3().setFromObject(model);

    // Calculate the center of the bounding box
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);

    // Calculate size for scaling if needed
    const size = new THREE.Vector3();
    boundingBox.getSize(size);

    // Get the largest dimension for scaling calculations
    const maxDim = Math.max(size.x, size.y, size.z);

    // If the model is very large or very small, normalize its scale
    if (maxDim > 10 || maxDim < 0.1) {
      const scale = 2 / maxDim;
      model.scale.set(scale, scale, scale);

      // Recalculate bounding box after scaling
      boundingBox.setFromObject(model);
      boundingBox.getCenter(center);
    }

    // Move the model so its center is at the origin
    // Need to negate the center position since we're moving the model
    model.position.x = -center.x;
    model.position.y = -center.y;
    model.position.z = -center.z;

    // For some models with children, also center their children
    if (model.children && model.children.length > 0) {
      model.children.forEach((child) => {
        if (child.type === 'Group' || child.type === 'Mesh') {
          // Adjust position relative to parent
          child.position.x -= center.x;
          child.position.y -= center.y;
          child.position.z -= center.z;
        }
      });
    }

    // Apply a slight y-offset to place model just above ground plane if present
    const groundOffset = this.options.groundPlane ? 0.01 : 0;
    model.position.y += groundOffset;
  }

  /**
   * Apply profile-specific effects to model
   * @private
   */
  static _applyProfileToModel(model, profile) {
    if (!model || !window.THREE) return;

    const THREE = window.THREE;

    // Get profile-specific color
    const baseColor = this._getProfileColor(profile);
    const color = new THREE.Color(baseColor);

    // Apply to model materials
    model.traverse((object) => {
      if (object.isMesh && object.material) {
        // Handle array of materials
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => {
            this._applyProfileToMaterial(material, profile, color);
          });
        } else {
          // Handle single material
          this._applyProfileToMaterial(object.material, profile, color);
        }
      }
    });

    // Apply profile-specific scale or rotation
    switch (profile) {
    case 'CyberLotus':
      // Standard positioning
      break;
    case 'ObsidianBloom':
      // Slight rotation
      model.rotation.y = Math.PI * 0.1;
      break;
    case 'VoidBloom':
      // Floating effect - elevate slightly
      model.position.y += 0.2;
      break;
    case 'NeonVortex':
      // Dynamic scale pulse will be handled in animation
      break;
    }
  }

  /**
   * Apply profile effects to a specific material
   * @private
   */
  static _applyProfileToMaterial(material, profile, color) {
    if (!material) return;

    // Store original values for reset
    if (!material.userData.original) {
      material.userData.original = {
        color: material.color ? material.color.clone() : null,
        emissive: material.emissive ? material.emissive.clone() : null,
        emissiveIntensity: material.emissiveIntensity,
        metalness: material.metalness,
        roughness: material.roughness,
      };
    }

    // Apply profile-specific material modifications
    switch (profile) {
    case 'CyberLotus':
      // Cyan-blue holographic look
      if (material.emissive) {
        material.emissive.set(0x00ffff);
        material.emissiveIntensity = 0.3;
      }
      material.metalness = 0.7;
      material.roughness = 0.2;
      break;

    case 'ObsidianBloom':
      // Magenta-purple ethereal look
      if (material.emissive) {
        material.emissive.set(0xff00ff);
        material.emissiveIntensity = 0.4;
      }
      material.metalness = 0.8;
      material.roughness = 0.1;
      break;

    case 'VoidBloom':
      // Deep purple mystical look
      if (material.emissive) {
        material.emissive.set(0x9900ff);
        material.emissiveIntensity = 0.5;
      }
      material.metalness = 0.5;
      material.roughness = 0.3;
      break;

    case 'NeonVortex':
      // Green-cyan energetic look
      if (material.emissive) {
        material.emissive.set(0x00ff66);
        material.emissiveIntensity = 0.6;
      }
      material.metalness = 0.9;
      material.roughness = 0.1;
      break;
    }

    // Add subtle color tint to all materials
    if (material.color) {
      const originalHSL = { h: 0, s: 0, l: 0 };
      material.userData.original.color.getHSL(originalHSL);

      const profileHSL = { h: 0, s: 0, l: 0 };
      color.getHSL(profileHSL);

      // Blend original color with profile color
      material.color.setHSL(profileHSL.h, Math.max(0.5, originalHSL.s), originalHSL.l);
    }

    // Set transparency for holographic effect
    material.transparent = true;
    material.opacity = 0.85;

    // Update shader uniforms if present
    if (material.onBeforeCompile) {
      const originalOnBeforeCompile = material.onBeforeCompile;
      material.onBeforeCompile = function (shader) {
        // Call original handler
        originalOnBeforeCompile(shader);

        // Add custom uniforms
        shader.uniforms.time = { value: 0 };
        shader.uniforms.hologramIntensity = { value: 0.5 };

        // Add vertex displacement
        shader.vertexShader = shader.vertexShader.replace(
          'void main() {',
          `
          uniform float time;
          uniform float hologramIntensity;

          // Holographic wave function
          float hologramWave(vec3 pos, float time) {
            return sin(pos.y * 10.0 + time) * 0.01 * hologramIntensity;
          }

          void main() {
          `
        );

        // Add position modification
        shader.vertexShader = shader.vertexShader.replace(
          '#include <begin_vertex>',
          `
          #include <begin_vertex>

          // Apply holographic wave displacement
          transformed.x += hologramWave(position, time * 2.0);
          transformed.z += hologramWave(position, time * 1.5);
          `
        );
      };
    }
  }

  /**
   * Get color for specific profile
   * @private
   */
  static _getProfileColor(profile) {
    switch (profile) {
    case 'CyberLotus':
      return '#00ffff'; // Cyan
    case 'ObsidianBloom':
      return '#ff00ff'; // Magenta
    case 'VoidBloom':
      return '#9900ff'; // Purple
    case 'NeonVortex':
      return '#00ff66'; // Green
    default:
      return '#00ffff'; // Default to Cyan
    }
  }

  /**
   * Get appropriate loader for model format
   * @private
   */
  static _getLoader(format) {
    if (!window.THREE) {
      console.error('[HologramRenderer] THREE.js not available');
      return null;
    }

    const THREE = window.THREE;

    // Ensure the loaders are available
    if (!THREE.GLTFLoader && !THREE.OBJLoader) {
      console.error('[HologramRenderer] Required THREE.js loaders not available');

      // Return basic mock loader
      return {
        load: (url, onLoad, onProgress, onError) => {
          // Create a basic cube as placeholder
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshStandardMaterial({ color: 0x888888 });
          const mesh = new THREE.Mesh(geometry, material);

          // Wrap in group for consistency
          const group = new THREE.Group();
          group.add(mesh);

          setTimeout(() => onLoad(group), 100);
        },
      };
    }

    // Return appropriate loader based on format
    switch (format) {
    case 'glb':
    case 'gltf':
      if (THREE.GLTFLoader) {
        return new THREE.GLTFLoader();
      }
      break;

    case 'obj':
      if (THREE.OBJLoader) {
        return new THREE.OBJLoader();
      }
      break;
    }

    // Fallback to mock loader
    console.warn(`[HologramRenderer] No loader found for format: ${format}`);
    return {
      load: (url, onLoad, onProgress, onError) => {
        // Create a basic sphere as placeholder
        const geometry = new THREE.SphereGeometry(1, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const mesh = new THREE.Mesh(geometry, material);

        // Wrap in group for consistency
        const group = new THREE.Group();
        group.add(mesh);

        setTimeout(() => onLoad(group), 100);
      },
    };
  }

  /**
   * Dispose of all scene resources
   * @private
   */
  static _disposeScene(scene) {
    if (!scene) return;

    // Recursively dispose of all geometries, materials, and textures
    scene.traverse((object) => {
      // Dispose of geometries
      if (object.geometry) {
        object.geometry.dispose();
      }

      // Dispose of materials
      if (object.material) {
        // Handle array of materials
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => {
            this._disposeMaterial(material);
          });
        } else {
          // Handle single material
          this._disposeMaterial(object.material);
        }
      }

      // Remove any event listeners or callbacks
      if (object.userData && object.userData.eventListeners) {
        for (const [target, events] of Object.entries(object.userData.eventListeners)) {
          for (const [event, callback] of Object.entries(events)) {
            target.removeEventListener(event, callback);
          }
        }
      }
    });

    // Remove all objects from scene
    while (scene.children.length > 0) {
      scene.remove(scene.children[0]);
    }
  }

  /**
   * Dispose of a material and its textures
   * @private
   */
  static _disposeMaterial(material) {
    if (!material) return;

    // Dispose textures used by this material
    for (const key of Object.keys(material)) {
      const value = material[key];
      if (value && typeof value === 'object' && 'isTexture' in value) {
        value.dispose();
      }
    }

    // Dispose the material itself
    material.dispose();
  }
}

// Export the renderer
export default HologramRenderer;
