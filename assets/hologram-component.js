/**
 * HOLOGRAM-COMPONENT.JS
 * Custom Element implementation for holographic product previews
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 1.0.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * CartPreviewHologram Web Component
 * Reusable custom element for embedding holographic product previews anywhere in the DOM
 */
class CartPreviewHologram extends HTMLElement {
  // Private class properties
  #initialized = false;
  #productId = null;
  #modelUrl = null;
  #renderer = null;
  #shadow = null;
  #container = null;
  #observer = null;
  #neuralBusSubscriptions = [];
  #productData = null;
  #mutationProfile = 'CyberLotus';
  #arSupported = false;
  #arMode = false;
  #rendererModule = null;
  #resizeDebounce = null;
  #rendererRegistry = null;

  /**
   * Constructor - Sets up shadow DOM and initial structure
   */
  constructor() {
    super();

    // Create shadow DOM
    this.#shadow = this.attachShadow({ mode: 'open' });

    // Create renderer registry if it doesn't exist
    if (!window.__hologramRenderers) {
      window.__hologramRenderers = new Map();
      this.#rendererRegistry = window.__hologramRenderers;
    } else {
      this.#rendererRegistry = window.__hologramRenderers;
    }

    // Set initial HTML
    this.#shadow.innerHTML = `
      <style>
        :host {
          display: block;
          position: relative;
          width: 100%;
          height: 300px;
          overflow: hidden;
          --hologram-color: #00ffff;
          --hologram-bg: rgba(0, 0, 0, 0.8);
          --hologram-text: #ffffff;
          --hologram-highlight: #00ffff;
        }
        
        :host([profile="CyberLotus"]) {
          --hologram-color: #00ffff;
        }
        
        :host([profile="ObsidianBloom"]) {
          --hologram-color: #ff00ff;
        }
        
        :host([profile="VoidBloom"]) {
          --hologram-color: #9900ff;
        }
        
        :host([profile="NeonVortex"]) {
          --hologram-color: #00ff66;
        }
        
        :host([ar-mode="true"]) .hologram-container {
          opacity: 0;
          pointer-events: none;
        }
        
        :host([ar-mode="true"]) .ar-container {
          opacity: 1;
          pointer-events: auto;
        }
        
        .hologram-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          transition: opacity 0.3s ease;
        }
        
        .ar-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0;
          transition: opacity 0.3s ease;
          pointer-events: none;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--hologram-bg);
        }
        
        .ar-content {
          text-align: center;
          color: var(--hologram-text);
          font-family: 'Courier New', monospace;
        }
        
        .hologram-loading {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--hologram-bg);
          color: var(--hologram-color);
          font-family: 'Courier New', monospace;
          z-index: 5;
        }
        
        .hologram-loading.hidden {
          display: none;
        }
        
        .hologram-loading-spinner {
          border: 2px solid transparent;
          border-top: 2px solid var(--hologram-color);
          border-right: 2px solid var(--hologram-color);
          border-radius: 50%;
          width: 30px;
          height: 30px;
          animation: spin 1s linear infinite;
          margin-right: 10px;
        }
        
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .hologram-error {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--hologram-bg);
          color: #ff3333;
          font-family: 'Courier New', monospace;
          z-index: 5;
        }
        
        .hologram-error.hidden {
          display: none;
        }
        
        .hologram-controls {
          position: absolute;
          bottom: 10px;
          right: 10px;
          display: flex;
          gap: 8px;
          z-index: 10;
        }
        
        .hologram-btn {
          background: var(--hologram-bg);
          color: var(--hologram-color);
          border: 1px solid var(--hologram-color);
          border-radius: 4px;
          padding: 5px 10px;
          font-family: 'Courier New', monospace;
          font-size: 12px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 5px;
          transition: all 0.2s ease;
        }
        
        .hologram-btn:hover {
          background: var(--hologram-color);
          color: var(--hologram-bg);
        }
        
        .hologram-btn svg {
          width: 16px;
          height: 16px;
        }
        
        .hologram-btn.hidden {
          display: none;
        }
        
        .hologram-badge {
          position: absolute;
          top: 10px;
          left: 10px;
          background: var(--hologram-bg);
          color: var(--hologram-color);
          padding: 3px 8px;
          border-radius: 4px;
          font-family: 'Courier New', monospace;
          font-size: 10px;
          z-index: 10;
          border: 1px solid var(--hologram-color);
        }
        
        .quantum-pulse {
          animation: pulse 0.5s ease;
        }
        
        @keyframes pulse {
          0% { filter: brightness(1); }
          50% { filter: brightness(2); }
          100% { filter: brightness(1); }
        }
      </style>
      
      <div class="hologram-container">
        <!-- Hologram will render here -->
      </div>
      
      <div class="ar-container">
        <div class="ar-content">
          <p>Experience this product in your space</p>
          <a class="hologram-btn ar-link">
            <span>View in AR</span>
          </a>
        </div>
      </div>
      
      <div class="hologram-loading">
        <div class="hologram-loading-spinner"></div>
        <span>Materializing hologram...</span>
      </div>
      
      <div class="hologram-error hidden">
        <span>Holographic projection failed</span>
      </div>
      
      <div class="hologram-controls">
        <button class="hologram-btn rotate-toggle">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21.5 2v6h-6"></path>
            <path d="M2.5 12.5v-6h6"></path>
            <path d="M21.5 15.5c-1 3.5-4 5-7 5s-6-1.5-7-5"></path>
            <path d="M2.5 8.5c1-3.5 4-5 7-5s6 1.5 7 5"></path>
          </svg>
          <span>Rotate</span>
        </button>
        <button class="hologram-btn effect-toggle">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 22v-5"></path>
            <path d="M12 2v5"></path>
            <path d="M4.93 19.07l3.54-3.54"></path>
            <path d="M4.93 4.93l3.54 3.54"></path>
            <path d="M19.07 19.07l-3.54-3.54"></path>
            <path d="M19.07 4.93l-3.54 3.54"></path>
            <path d="M2 12h5"></path>
            <path d="M17 12h5"></path>
            <circle cx="12" cy="12" r="4"></circle>
          </svg>
          <span>Effect</span>
        </button>
        <button class="hologram-btn ar-toggle hidden">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
          <span>AR Mode</span>
        </button>
      </div>
      
      <div class="hologram-badge"></div>
    `;

    // Cache DOM elements
    this.#container = this.#shadow.querySelector('.hologram-container');
  }

  /**
   * Connected callback - Fires when element is added to DOM
   */
  connectedCallback() {
    // Get attributes
    this.#productId = this.getAttribute('product-id');
    this.#modelUrl = this.getAttribute('model-url');
    this.#mutationProfile = this.getAttribute('profile') || 'CyberLotus';

    // Set profile attribute
    this.setAttribute('profile', this.#mutationProfile);

    // Update UI
    this.#updateBadge();

    // Initialize when visible
    this.#observeVisibility();

    // Add event listeners
    this.#addEventListeners();

    // Connect to Neural Bus
    this.#connectToNeuralBus();

    // Check for AR support
    this.#checkArSupport();
  }

  /**
   * Disconnected callback - Fires when element is removed from DOM
   */
  disconnectedCallback() {
    // Clean up
    this.#disconnectFromNeuralBus();
    this.#destroyRenderer();

    // Stop observing
    if (this.#observer) {
      this.#observer.disconnect();
      this.#observer = null;
    }

    // Clear resize debounce
    if (this.#resizeDebounce) {
      clearTimeout(this.#resizeDebounce);
    }
  }

  /**
   * Attribute changed callback - Fires when an observed attribute changes
   */
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    switch (name) {
      case 'product-id':
        this.#productId = newValue;
        this.#loadProductData();
        break;
      case 'model-url':
        this.#modelUrl = newValue;
        this.#updateModel();
        break;
      case 'profile':
        this.#mutationProfile = newValue;
        this.#updateProfile();
        break;
      case 'ar-mode':
        this.#arMode = newValue === 'true';
        this.#updateArMode();
        break;
    }
  }

  /**
   * Define which attributes to observe
   */
  static get observedAttributes() {
    return ['product-id', 'model-url', 'profile', 'ar-mode'];
  }

  /**
   * Start observing visibility to initialize when in viewport
   * @private
   */
  #observeVisibility() {
    this.#observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && !this.#initialized) {
          this.#initialize();
        }
      },
      { threshold: 0.1 }
    );

    this.#observer.observe(this);
  }

  /**
   * Initialize the component
   * @private
   */
  #initialize() {
    if (this.#initialized) return;

    // Load dynamic dependencies
    this.#loadDependencies()
      .then(() => {
        // Initialize renderer
        this.#initRenderer();

        // Load model or product data
        if (this.#productId) {
          this.#loadProductData();
        } else if (this.#modelUrl) {
          this.#updateModel();
        }

        this.#initialized = true;
      })
      .catch((error) => {
        console.error('Failed to initialize hologram component:', error);
        this.#showError('Initialization failed');
      });

    // Handle window resize
    window.addEventListener('resize', this.#handleResize.bind(this));
  }

  /**
   * Load required dependencies
   * @private
   * @returns {Promise} Promise that resolves when dependencies are loaded
   */
  #loadDependencies() {
    return new Promise((resolve, reject) => {
      // Import hologram renderer
      import('../assets/hologram-renderer.js')
        .then((module) => {
          this.#rendererModule = module;
          resolve();
        })
        .catch(reject);
    });
  }

  /**
   * Initialize hologram renderer
   * @private
   */
  #initRenderer() {
    if (!this.#rendererModule || !this.#container) return;

    // Show loading indicator
    this.#showLoading();

    try {
      // Create renderer instance
      this.#renderer = this.#rendererModule.HologramRenderer.initialize({
        container: this.#container,
        width: this.offsetWidth,
        height: this.offsetHeight,
        autoRotate: true,
        hologramEffect: true,
        useGlitch: true,
        neuralSynced: true,
        debug: false,
      });

      // Store in registry
      if (this.#productId) {
        this.#rendererRegistry.set(this.#productId, this.#renderer);
      }

      // Hide loading indicator
      this.#hideLoading();
    } catch (error) {
      console.error('Failed to initialize hologram renderer:', error);
      this.#showError('Renderer initialization failed');
    }
  }

  /**
   * Load product data from Shopify
   * @private
   */
  #loadProductData() {
    if (!this.#productId) return;

    this.#showLoading();

    // Fetch product data from Shopify
    fetch(`/products/${this.#productId}.js`)
      .then((response) => {
        if (!response.ok) {
          throw new Error(`Failed to fetch product: ${response.status}`);
        }
        return response.json();
      })
      .then((productData) => {
        this.#productData = productData;

        // Find model URL
        const modelUrl = this.#findProductModelUrl(productData);
        if (modelUrl) {
          this.#modelUrl = modelUrl;
          this.#updateModel();
        } else {
          this.#showError('No 3D model available');
        }

        // Publish product view event
        this.#publishProductView(productData);
      })
      .catch((error) => {
        console.error('Failed to load product data:', error);
        this.#showError('Failed to load product data');
      });
  }

  /**
   * Find 3D model URL in product data
   * @private
   * @param {Object} product - Product data
   * @returns {string|null} Model URL or null if not found
   */
  #findProductModelUrl(product) {
    if (!product) return null;

    // Check for model in media
    if (product.media && Array.isArray(product.media)) {
      const modelMedia = product.media.find((m) => m.media_type === 'model');
      if (modelMedia && modelMedia.sources) {
        const glbSource = modelMedia.sources.find((s) => s.format === 'glb');
        if (glbSource) return glbSource.url;
      }
    }

    // Fallback: look for model in metafields
    if (product.metafields) {
      const modelField = product.metafields.find((m) => m.namespace === '3d' && m.key === 'model');
      if (modelField && modelField.value) return modelField.value;
    }

    return null;
  }

  /**
   * Find AR model URL (USDZ) in product data
   * @private
   * @param {Object} product - Product data
   * @returns {string|null} AR model URL or null if not found
   */
  #findArModelUrl(product) {
    if (!product) return null;

    // Check for model in media
    if (product.media && Array.isArray(product.media)) {
      const modelMedia = product.media.find((m) => m.media_type === 'model');
      if (modelMedia && modelMedia.sources) {
        const usdzSource = modelMedia.sources.find((s) => s.format === 'usdz');
        if (usdzSource) return usdzSource.url;
      }
    }

    // Fallback: look for model in metafields
    if (product.metafields) {
      const arField = product.metafields.find((m) => m.namespace === '3d' && m.key === 'ar');
      if (arField && arField.value) return arField.value;
    }

    return null;
  }

  /**
   * Update hologram model
   * @private
   */
  #updateModel() {
    if (!this.#renderer || !this.#modelUrl) return;

    this.#showLoading();

    // Load the model
    this.#renderer
      .loadModel(this.#modelUrl, {
        product: this.#productData,
        scale: 1.0,
        position: [0, 0, 0],
        rotation: [0, 0, 0],
      })
      .then(() => {
        this.#hideLoading();

        // Apply profile to renderer
        this.#updateRendererProfile();

        // Trigger a quantum effect
        this.#triggerQuantumEffect();
      })
      .catch((error) => {
        console.error('Failed to load model:', error);
        this.#showError('Failed to load 3D model');
      });
  }

  /**
   * Update the mutation profile
   * @private
   */
  #updateProfile() {
    // Update attribute
    this.setAttribute('profile', this.#mutationProfile);

    // Update badge
    this.#updateBadge();

    // Update renderer if available
    this.#updateRendererProfile();

    // Trigger a quantum effect
    this.#triggerQuantumEffect();
  }

  /**
   * Update renderer profile
   * @private
   */
  #updateRendererProfile() {
    if (!this.#renderer) return;

    // Set color based on profile
    let color = 0x00ffff; // Default cyan

    switch (this.#mutationProfile) {
      case 'CyberLotus':
        color = 0x00ffff; // Cyan
        break;
      case 'ObsidianBloom':
        color = 0xff00ff; // Magenta
        break;
      case 'VoidBloom':
        color = 0x9900ff; // Purple
        break;
      case 'NeonVortex':
        color = 0x00ff66; // Neon green
        break;
    }

    this.#renderer.setHologramColor(color);
  }

  /**
   * Add event listeners to control buttons
   * @private
   */
  #addEventListeners() {
    // Rotation toggle
    const rotateBtn = this.#shadow.querySelector('.rotate-toggle');
    if (rotateBtn) {
      rotateBtn.addEventListener('click', () => {
        if (!this.#renderer) return;

        // Toggle auto-rotation
        const currentState = this.#renderer.isAutoRotating?.() || true;
        this.#renderer.setAutoRotate(!currentState);
      });
    }

    // Effect toggle
    const effectBtn = this.#shadow.querySelector('.effect-toggle');
    if (effectBtn) {
      effectBtn.addEventListener('click', () => {
        if (!this.#renderer) return;

        // Toggle hologram effect
        const currentState = this.#renderer.isHologramEnabled?.() || true;
        this.#renderer.setHologramEffect(!currentState);
      });
    }

    // AR toggle
    const arBtn = this.#shadow.querySelector('.ar-toggle');
    if (arBtn) {
      arBtn.addEventListener('click', () => {
        this.#toggleArMode();
      });
    }

    // AR link
    const arLink = this.#shadow.querySelector('.ar-link');
    if (arLink) {
      arLink.addEventListener('click', () => {
        this.#launchAr();
      });
    }
  }

  /**
   * Handle window resize
   * @private
   */
  #handleResize() {
    // Debounce resize events
    if (this.#resizeDebounce) {
      clearTimeout(this.#resizeDebounce);
    }

    this.#resizeDebounce = setTimeout(() => {
      if (this.#renderer) {
        // Update renderer size
        this.#renderer.updateSize?.(this.offsetWidth, this.offsetHeight);
      }
    }, 250);
  }

  /**
   * Connect to NeuralBus
   * @private
   */
  #connectToNeuralBus() {
    if (typeof NeuralBus === 'undefined') return;

    // Subscribe to quantum mutation events
    const sub1 = NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));
    this.#neuralBusSubscriptions.push(sub1);

    // Subscribe to cart events
    const sub2 = NeuralBus.subscribe('cart:item:added', this.#handleCartEvent.bind(this));
    this.#neuralBusSubscriptions.push(sub2);

    // Subscribe to product view events
    const sub3 = NeuralBus.subscribe('product:view', this.#handleProductView.bind(this));
    this.#neuralBusSubscriptions.push(sub3);
  }

  /**
   * Disconnect from NeuralBus
   * @private
   */
  #disconnectFromNeuralBus() {
    this.#neuralBusSubscriptions.forEach((sub) => {
      if (sub && typeof sub.unsubscribe === 'function') {
        sub.unsubscribe();
      }
    });

    this.#neuralBusSubscriptions = [];
  }

  /**
   * Handle quantum mutation events
   * @private
   * @param {Object} data - Event data
   */
  #handleQuantumMutation(data) {
    if (!data || !data.profile) return;

    // Update profile if a mutation occurs
    this.#mutationProfile = data.profile;
    this.#updateProfile();
  }

  /**
   * Handle cart events
   * @private
   * @param {Object} data - Event data
   */
  #handleCartEvent(data) {
    if (!data || !data.item || !this.#productData) return;

    // Check if this product was added to cart
    if (data.item.product_id === parseInt(this.#productId)) {
      // Publish a quantum mutation event
      NeuralBus.publish('quantum:mutation', {
        source: 'hologram-component',
        target: 'product',
        productId: this.#productId,
        profile: this.#mutationProfile,
        action: 'cart-add',
        timestamp: Date.now(),
      });

      // Show visual effect
      this.#pulseEffect();
    }
  }

  /**
   * Handle product view events
   * @private
   * @param {Object} data - Event data
   */
  #handleProductView(data) {
    if (!data || !data.product || !this.#productId) return;

    // Check if this is the current product
    if (data.product.id === parseInt(this.#productId)) {
      // Update product data
      this.#productData = data.product;

      // Update model if needed
      const modelUrl = this.#findProductModelUrl(data.product);
      if (modelUrl && modelUrl !== this.#modelUrl) {
        this.#modelUrl = modelUrl;
        this.#updateModel();
      }

      // Check for AR support
      this.#checkArSupport();
    }
  }

  /**
   * Publish product view event
   * @private
   * @param {Object} productData - Product data
   */
  #publishProductView(productData) {
    if (typeof NeuralBus === 'undefined' || !productData) return;

    NeuralBus.publish('product:view', {
      source: 'hologram-component',
      product: productData,
      timestamp: Date.now(),
    });
  }

  /**
   * Trigger a quantum effect
   * @private
   */
  #triggerQuantumEffect() {
    if (typeof NeuralBus === 'undefined') return;

    // Trigger a glitch effect via NeuralBus
    NeuralBus.publish('glitch:trigger', {
      intensity: 0.7,
      duration: 500,
      mode: 'rgb-shift',
      source: 'hologram-component',
      target: this.#productId,
    });

    // Add a visual effect
    this.#pulseEffect();
  }

  /**
   * Add a pulse visual effect
   * @private
   */
  #pulseEffect() {
    // Add pulse class to entire component
    this.classList.add('quantum-pulse');

    // Remove after animation completes
    setTimeout(() => {
      this.classList.remove('quantum-pulse');
    }, 500);
  }

  /**
   * Update the profile badge
   * @private
   */
  #updateBadge() {
    const badge = this.#shadow.querySelector('.hologram-badge');
    if (!badge) return;

    badge.textContent = `${this.#mutationProfile} ◆ Active`;
  }

  /**
   * Show loading indicator
   * @private
   */
  #showLoading() {
    const loading = this.#shadow.querySelector('.hologram-loading');
    if (loading) {
      loading.classList.remove('hidden');
    }

    // Hide error if shown
    this.#hideError();
  }

  /**
   * Hide loading indicator
   * @private
   */
  #hideLoading() {
    const loading = this.#shadow.querySelector('.hologram-loading');
    if (loading) {
      loading.classList.add('hidden');
    }
  }

  /**
   * Show error message
   * @private
   * @param {string} message - Error message
   */
  #showError(message) {
    const error = this.#shadow.querySelector('.hologram-error');
    if (error) {
      error.querySelector('span').textContent = message;
      error.classList.remove('hidden');
    }

    // Hide loading if shown
    this.#hideLoading();
  }

  /**
   * Hide error message
   * @private
   */
  #hideError() {
    const error = this.#shadow.querySelector('.hologram-error');
    if (error) {
      error.classList.add('hidden');
    }
  }

  /**
   * Check for AR support
   * @private
   */
  #checkArSupport() {
    if (!this.#productData) return;

    // Check for USDZ model for AR QuickLook
    const arModelUrl = this.#findArModelUrl(this.#productData);

    if (arModelUrl) {
      this.#arSupported = true;

      // Update AR link
      const arLink = this.#shadow.querySelector('.ar-link');
      if (arLink) {
        arLink.href = arModelUrl;
        arLink.rel = 'ar';

        // Add iOS specific attributes
        if (/iP(hone|od|ad)/.test(navigator.platform)) {
          arLink.setAttribute('rel', 'ar');
          arLink.setAttribute('data-ios-class', 'ar-quick-look');
        }
      }

      // Show AR toggle button
      const arBtn = this.#shadow.querySelector('.ar-toggle');
      if (arBtn) {
        arBtn.classList.remove('hidden');
      }
    } else {
      this.#arSupported = false;

      // Hide AR toggle button
      const arBtn = this.#shadow.querySelector('.ar-toggle');
      if (arBtn) {
        arBtn.classList.add('hidden');
      }
    }
  }

  /**
   * Toggle AR mode
   * @private
   */
  #toggleArMode() {
    if (!this.#arSupported) return;

    this.#arMode = !this.#arMode;

    // Update attribute
    this.setAttribute('ar-mode', this.#arMode.toString());
  }

  /**
   * Update AR mode UI
   * @private
   */
  #updateArMode() {
    if (this.#arMode) {
      // Pause renderer to save resources
      if (this.#renderer) {
        this.#renderer.stop?.();
      }
    } else {
      // Resume renderer
      if (this.#renderer) {
        this.#renderer.start?.();
      }
    }
  }

  /**
   * Launch AR experience
   * @private
   */
  #launchAr() {
    if (!this.#arSupported || !this.#productData) return;

    const arModelUrl = this.#findArModelUrl(this.#productData);
    if (!arModelUrl) return;

    // Launch AR QuickLook on iOS
    if (/iP(hone|od|ad)/.test(navigator.platform)) {
      window.location.href = arModelUrl;
    }
  }

  /**
   * Destroy renderer instance
   * @private
   */
  #destroyRenderer() {
    if (this.#renderer) {
      this.#renderer.dispose?.();
      this.#renderer = null;

      // Remove from registry
      if (this.#productId && this.#rendererRegistry) {
        this.#rendererRegistry.delete(this.#productId);
      }
    }
  }
}

// Register the custom element
customElements.define('cart-preview-hologram', CartPreviewHologram);

// Export for module use
export { CartPreviewHologram };
