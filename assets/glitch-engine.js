/**
 * GLITCH-ENGINE.JS
 * Visual glitch effects engine for CyberCore theme
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.5.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * GlitchEngine
 * A high-performance WebGL-accelerated glitch effect system for creating 
 * cyberpunk aesthetic distortions and visual artifacts.
 * 
 * Key Features:
 * - Hardware-accelerated effects using WebGL when available
 * - Fallbacks for non-WebGL environments
 * - Multiple glitch modes and effect types
 * - Performance optimized with RAF throttling
 * - Integration with NeuralBus for event-triggered effects
 */
export class GlitchEngine {
  /**
   * Create a new GlitchEngine instance
   * @param {Object} options - Configuration options
   */
  constructor(options = {}) {
    // Configuration with defaults
    this.config = {
      intensity: options.intensity || 0.5,        // Base intensity of glitch effects
      targetSelector: options.targetSelector || '[data-glitch]',  // CSS selector for targets
      autoStart: options.autoStart !== undefined ? options.autoStart : false,
      useWebGL: options.useWebGL !== undefined ? options.useWebGL : true,
      fpsLimit: options.fpsLimit || 30,           // Performance limit
      glitchMode: options.glitchMode || 'rgb-shift', // Default effect type
      layerCount: options.layerCount || 2,        // Number of distortion layers
      glitchTypes: options.glitchTypes || ['rgb-shift', 'noise', 'scanlines', 'jitter'],
      textGlitch: options.textGlitch !== undefined ? options.textGlitch : true,
      neuralSynced: options.neuralSynced !== undefined ? options.neuralSynced : true,
      debug: options.debug || false
    };
    
    // State
    this.running = false;
    this.targets = [];
    this.rafId = null;
    this.lastFrameTime = 0;
    this.frameInterval = 1000 / this.config.fpsLimit;
    this.webglSupported = this._checkWebGLSupport();
    this.canvasContexts = new Map();
    this.textNodes = new Map();
    this.originalContent = new Map();
    this.glitchCharacters = '!<>-_\\/[]{}â€”=+*^?#________';
    this.neuralBusConnected = false;
    this.neuralNonce = null;
    
    // Initialize
    this._init();
    
    // Auto-start if configured
    if (this.config.autoStart) {
      this.start();
    }
  }
  
  /**
   * Initialize the glitch engine
   * @private
   */
  _init() {
    // Find targets in the DOM
    this._findTargets();
    
    // Initialize WebGL if supported and enabled
    if (this.config.useWebGL && this.webglSupported) {
      this._initWebGL();
    }
    
    // Connect to Neural Bus if available
    if (this.config.neuralSynced) {
      this._connectToNeuralBus();
    }
    
    // Store original content for text glitch
    if (this.config.textGlitch) {
      this._storeOriginalContent();
    }
    
    // Log debug information
    if (this.config.debug) {
      this._logDebug('GlitchEngine initialized', {
        targets: this.targets.length,
        webGL: this.webglSupported,
        neuralConnected: this.neuralBusConnected
      });
    }
    
    // Add resize handler
    window.addEventListener('resize', this._handleResize.bind(this));
  }
  
  /**
   * Start the glitch animation
   * @param {Object} options - Optional runtime options
   * @returns {GlitchEngine} The engine instance for chaining
   */
  start(options = {}) {
    if (this.running) return this;
    
    // Apply runtime options
    if (options.intensity !== undefined) {
      this.config.intensity = options.intensity;
    }
    
    if (options.glitchMode) {
      this.config.glitchMode = options.glitchMode;
    }
    
    // Start animation loop
    this.running = true;
    this.lastFrameTime = performance.now();
    this._tick();
    
    // Notify neural bus if connected
    if (this.neuralBusConnected) {
      NeuralBus.publish('glitch:started', {
        intensity: this.config.intensity,
        mode: this.config.glitchMode,
        targetCount: this.targets.length
      });
    }
    
    return this;
  }
  
  /**
   * Stop the glitch animation
   * @returns {GlitchEngine} The engine instance for chaining
   */
  stop() {
    if (!this.running) return this;
    
    // Stop animation loop
    this.running = false;
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    
    // Reset targets to original state
    this._resetTargets();
    
    // Notify neural bus if connected
    if (this.neuralBusConnected) {
      NeuralBus.publish('glitch:stopped', {
        timestamp: Date.now()
      });
    }
    
    return this;
  }
  
  /**
   * Trigger a momentary glitch pulse
   * @param {Object} options - Pulse options
   * @returns {Promise} Resolves when pulse completes
   */
  pulse(options = {}) {
    const intensity = options.intensity || 1.0;
    const duration = options.duration || 500;
    const mode = options.mode || this.config.glitchMode;
    
    // Store original settings
    const originalIntensity = this.config.intensity;
    const originalMode = this.config.glitchMode;
    const wasRunning = this.running;
    
    // Apply pulse settings
    this.config.intensity = intensity;
    this.config.glitchMode = mode;
    
    if (!wasRunning) {
      this.start();
    }
    
    // Create promise to track completion
    return new Promise((resolve) => {
      setTimeout(() => {
        // Restore original settings
        this.config.intensity = originalIntensity;
        this.config.glitchMode = originalMode;
        
        if (!wasRunning) {
          this.stop();
        }
        
        resolve();
      }, duration);
    });
  }
  
  /**
   * Set the glitch intensity
   * @param {number} intensity - New intensity value (0-1)
   * @returns {GlitchEngine} The engine instance for chaining
   */
  setIntensity(intensity) {
    this.config.intensity = Math.max(0, Math.min(1, intensity));
    return this;
  }
  
  /**
   * Set the glitch mode
   * @param {string} mode - Glitch effect mode
   * @returns {GlitchEngine} The engine instance for chaining
   */
  setMode(mode) {
    if (this.config.glitchTypes.includes(mode)) {
      this.config.glitchMode = mode;
    } else {
      console.warn(`Glitch mode "${mode}" not supported. Using default.`);
      this.config.glitchMode = 'rgb-shift';
    }
    return this;
  }
  
  /**
   * Add a new target element to the engine
   * @param {HTMLElement} element - Element to add
   * @returns {GlitchEngine} The engine instance for chaining
   */
  addTarget(element) {
    if (element && !this.targets.includes(element)) {
      this.targets.push(element);
      
      // Store original content for text glitch
      if (this.config.textGlitch && element.textContent) {
        this.originalContent.set(element, element.textContent);
      }
      
      // Create canvas if using WebGL
      if (this.config.useWebGL && this.webglSupported) {
        this._setupWebGLForElement(element);
      }
    }
    return this;
  }
  
  /**
   * Remove a target element from the engine
   * @param {HTMLElement} element - Element to remove
   * @returns {GlitchEngine} The engine instance for chaining
   */
  removeTarget(element) {
    const index = this.targets.indexOf(element);
    if (index !== -1) {
      this.targets.splice(index, 1);
      
      // Cleanup canvas if using WebGL
      if (this.canvasContexts.has(element)) {
        const canvas = this.canvasContexts.get(element).canvas;
        if (canvas && canvas.parentNode) {
          canvas.parentNode.removeChild(canvas);
        }
        this.canvasContexts.delete(element);
      }
      
      // Restore original content
      if (this.originalContent.has(element)) {
        element.textContent = this.originalContent.get(element);
        this.originalContent.delete(element);
      }
    }
    return this;
  }
  
  /**
   * Main animation tick function
   * @private
   */
  _tick() {
    if (!this.running) return;
    
    const now = performance.now();
    const elapsed = now - this.lastFrameTime;
    
    if (elapsed >= this.frameInterval) {
      // Update last frame time with adjustment to prevent drift
      this.lastFrameTime = now - (elapsed % this.frameInterval);
      
      // Apply glitch effects
      this._applyGlitchEffects();
    }
    
    // Schedule next frame
    this.rafId = requestAnimationFrame(this._tick.bind(this));
  }
  
  /**
   * Apply glitch effects to all targets
   * @private
   */
  _applyGlitchEffects() {
    // Skip if no intensity
    if (this.config.intensity <= 0) return;
    
    // Apply different effects based on mode and available features
    if (this.config.useWebGL && this.webglSupported) {
      this._applyWebGLEffects();
    } else if (this.config.textGlitch) {
      this._applyTextGlitch();
    }
    
    // Apply CSS transform glitches regardless of rendering mode
    this._applyCSSGlitch();
  }
  
  /**
   * Apply WebGL-based glitch effects
   * @private
   */
  _applyWebGLEffects() {
    this.targets.forEach(target => {
      if (!this.canvasContexts.has(target)) return;
      
      const context = this.canvasContexts.get(target);
      const gl = context.gl;
      const program = context.program;
      
      // Skip if WebGL context is lost
      if (!gl || gl.isContextLost()) return;
      
      // Update uniform values based on current settings
      gl.uniform1f(context.intensityLocation, this.config.intensity);
      gl.uniform1f(context.timeLocation, performance.now() / 1000);
      
      // Set mode-specific uniforms
      switch (this.config.glitchMode) {
        case 'rgb-shift':
          gl.uniform1f(context.rgbShiftLocation, this.config.intensity * 0.1);
          break;
        case 'noise':
          gl.uniform1f(context.noiseLocation, this.config.intensity);
          break;
        case 'scanlines':
          gl.uniform1f(context.scanlineLocation, this.config.intensity);
          break;
        case 'jitter':
          gl.uniform2f(
            context.jitterLocation, 
            Math.random() * this.config.intensity * 0.1, 
            Math.random() * this.config.intensity * 0.1
          );
          break;
      }
      
      // Draw the scene
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    });
  }
  
  /**
   * Apply text-based glitch effects
   * @private
   */
  _applyTextGlitch() {
    this.targets.forEach(target => {
      if (!this.originalContent.has(target)) return;
      
      const original = this.originalContent.get(target);
      
      // Determine if we should glitch this frame based on intensity
      const shouldGlitch = Math.random() < this.config.intensity * 0.2;
      
      if (shouldGlitch) {
        let glitched = '';
        
        // Apply character-level glitches
        for (let i = 0; i < original.length; i++) {
          // Random chance to replace character based on intensity
          if (Math.random() < this.config.intensity * 0.3) {
            // Replace with random glitch character
            const glitchChar = this.glitchCharacters.charAt(
              Math.floor(Math.random() * this.glitchCharacters.length)
            );
            glitched += glitchChar;
          } else {
            glitched += original.charAt(i);
          }
        }
        
        target.textContent = glitched;
        
        // Schedule reset after short delay for flicker effect
        setTimeout(() => {
          if (this.running && this.targets.includes(target)) {
            target.textContent = original;
          }
        }, Math.random() * 50 + 50);
      }
    });
  }
  
  /**
   * Apply CSS-based transform glitches
   * @private
   */
  _applyCSSGlitch() {
    this.targets.forEach(target => {
      // Skip if target is a canvas (we're already applying WebGL effects)
      if (target.tagName === 'CANVAS') return;
      
      // Determine if we should glitch this frame based on intensity
      const shouldGlitch = Math.random() < this.config.intensity * 0.15;
      
      if (shouldGlitch) {
        // Apply random transform based on intensity and mode
        const translateX = (Math.random() - 0.5) * this.config.intensity * 10;
        const translateY = (Math.random() - 0.5) * this.config.intensity * 5;
        const skewX = (Math.random() - 0.5) * this.config.intensity * 5;
        
        let transform = '';
        let filter = '';
        
        // Mode-specific effects
        switch (this.config.glitchMode) {
          case 'rgb-shift':
            filter = `hue-rotate(${Math.random() * 360}deg) saturate(${1 + this.config.intensity * 5})`;
            transform = `translate(${translateX}px, ${translateY}px)`;
            break;
          case 'noise':
            // Noise is primarily handled by WebGL, so just add subtle transform
            transform = `translate(${translateX}px, ${translateY}px)`;
            break;
          case 'scanlines':
            // Scanlines effect is primarily handled by WebGL
            transform = `translateY(${translateY}px)`;
            break;
          case 'jitter':
            transform = `translate(${translateX}px, ${translateY}px) skew(${skewX}deg, 0deg)`;
            break;
          default:
            transform = `translate(${translateX}px, ${translateY}px)`;
        }
        
        // Apply effects
        target.style.transform = transform;
        if (filter) {
          target.style.filter = filter;
        }
        
        // Schedule reset after short delay for flicker effect
        setTimeout(() => {
          if (this.running && this.targets.includes(target)) {
            target.style.transform = '';
            if (filter) {
              target.style.filter = '';
            }
          }
        }, Math.random() * 100 + 50);
      }
    });
  }
  
  /**
   * Initialize WebGL for glitch effects
   * @private
   */
  _initWebGL() {
    // Initialize WebGL for each target
    this.targets.forEach(target => {
      this._setupWebGLForElement(target);
    });
  }
  
  /**
   * Setup WebGL for a specific element
   * @private
   * @param {HTMLElement} element - Target element
   */
  _setupWebGLForElement(element) {
    // Create a canvas element for the target
    const canvas = document.createElement('canvas');
    const rect = element.getBoundingClientRect();
    
    // Set canvas size to match element
    canvas.width = rect.width;
    canvas.height = rect.height;
    
    // Position canvas absolutely to overlay the target
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '1';
    
    // Create a relative container if needed
    let container = element;
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }
    
    // Append canvas to container
    element.appendChild(canvas);
    
    // Initialize WebGL context
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
      console.warn('WebGL not supported in this browser');
      element.removeChild(canvas);
      return;
    }
    
    // Create shader program
    const program = this._createShaderProgram(gl);
    
    if (!program) {
      console.warn('Failed to create shader program');
      element.removeChild(canvas);
      return;
    }
    
    // Setup geometry (a simple quad)
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    
    // Quad vertices (two triangles)
    const vertices = [
      -1.0, -1.0,
       1.0, -1.0,
      -1.0,  1.0,
      -1.0,  1.0,
       1.0, -1.0,
       1.0,  1.0
    ];
    
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    
    // Setup attributes
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    
    // Setup uniforms
    const intensityLocation = gl.getUniformLocation(program, 'u_intensity');
    const timeLocation = gl.getUniformLocation(program, 'u_time');
    const rgbShiftLocation = gl.getUniformLocation(program, 'u_rgbShift');
    const noiseLocation = gl.getUniformLocation(program, 'u_noiseAmount');
    const scanlineLocation = gl.getUniformLocation(program, 'u_scanlineAmount');
    const jitterLocation = gl.getUniformLocation(program, 'u_jitter');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    
    // Set resolution uniform
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    
    // Store context for later use
    this.canvasContexts.set(element, {
      canvas,
      gl,
      program,
      intensityLocation,
      timeLocation,
      rgbShiftLocation,
      noiseLocation,
      scanlineLocation,
      jitterLocation,
      resolutionLocation
    });
  }
  
  /**
   * Create WebGL shader program
   * @private
   * @param {WebGLRenderingContext} gl - WebGL context
   * @returns {WebGLProgram} Shader program
   */
  _createShaderProgram(gl) {
    // Vertex shader source
    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_position * 0.5 + 0.5;
      }
    `;
    
    // Fragment shader source
    const fragmentShaderSource = `
      precision mediump float;
      
      varying vec2 v_texCoord;
      
      uniform float u_intensity;
      uniform float u_time;
      uniform vec2 u_resolution;
      uniform float u_rgbShift;
      uniform float u_noiseAmount;
      uniform float u_scanlineAmount;
      uniform vec2 u_jitter;
      
      // Pseudo-random function
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      // Noise function
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        return mix(a, b, u.x) +
              (c - a) * u.y * (1.0 - u.x) +
              (d - b) * u.x * u.y;
      }
      
      void main() {
        // Apply jitter displacement
        vec2 texCoord = v_texCoord + u_jitter;
        
        // RGB shift effect
        vec3 color;
        if (u_rgbShift > 0.0) {
          float r = texture2D(u_texture, texCoord + vec2(u_rgbShift * sin(u_time), 0.0)).r;
          float g = texture2D(u_texture, texCoord).g;
          float b = texture2D(u_texture, texCoord - vec2(u_rgbShift * sin(u_time), 0.0)).b;
          color = vec3(r, g, b);
        } else {
          // Base color (when no texture)
          color = vec3(0.1, 0.1, 0.12);
        }
        
        // Apply noise
        if (u_noiseAmount > 0.0) {
          float noiseValue = noise(texCoord * 100.0 + u_time);
          color = mix(color, vec3(noiseValue), u_noiseAmount * u_intensity);
        }
        
        // Apply scanlines
        if (u_scanlineAmount > 0.0) {
          float scanline = sin(texCoord.y * u_resolution.y * 0.5 - u_time * 10.0) * 0.5 + 0.5;
          color = mix(color, color * scanline, u_scanlineAmount * u_intensity);
        }
        
        // Random glitch blocks
        if (u_intensity > 0.3) {
          float blockNoise = random(floor(texCoord * 10.0) + floor(u_time * 0.1));
          if (blockNoise > 0.95) {
            texCoord.y = fract(texCoord.y + blockNoise * 0.1);
          }
        }
        
        // Random vertical glitch lines
        if (u_intensity > 0.5) {
          float lineNoise = random(vec2(floor(u_time * 10.0), floor(texCoord.y * 20.0)));
          if (lineNoise > 0.5) {
            texCoord.x = fract(texCoord.x + lineNoise * 0.1);
          }
        }
        
        // Output final color with intensity modulation
        gl_FragColor = vec4(color, 1.0);
      }
    `;
    
    // Create shaders
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    
    // Check for compilation errors
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));
      gl.deleteShader(vertexShader);
      return null;
    }
    
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    
    // Check for compilation errors
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    
    // Create program and link shaders
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    // Check for linking errors
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program linking failed:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    
    // Use the program
    gl.useProgram(program);
    
    return program;
  }
  
  /**
   * Find all target elements based on selector
   * @private
   */
  _findTargets() {
    if (typeof this.config.targetSelector === 'string') {
      // Find elements matching selector
      const elements = document.querySelectorAll(this.config.targetSelector);
      this.targets = Array.from(elements);
    } else if (Array.isArray(this.config.targetSelector)) {
      // Use array of elements directly
      this.targets = this.config.targetSelector.filter(el => el instanceof HTMLElement);
    } else if (this.config.targetSelector instanceof HTMLElement) {
      // Use single element
      this.targets = [this.config.targetSelector];
    }
  }
  
  /**
   * Store original content of text elements
   * @private
   */
  _storeOriginalContent() {
    this.targets.forEach(target => {
      if (target.textContent) {
        this.originalContent.set(target, target.textContent);
      }
    });
  }
  
  /**
   * Reset targets to original state
   * @private
   */
  _resetTargets() {
    this.targets.forEach(target => {
      // Reset CSS properties
      target.style.transform = '';
      target.style.filter = '';
      
      // Reset text content if modified
      if (this.originalContent.has(target)) {
        target.textContent = this.originalContent.get(target);
      }
    });
  }
  
  /**
   * Handle window resize events
   * @private
   */
  _handleResize() {
    // Update WebGL canvases if using WebGL
    if (this.config.useWebGL && this.webglSupported) {
      for (const [element, context] of this.canvasContexts.entries()) {
        const canvas = context.canvas;
        const rect = element.getBoundingClientRect();
        
        // Update canvas size
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        // Update GL viewport and uniforms
        const gl = context.gl;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(context.resolutionLocation, canvas.width, canvas.height);
      }
    }
  }
  
  /**
   * Check if WebGL is supported
   * @private
   * @returns {boolean} WebGL support status
   */
  _checkWebGLSupport() {
    try {
      const canvas = document.createElement('canvas');
      return !!(
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
      );
    } catch (e) {
      return false;
    }
  }
  
  /**
   * Connect to Neural Bus for event-driven effects
   * @private
   */
  _connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('glitch-engine', {
          version: '2.5.0',
          capabilities: {
            webgl: this.webglSupported,
            textGlitch: this.config.textGlitch,
            modes: this.config.glitchTypes
          }
        });
        
        this.neuralBusConnected = true;
        this.neuralNonce = registration.nonce;
        
        // Subscribe to relevant events
        NeuralBus.subscribe('glitch:trigger', this._handleGlitchTrigger.bind(this));
        NeuralBus.subscribe('quantum:mutation', this._handleQuantumMutation.bind(this));
        NeuralBus.subscribe('theme:changed', this._handleThemeChange.bind(this));
        
        if (this.config.debug) {
          this._logDebug('Connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
      this.neuralBusConnected = false;
    }
  }
  
  /**
   * Handle glitch trigger events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  _handleGlitchTrigger(data) {
    // Handle immediate glitch pulse request
    if (data && typeof data === 'object') {
      this.pulse({
        intensity: data.intensity || 1.0,
        duration: data.duration || 500,
        mode: data.mode || this.config.glitchMode
      });
    }
  }
  
  /**
   * Handle quantum mutation events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  _handleQuantumMutation(data) {
    if (data && data.profile) {
      // Adjust glitch properties based on mutation profile
      switch (data.profile) {
        case 'CyberLotus':
          this.setMode('rgb-shift');
          break;
        case 'ObsidianBloom':
          this.setMode('noise');
          break;
        case 'VoidBloom':
          this.setMode('jitter');
          break;
        case 'NeonVortex':
          this.setMode('scanlines');
          break;
      }
      
      // Apply a pulse effect to visualize the change
      this.pulse({
        intensity: 0.8,
        duration: 800
      });
    }
  }
  
  /**
   * Handle theme change events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  _handleThemeChange(data) {
    if (data && data.glitchIntensity !== undefined) {
      this.setIntensity(data.glitchIntensity);
    }
    
    if (data && data.glitchMode) {
      this.setMode(data.glitchMode);
    }
  }
  
  /**
   * Log debug information
   * @private
   * @param {string} message - Debug message
   * @param {Object} data - Additional data to log
   */
  _logDebug(message, data) {
    if (!this.config.debug) return;
    
    console.log(`[GlitchEngine] ${message}`, data || '');
  }
}

// Auto-initialize when loaded if in browser environment with auto elements
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    // Auto-init for any elements with data-glitch-auto attribute
    const autoElements = document.querySelectorAll('[data-glitch-auto]');
    
    if (autoElements.length > 0) {
      const engine = new GlitchEngine({
        targetSelector: '[data-glitch-auto]',
        autoStart: true,
        intensity: 0.3
      });
      
      // Expose to global scope for debugging
      window.GlitchEngine = GlitchEngine;
      window.__glitchEngine = engine;
    }
  });
}