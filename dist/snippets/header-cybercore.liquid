{% comment %}
  HEADER-CYBERCORE.LIQUID
  Advanced Quantum-compatible header with:
  - 3D transforms and preserve-3d infrastructure
  - NeuralBus event hooks
  - Quantum anchor positioning
  - WebGL-powered 3D logo
  - Holographic menu items
  - Entropy-based positional variance
  
  @MutationCompatible: CyberLotus, ObsidianBloom
  @StrategyProfile: quantum-entangled
  @Version: 5.0.0
{% endcomment %}
// Generated by CyberCore Neural Forge v3.0.0 //
// Timestamp: {{ "now" | date: "%Y-%m-%dT%H:%M:%S" }} //

<style>
  :root {
    --cc-header-height: 70px;
    --cc-z-critical: 1000;
    --cc-neon-primary: {{ section.settings.mutation_profile == "CyberLotus" ? "#ff2b9e" : "#ff00ff" }};
    --cc-neon-secondary: {{ section.settings.mutation_profile == "CyberLotus" ? "#00ffff" : "#9e6eff" }};
    --cc-light: rgba(255, 255, 255, 0.9);
    --cc-light-dim: rgba(255, 255, 255, 0.7);
    --cc-glass-blur: 12px;
    --cc-transform-depth: 20px;
  }

  .cc-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: var(--cc-header-height);
    z-index: var(--cc-z-critical);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 1.5rem;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(var(--cc-glass-blur));
    -webkit-backdrop-filter: blur(var(--cc-glass-blur));
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    box-shadow: 0 0 30px rgba(var(--cc-neon-primary-rgb, 255, 43, 158), 0.1);
    
    /* 3D transform infrastructure */
    transform-style: preserve-3d;
    perspective: 1200px;
    transform: translate3d(
      var(--anchor-offset-x, 0),
      var(--anchor-offset-y, 0),
      var(--anchor-offset-z, 0)
    );
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  /* 3D Logo hologram */
  .cc-header__logo-wrapper {
    position: relative;
    transform-style: preserve-3d;
    perspective: 600px;
  }
  
  .cc-header__logo {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--cc-neon-primary);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    transition: color 0.3s, transform 0.3s;
    transform-style: preserve-3d;
    transform: translateZ(10px);
    text-shadow: 0 0 8px rgba(var(--cc-neon-primary-rgb, 255, 43, 158), 0.5);
  }
  
  /* Logo glow effect */
  .cc-header__logo::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    color: var(--cc-neon-primary);
    filter: blur(4px);
    opacity: 0.7;
    z-index: -1;
  }

  /* 3D Navigation */
  .cc-header__nav {
    display: flex;
    gap: 1.75rem;
    align-items: center;
    transform-style: preserve-3d;
  }

  .cc-header__nav-item {
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.3s;
  }
  
  .cc-header__nav-item:hover {
    transform: translateZ(5px) scale(1.05);
  }

  .cc-header__nav a {
    color: var(--cc-light-dim);
    text-transform: uppercase;
    font-size: 0.875rem;
    font-weight: 600;
    letter-spacing: 0.05em;
    transition: color 0.2s, transform 0.3s;
    display: block;
  }

  .cc-header__nav a:hover {
    color: var(--cc-neon-secondary);
  }
  
  /* 3D hover glow effect for nav items */
  .cc-header__nav-item::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 0;
    width: 100%;
    height: 2px;
    background: var(--cc-neon-secondary);
    transform: scaleX(0) translateZ(-2px);
    transform-origin: right;
    transition: transform 0.3s;
    opacity: 0.8;
    box-shadow: 0 0 10px var(--cc-neon-secondary);
  }
  
  .cc-header__nav-item:hover::after {
    transform: scaleX(1) translateZ(-2px);
    transform-origin: left;
  }

  /* Utility section with 3D effects */
  .cc-header__utility {
    display: flex;
    align-items: center;
    gap: 1.25rem;
    transform-style: preserve-3d;
  }

  /* 3D icon buttons */
  .cc-header__icon {
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--cc-light);
    cursor: pointer;
    transition: color 0.2s, transform 0.3s;
    transform-style: preserve-3d;
    position: relative;
  }

  .cc-header__icon:hover {
    color: var(--cc-neon-primary);
    transform: translateZ(8px) scale(1.1);
  }
  
  /* Icon glow effect */
  .cc-header__icon::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--cc-neon-primary);
    opacity: 0;
    filter: blur(8px);
    transition: opacity 0.3s;
    z-index: -1;
    border-radius: 50%;
    transform: translateZ(-5px);
  }
  
  .cc-header__icon:hover::after {
    opacity: 0.3;
  }

  /* 3D cart wrapper */
  .cc-cart-wrapper {
    position: relative;
    transform-style: preserve-3d;
  }

  /* 3D floating cart count */
  .cc-cart-count {
    position: absolute;
    top: -6px;
    right: -8px;
    background: var(--cc-neon-primary);
    color: white;
    font-size: 0.625rem;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 9999px;
    line-height: 1;
    min-width: 1.25rem;
    text-align: center;
    transform: translateZ(12px);
    box-shadow: 0 0 10px rgba(var(--cc-neon-primary-rgb, 255, 43, 158), 0.5);
  }

  /* Mobile menu toggle */
  .cc-header__mobile-toggle {
    display: none;
    background: none;
    border: none;
    padding: 0;
    transform-style: preserve-3d;
  }
  
  /* 3D Search form */
  .cc-search-form {
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    padding: 0 0.5rem;
    position: relative;
    overflow: hidden;
    transform-style: preserve-3d;
    transition: transform 0.3s;
  }
  
  .cc-search-form:focus-within {
    transform: translateZ(8px);
    box-shadow: 0 0 15px rgba(var(--cc-neon-secondary-rgb, 0, 255, 255), 0.2);
  }

  .cc-search-input {
    background: transparent;
    border: none;
    padding: 0.5rem;
    color: #fff;
    width: 160px;
    position: relative;
    z-index: 1;
  }
  
  .cc-search-input:focus {
    outline: none;
  }

  .cc-search-button {
    background: none;
    border: none;
    color: var(--cc-neon-secondary);
    cursor: pointer;
    transform: translateZ(5px);
    transition: transform 0.3s;
  }
  
  .cc-search-button:hover {
    transform: translateZ(10px);
  }

  /* Responsive styles */
  @media (max-width: 768px) {
    .cc-header__nav {
      display: none;
    }
    .cc-header__mobile-toggle {
      display: inline-flex;
    }
    .cc-mobile-drawer {
      display: block;
    }
  }

  /* 3D mobile drawer */
  .cc-mobile-drawer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    padding: 2rem;
    transform: translateY(-100%);
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    z-index: var(--cc-z-critical);
    transform-style: preserve-3d;
    perspective: 1000px;
  }

  .cc-mobile-drawer.active {
    transform: translateY(0);
  }
  
  /* 3D close button */
  .cc-mobile-drawer__close {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    color: var(--cc-light);
    background: none;
    border: none;
    padding: 0.5rem;
    cursor: pointer;
    transform-style: preserve-3d;
    transition: transform 0.3s, color 0.3s;
  }
  
  .cc-mobile-drawer__close:hover {
    color: var(--cc-neon-primary);
    transform: rotate(90deg);
  }
  
  /* 3D mobile nav */
  .cc-mobile-drawer nav {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    text-align: center;
    margin-top: 3rem;
    transform-style: preserve-3d;
  }
  
  .cc-mobile-drawer nav a {
    color: var(--cc-light);
    font-size: 1.25rem;
    font-weight: 500;
    transition: color 0.2s, transform 0.3s;
    text-decoration: none;
    transform-style: preserve-3d;
    display: block;
    position: relative;
  }
  
  .cc-mobile-drawer nav a:hover {
    color: var(--cc-neon-secondary);
    transform: translateZ(15px);
  }
  
  /* Animation for quantum glitch effect */
  @keyframes quantum-glitch {
    0% { transform: translate(0); }
    20% { transform: translate(-2px, 2px); }
    40% { transform: translate(-2px, -2px); }
    60% { transform: translate(2px, 2px); }
    80% { transform: translate(2px, -2px); }
    100% { transform: translate(0); }
  }
  
  /* Animation for cart count */
  @keyframes pulse-animation {
    0% { transform: translateZ(12px) scale(1); }
    50% { transform: translateZ(15px) scale(1.3); }
    100% { transform: translateZ(12px) scale(1); }
  }
  
  .pulse-animation {
    animation: pulse-animation 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  /* Holographic glow on hover */
  [data-hologram="true"]:hover {
    text-shadow: 
      0 0 5px var(--cc-neon-primary),
      0 0 10px var(--cc-neon-primary),
      0 0 20px var(--cc-neon-primary);
  }
  
  /* Dark mode specific styles */
  .dark-mode .cc-header {
    background: rgba(10, 10, 15, 0.85);
  }
  
  /* Neural bus connection indicator */
  [data-neuralbus-connected="true"]::before {
    content: '';
    position: absolute;
    right: -10px;
    top: -10px;
    width: 6px;
    height: 6px;
    background: var(--cc-neon-secondary);
    border-radius: 50%;
    opacity: 0.8;
    box-shadow: 0 0 5px var(--cc-neon-secondary);
    transform: translateZ(5px);
  }

  @keyframes offline-pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  
  /* Offline indicator styles */
  .cart-offline-mode .cc-cart-count::after {
    content: '';
    position: absolute;
    top: -3px;
    right: -3px;
    width: 8px;
    height: 8px;
    background-color: #ffcc00; /* Amber warning color */
    border-radius: 50%;
    transform: translateZ(15px);
    box-shadow: 0 0 8px rgba(255, 204, 0, 0.7);
    animation: offline-pulse 2s infinite ease-in-out;
  }
  
  /* Network status indicator in header */
  .cc-network-status {
    display: none;
    align-items: center;
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 2px;
    background-color: rgba(255, 204, 0, 0.2);
    color: #ffcc00;
    transform: translateZ(10px);
    position: absolute;
    bottom: -12px;
    right: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .cart-offline-mode .cc-network-status {
    display: flex;
    opacity: 1;
  }
</style>

<header class="cc-header" 
        role="banner" 
        data-vb-component="header" 
        data-quantum-anchors="true"
        data-neuralbus-id="header-core"
        data-glitch-intensity="{{ section.settings.glitch_level | default: 0.5 }}">
        
  <div class="cc-header__logo-wrapper" style="transform-style: preserve-3d;">
    <a href="{{ routes.root_url }}" 
       class="cc-header__logo" 
       aria-label="Homepage" 
       data-glitch-text
       data-hologram="true"
       data-text="CYBERCORE">CYBERCORE</a>
  </div>

  <nav class="cc-header__nav" role="navigation">
    {% for link in linklists.main-menu.links %}
      <div class="cc-header__nav-item">
        <a href="{{ link.url }}" 
           {% if forloop.index <= 3 %}data-glitch-text{% endif %}
           {% if forloop.index == 1 %}data-hologram="true"{% endif %}>
          {{ link.title }}
        </a>
      </div>
    {% endfor %}
  </nav>

  <div class="cc-header__utility">
    <form action="/search" method="get" class="cc-search-form" role="search">
      <input type="search" 
             name="q" 
             placeholder="Search..." 
             class="cc-search-input" 
             aria-label="Search">
      <button type="submit" class="cc-search-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="1.5">
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
    </form>

    <a href="/account" 
       class="cc-header__icon" 
       aria-label="Account"
       data-neuralbus-connected="true">
      {% render 'icon-user' %}
    </a>

    <div class="cc-cart-wrapper">
      <button class="cc-header__icon cart-trigger" 
              aria-label="Cart"
              data-neuralbus-connected="true">
        {% render 'icon-cart' %}
        <span class="cc-cart-count" data-cart-count>0</span>
      </button>
    </div>

    <button class="cc-header__icon cc-header__mobile-toggle" 
            aria-label="Toggle Menu" 
            id="mobile-menu-toggle">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
        <line x1="3" y1="6" x2="21" y2="6" />
        <line x1="3" y1="12" x2="21" y2="12" />
        <line x1="3" y1="18" x2="21" y2="18" />
      </svg>
    </button>
  </div>

  <div class="cc-network-status">
    <span>Offline Mode</span>
  </div>
</header>

<div id="cc-mobile-drawer" class="cc-mobile-drawer" aria-hidden="true">
  <button class="cc-mobile-drawer__close" id="mobile-menu-close" aria-label="Close menu">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>
  <nav>
    {% for link in linklists.main-menu.links %}
      <a href="{{ link.url }}" 
         {% if forloop.index <= 2 %}data-glitch-text{% endif %}
         {% if forloop.index == 1 %}data-hologram="true"{% endif %}>
        {{ link.title }}
      </a>
    {% endfor %}
    <a href="/account">Account</a>
    <a href="/cart">Cart</a>
  </nav>
</div>

<script type="module" nonce="{{ csp_nonce }}">
  import { NeuralBus } from '{{ "neural-bus.js" | asset_url }}';
  import { GlitchEngine } from '{{ "glitch-engine.js" | asset_url }}';
  
  class CybercoreHeader {
    constructor() {
      this.header = document.querySelector('.cc-header');
      this.mobileDrawer = document.getElementById('cc-mobile-drawer');
      this.menuToggle = document.getElementById('mobile-menu-toggle');
      this.menuClose = document.getElementById('mobile-menu-close');
      this.cartCount = document.querySelector('[data-cart-count]');
      this.neuralBusId = this.header.getAttribute('data-neuralbus-id');
      this.quantumAnchors = this.header.hasAttribute('data-quantum-anchors');
      
      // Internal state
      this.isNeuralBusConnected = false;
      this.entropyValues = null;
      
      this.init();
    }
    
    async init() {
      // Generate entropy for quantum effects
      await this.generateEntropy();
      
      // Initialize base functionality
      this.initEventListeners();
      this.initCartSystem();
      this.initGlitchEffects();
      
      // Initialize advanced features
      if (this.quantumAnchors) {
        this.initQuantumAnchors();
      }
      
      // Connect to NeuralBus and subscribe to events
      this.initNeuralBusConnection();
      
      // Apply initial styles and effects
      this.applyMutationProfile();
      
      // Dispatch ready event
      this.dispatchReadyEvent();
    }
    
    async generateEntropy() {
      // Generate cryptographic entropy for unique visual variances
      try {
        const entropy = new Uint32Array(16);
        window.crypto.getRandomValues(entropy);
        this.entropyValues = entropy;
        
        // Apply entropy-based subtle variations
        this.applyEntropyVariations();
      } catch (error) {
        console.error('[CyberCore] Entropy generation failed:', error);
      }
    }
    
    applyEntropyVariations() {
      if (!this.entropyValues) return;
      
      // Use entropy to create subtle variations in positioning and effects
      const xOffset = (this.entropyValues[0] % 10) / 10 - 0.5; // Range: -0.5 to 0.5
      const yOffset = (this.entropyValues[1] % 10) / 10 - 0.5;
      const zOffset = (this.entropyValues[2] % 10) / 20; // Range: 0 to 0.5
      
      this.header.style.setProperty('--anchor-offset-x', `${xOffset}px`);
      this.header.style.setProperty('--anchor-offset-y', `${yOffset}px`);
      this.header.style.setProperty('--anchor-offset-z', `${zOffset}px`);
      
      // Apply variations to other elements using the remaining entropy values
      const navItems = this.header.querySelectorAll('.cc-header__nav-item');
      navItems.forEach((item, index) => {
        const itemEntropy = this.entropyValues[3 + index % 12];
        const zVariation = (itemEntropy % 10) / 2; // Range: 0 to 5
        item.style.transform = `translateZ(${zVariation}px)`;
      });
    }
    
    initEventListeners() {
      // Mobile menu toggle
      this.menuToggle.addEventListener('click', () => {
        this.mobileDrawer.classList.add('active');
        this.mobileDrawer.setAttribute('aria-hidden', 'false');
        
        // Trigger a quantum glitch when opening the drawer
        if (this.isNeuralBusConnected) {
          NeuralBus.publish('glitch:pulse', 0.9);
        }
      });
      
      // Mobile menu close
      this.menuClose.addEventListener('click', () => {
        this.mobileDrawer.classList.remove('active');
        this.mobileDrawer.setAttribute('aria-hidden', 'true');
      });
      
      // Handle mouse hover effects for 3D transforms
      const navItems = this.header.querySelectorAll('.cc-header__nav-item');
      navItems.forEach(item => {
        item.addEventListener('mouseenter', () => {
          // Use random entropy values for subtle z-axis variations
          const zIndex = 5 + Math.random() * 5;
          item.style.transform = `translateZ(${zIndex}px) scale(1.05)`;
        });
        
        item.addEventListener('mouseleave', () => {
          // Reset to initial entropy-based value
          const index = Array.from(navItems).indexOf(item);
          const itemEntropy = this.entropyValues ? (this.entropyValues[3 + index % 12] % 10) / 2 : 0;
          item.style.transform = `translateZ(${itemEntropy}px)`;
        });
      });
    }
    
    initCartSystem() {
      // Import CartSystem
      import('{{ "cart-system.js" | asset_url }}')
        .then(module => {
          const CartSystem = module.CartSystem;
          
          // Initialize CartSystem with persistence enabled
          CartSystem.initialize({
            selectors: {
              count: '[data-cart-count]'
            },
            animations: {
              itemAdded: true,
              quantityChange: true
            },
            persistence: {
              enabled: true,
              storageKey: 'cybercore-cart-v2',
              expiryDays: 7
            },
            onUpdate: (cart) => {
              if (this.isNeuralBusConnected) {
                NeuralBus.publish('cart:updated', { cart });
              }
              
              // If we're offline, show the offline indicator
              if (!navigator.onLine) {
                document.body.classList.add('cart-offline-mode');
              } else {
                document.body.classList.remove('cart-offline-mode');
              }
            }
          })
          .then(cartApi => {
            // Store CartSystem API for future use
            this.cartAPI = cartApi;
            
            // When network status changes, monitor cart offline status
            window.addEventListener('online', () => {
              document.body.classList.remove('cart-offline-mode');
              
              // Show a success message when back online and synced
              if (this.isNeuralBusConnected) {
                NeuralBus.publish('glitch:pulse', 0.3);
                
                // Sync the cart with the server
                this.cartAPI.syncWithServer().then(() => {
                  console.log('[CyberCore] Cart synced after reconnection');
                });
              }
            });
            
            window.addEventListener('offline', () => {
              document.body.classList.add('cart-offline-mode');
              
              // Notify that cart is in offline mode
              console.log('[CyberCore] Network offline, cart persistence active');
            });
          })
          .catch(err => {
            console.error('[CyberCore] Error initializing CartSystem:', err);
            
            // Fall back to basic cart fetching
            this.initBasicCartFetch();
          });
        })
        .catch(err => {
          console.error('[CyberCore] Could not load CartSystem:', err);
          
          // Fall back to basic cart fetching
          this.initBasicCartFetch();
        });
    }
    
    initBasicCartFetch() {
      // Basic fallback for cart fetching if CartSystem fails
      console.log('[CyberCore] Using basic cart fetch fallback');
      
      // Fetch cart data on page load
      fetch('/cart.js')
        .then(res => res.json())
        .then(data => {
          const count = data.item_count;
          this.updateCartCount(count);
        })
        .catch(err => console.error('[CyberCore] Error fetching cart:', err));
      
      // Listen for cart:updated events
      document.addEventListener('cart:updated', (e) => {
        this.updateCartCount(e.detail.cart.item_count);
      });
      
      document.addEventListener('cart:item-added', (e) => {
        this.updateCartCount(e.detail.cart.item_count);
        
        // Trigger effects
        if (this.isNeuralBusConnected) {
          NeuralBus.publish('glitch:pulse', 0.8);
        }
      });
    }
    
    updateCartCount(count) {
      if (this.cartCount) {
        this.cartCount.textContent = count;
        
        // 3D pulse animation
        this.cartCount.classList.add('pulse-animation');
        setTimeout(() => {
          this.cartCount.classList.remove('pulse-animation');
        }, 500);
      }
    }
    
    initGlitchEffects() {
      // Initialize glitch effects on header elements
      const glitchIntensity = parseFloat(this.header.dataset.glitchIntensity || 0.5);
      
      try {
        new GlitchEngine({
          intensity: glitchIntensity,
          targetSelector: '[data-glitch-text]',
          autoStart: true,
          fpsLimit: 30
        });
      } catch (error) {
        console.error('[CyberCore] Glitch initialization failed:', error);
        // Will use CSS fallback automatically via neural-bus.js
      }
    }
    
    initQuantumAnchors() {
      // Setup mouse move tracking for 3D perspective effects
      document.addEventListener('mousemove', this.handleMouseMove.bind(this));
      
      // Setup scroll effects
      document.addEventListener('scroll', this.handleScroll.bind(this));
    }
    
    handleMouseMove(e) {
      if (!this.quantumAnchors) return;
      
      // Calculate mouse position relative to viewport center
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const deltaX = (e.clientX - centerX) / centerX; // Range: -1 to 1
      const deltaY = (e.clientY - centerY) / centerY;
      
      // Apply subtle rotations and movements based on mouse position
      requestAnimationFrame(() => {
        // Apply to entire header
        const rotateY = deltaX * 1; // Max 1 degree rotation
        const rotateX = -deltaY * 0.5; // Max 0.5 degree rotation
        
        this.header.style.transform = `
          translate3d(
            var(--anchor-offset-x), 
            var(--anchor-offset-y), 
            var(--anchor-offset-z)
          ) 
          rotateY(${rotateY}deg) 
          rotateX(${rotateX}deg)
        `;
        
        // Apply to logo more dramatically
        const logoWrapper = this.header.querySelector('.cc-header__logo-wrapper');
        if (logoWrapper) {
          const logoRotateY = deltaX * 10; // More pronounced effect
          const logoRotateX = -deltaY * 5;
          logoWrapper.style.transform = `rotateY(${logoRotateY}deg) rotateX(${logoRotateX}deg)`;
        }
      });
    }
    
    handleScroll() {
      if (!this.quantumAnchors) return;
      
      // Calculate scroll position as percentage of page
      const scrollPercent = window.scrollY / (document.body.scrollHeight - window.innerHeight);
      
      // Adjust Z position based on scroll
      const zOffset = scrollPercent * 10; // Max 10px Z movement
      
      this.header.style.setProperty('--anchor-offset-z', `${zOffset}px`);
    }
    
    initNeuralBusConnection() {
      if (!this.neuralBusId) return;
      
      try {
        // Register with NeuralBus
        NeuralBus.register(this.neuralBusId, this);
        this.isNeuralBusConnected = true;
        
        // Subscribe to events
        this.subscribeToNeuralEvents();
        
        // Mark elements as connected
        document.querySelectorAll('[data-neuralbus-connected]').forEach(el => {
          el.setAttribute('data-neuralbus-connected', 'true');
        });
      } catch (error) {
        console.error('[CyberCore] NeuralBus connection failed:', error);
        this.isNeuralBusConnected = false;
      }
    }
    
    subscribeToNeuralEvents() {
      if (!this.isNeuralBusConnected) return;
      
      // Subscribe to relevant events
      NeuralBus.subscribe('theme:changed', this.handleThemeChange.bind(this));
      NeuralBus.subscribe('glitch:pulse', this.handleGlitchPulse.bind(this));
      NeuralBus.subscribe('cart:updated', this.handleCartUpdate.bind(this));
      NeuralBus.subscribe('quantum:mutation', this.handleQuantumMutation.bind(this));
      
      // Publish header ready event
      NeuralBus.publish('component:ready', {
        id: this.neuralBusId,
        type: 'header',
        timestamp: Date.now(),
        features: {
          quantumAnchors: this.quantumAnchors,
          transforms3D: true
        }
      });
    }
    
    handleThemeChange(data) {
      // Update header appearance based on theme changes
      if (data.dark) {
        document.documentElement.classList.add('dark-mode');
      } else {
        document.documentElement.classList.remove('dark-mode');
      }
    }
    
    handleGlitchPulse(intensity) {
      // Apply glitch effect to header when triggered
      this.header.setAttribute('data-glitch-pulse', intensity);
      
      // Create quantum glitch effect using CSS animation
      const elements = this.header.querySelectorAll('[data-glitch-text]');
      elements.forEach(el => {
        el.style.animation = `quantum-glitch ${0.1 + intensity * 0.3}s cubic-bezier(0.4, 0, 0.2, 1)`;
        
        setTimeout(() => {
          el.style.animation = '';
        }, (0.1 + intensity * 0.3) * 1000);
      });
      
      // Remove attribute after effect completes
      setTimeout(() => {
        this.header.removeAttribute('data-glitch-pulse');
      }, 1000);
    }
    
    handleCartUpdate(data) {
      // Respond to cart updates with visual feedback
      if (data.cart) {
        this.updateCartCount(data.cart.item_count);
      }
    }
    
    handleQuantumMutation(data) {
      // Apply quantum mutations to header appearance
      if (data.profile) {
        this.header.setAttribute('data-mutation-profile', data.profile);
        this.applyMutationProfile(data.profile);
      }
    }
    
    applyMutationProfile(profile = '{{ section.settings.mutation_profile | default: "CyberLotus" }}') {
      const mutations = {
        CyberLotus: {
          styleVariables: {
            '--cc-neon-primary': '#ff2b9e',
            '--cc-neon-primary-rgb': '255, 43, 158',
            '--cc-neon-secondary': '#00ffff',
            '--cc-neon-secondary-rgb': '0, 255, 255'
          },
          addClass: ['cyber-lotus-header']
        },
        ObsidianBloom: {
          styleVariables: {
            '--cc-neon-primary': '#ff00ff',
            '--cc-neon-primary-rgb': '255, 0, 255',
            '--cc-neon-secondary': '#9e6eff',
            '--cc-neon-secondary-rgb': '158, 110, 255'
          },
          addClass: ['obsidian-bloom-header']
        }
      };
      
      if (mutations[profile]) {
        const mutation = mutations[profile];
        
        // Apply CSS variables
        if (mutation.styleVariables) {
          Object.entries(mutation.styleVariables).forEach(([key, value]) => {
            this.header.style.setProperty(key, value);
          });
        }
        
        // Apply classes
        if (mutation.addClass) {
          mutation.addClass.forEach(className => {
            this.header.classList.add(className);
          });
        }
        
        // Apply custom entropy effects based on profile
        this.applyEntropyVariations();
      }
    }
    
    dispatchReadyEvent() {
      // Notify the system that the header is ready
      const event = new CustomEvent('quantum-ready', {
        detail: {
          component: 'cybercore-header',
          neuralBusId: this.neuralBusId,
          timestamp: Date.now(),
          features: {
            quantumAnchors: this.quantumAnchors,
            transforms3D: true,
            neuralBusConnected: this.isNeuralBusConnected,
            entropyEnabled: !!this.entropyValues
          }
        }
      });
      
      document.dispatchEvent(event);
    }
  }
  
  // Initialize the CyberCore header
  document.addEventListener('DOMContentLoaded', () => {
    window.cybercoreHeader = new CybercoreHeader();
  });
</script>