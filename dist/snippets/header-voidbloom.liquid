{% comment %}
  HEADER-VOIDBLOOM.LIQUID
  Advanced Quantum-compatible VoidBloom variant header with:
  - Particle effect background
  - Void bloom animations
  - Neural flux interactions
  - Dimensional shift menu
  
  @MutationCompatible: VoidBloom, NeonVortex
  @StrategyProfile: quantum-entangled
  @Version: 3.0.0
{% endcomment %}
// Generated by VoidBloom Neural Forge v2.2.1 //
// Timestamp: {{ "now" | date: "%Y-%m-%dT%H:%M:%S" }} //

<style>
  :root {
    --vb-header-height: 70px;
    --vb-z-critical: 1000;
    --vb-primary: {{ section.settings.mutation_profile == "VoidBloom" ? "#6600ff" : "#00c8ff" }};
    --vb-primary-rgb: {{ section.settings.mutation_profile == "VoidBloom" ? "102, 0, 255" : "0, 200, 255" }};
    --vb-secondary: {{ section.settings.mutation_profile == "VoidBloom" ? "#ff00cc" : "#ff5500" }};
    --vb-secondary-rgb: {{ section.settings.mutation_profile == "VoidBloom" ? "255, 0, 204" : "255, 85, 0" }};
    --vb-light: rgba(255, 255, 255, 0.9);
    --vb-light-dim: rgba(255, 255, 255, 0.7);
    --vb-glass-blur: 15px;
    --vb-transform-depth: 25px;
    --vb-particle-count: {{ section.settings.particle_count | default: 50 }};
    --vb-particle-size: {{ section.settings.particle_size | default: 3 }};
    --vb-particle-speed: {{ section.settings.particle_speed | default: 1.5 }};
  }

  .vb-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: var(--vb-header-height);
    z-index: var(--vb-z-critical);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 1.75rem;
    background: rgba(0, 0, 0, 0.65);
    backdrop-filter: blur(var(--vb-glass-blur));
    -webkit-backdrop-filter: blur(var(--vb-glass-blur));
    border-bottom: 1px solid rgba(var(--vb-primary-rgb), 0.2);
    box-shadow: 0 0 30px rgba(var(--vb-primary-rgb), 0.15);
    
    /* 3D transform infrastructure */
    transform-style: preserve-3d;
    perspective: 1500px;
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  }

  /* Particle background container */
  .vb-header__particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
    pointer-events: none;
  }

  /* Logo with bloom effect */
  .vb-header__logo-wrapper {
    position: relative;
    transform-style: preserve-3d;
  }
  
  .vb-header__logo {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--vb-primary);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    transform-style: preserve-3d;
    transform: translateZ(15px);
    position: relative;
    text-shadow: 0 0 10px rgba(var(--vb-primary-rgb), 0.7);
  }

  /* Bloom glow effects */
  .vb-header__logo::before,
  .vb-header__logo::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transform-style: preserve-3d;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .vb-header__logo::before {
    color: var(--vb-primary);
    filter: blur(7px);
    transform: translateZ(-5px);
  }
  
  .vb-header__logo::after {
    color: var(--vb-secondary);
    filter: blur(12px);
    transform: translateZ(-10px);
  }
  
  .vb-header__logo:hover::before {
    opacity: 0.8;
    transform: translateZ(-8px) translateX(-2px);
  }
  
  .vb-header__logo:hover::after {
    opacity: 0.6;
    transform: translateZ(-15px) translateX(2px);
  }

  /* 3D Navigation */
  .vb-header__nav {
    display: flex;
    gap: 2rem;
    align-items: center;
    transform-style: preserve-3d;
  }

  .vb-header__nav-item {
    position: relative;
    transform-style: preserve-3d;
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .vb-header__nav-item:hover {
    transform: translateZ(10px) scale(1.05);
  }

  .vb-header__nav a {
    color: var(--vb-light-dim);
    text-transform: uppercase;
    font-size: 0.875rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    display: block;
  }

  .vb-header__nav a:hover {
    color: var(--vb-secondary);
  }
  
  /* Dimensional rift nav effect */
  .vb-header__nav-item::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 0;
    width: 100%;
    height: 2px;
    background: var(--vb-secondary);
    transform: scaleX(0) translateZ(-3px);
    transform-origin: right;
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    opacity: 0.8;
    box-shadow: 0 0 15px var(--vb-secondary);
  }
  
  .vb-header__nav-item:hover::after {
    transform: scaleX(1) translateZ(-3px);
    transform-origin: left;
  }

  /* Utility section with 3D effects */
  .vb-header__utility {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    transform-style: preserve-3d;
  }

  /* Dimensional icons */
  .vb-header__icon {
    width: 24px;
    height: 24px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--vb-light);
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    transform-style: preserve-3d;
    position: relative;
    transform: translateZ(0);
  }

  .vb-header__icon:hover {
    color: var(--vb-primary);
    transform: translateZ(12px) scale(1.1);
  }
  
  /* Icon void bloom effect */
  .vb-header__icon::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--vb-primary);
    opacity: 0;
    filter: blur(10px);
    transition: opacity 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    z-index: -1;
    border-radius: 50%;
    transform: translateZ(-8px);
  }
  
  .vb-header__icon:hover::after {
    opacity: 0.5;
  }

  /* 3D cart wrapper */
  .vb-cart-wrapper {
    position: relative;
    transform-style: preserve-3d;
  }

  /* Dimensional floating cart count */
  .vb-cart-count {
    position: absolute;
    top: -6px;
    right: -8px;
    background: var(--vb-secondary);
    color: white;
    font-size: 0.625rem;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 9999px;
    line-height: 1;
    min-width: 1.25rem;
    text-align: center;
    transform: translateZ(15px);
    box-shadow: 0 0 12px rgba(var(--vb-secondary-rgb), 0.7);
  }

  /* Mobile menu toggle */
  .vb-header__mobile-toggle {
    display: none;
    background: none;
    border: none;
    padding: 0;
    transform-style: preserve-3d;
  }
  
  /* Dimensional Search form */
  .vb-search-form {
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.07);
    border-radius: 6px;
    padding: 0 0.75rem;
    position: relative;
    overflow: hidden;
    transform-style: preserve-3d;
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .vb-search-form:focus-within {
    transform: translateZ(10px);
    box-shadow: 0 0 20px rgba(var(--vb-secondary-rgb), 0.3);
    background: rgba(255, 255, 255, 0.1);
  }

  .vb-search-input {
    background: transparent;
    border: none;
    padding: 0.5rem;
    color: #fff;
    width: 180px;
    position: relative;
    z-index: 1;
  }
  
  .vb-search-input:focus {
    outline: none;
  }

  .vb-search-button {
    background: none;
    border: none;
    color: var(--vb-secondary);
    cursor: pointer;
    transform: translateZ(7px);
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .vb-search-button:hover {
    transform: translateZ(12px);
  }

  /* Animation for void bloom effect */
  @keyframes void-bloom {
    0% { transform: scale(1) rotate(0deg); opacity: 0.7; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 0.4; }
    100% { transform: scale(1) rotate(360deg); opacity: 0.7; }
  }

  @keyframes void-particle-float {
    0% { transform: translateY(0) translateX(0); }
    25% { transform: translateY(-10px) translateX(5px); }
    50% { transform: translateY(0) translateX(10px); }
    75% { transform: translateY(10px) translateX(5px); }
    100% { transform: translateY(0) translateX(0); }
  }
  
  /* Animation for dimensional pulse */
  @keyframes dimensional-pulse {
    0% { transform: translateZ(15px) scale(1); }
    50% { transform: translateZ(20px) scale(1.3); }
    100% { transform: translateZ(15px) scale(1); }
  }
  
  .dimensional-pulse {
    animation: dimensional-pulse 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  /* Neural flux glow on hover */
  [data-flux="true"]:hover {
    text-shadow: 
      0 0 5px var(--vb-primary),
      0 0 15px var(--vb-primary),
      0 0 30px var(--vb-primary);
  }
  
  /* Responsive styles */
  @media (max-width: 768px) {
    .vb-header__nav {
      display: none;
    }
    .vb-header__mobile-toggle {
      display: inline-flex;
    }
    .vb-mobile-drawer {
      display: block;
    }
  }

  /* Dimensional mobile drawer */
  .vb-mobile-drawer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(25px);
    -webkit-backdrop-filter: blur(25px);
    padding: 2.5rem;
    transform: translateX(-100%);
    transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
    z-index: var(--vb-z-critical);
    transform-style: preserve-3d;
    perspective: 1200px;
  }

  .vb-mobile-drawer.active {
    transform: translateX(0);
  }
  
  /* Dimensional rift close button */
  .vb-mobile-drawer__close {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    color: var(--vb-light);
    background: none;
    border: none;
    padding: 0.5rem;
    cursor: pointer;
    transform-style: preserve-3d;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .vb-mobile-drawer__close:hover {
    color: var(--vb-secondary);
    transform: rotate(90deg) translateZ(10px);
  }
  
  /* Dimensional mobile nav */
  .vb-mobile-drawer nav {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    text-align: center;
    margin-top: 4rem;
    transform-style: preserve-3d;
  }
  
  .vb-mobile-drawer nav a {
    color: var(--vb-light);
    font-size: 1.5rem;
    font-weight: 500;
    transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
    text-decoration: none;
    transform-style: preserve-3d;
    display: block;
    position: relative;
    letter-spacing: 0.1em;
  }
  
  .vb-mobile-drawer nav a:hover {
    color: var(--vb-primary);
    transform: translateZ(20px);
  }
  
  /* Neural flux connection indicator */
  [data-neural-connected="true"]::before {
    content: '';
    position: absolute;
    right: -10px;
    top: -10px;
    width: 6px;
    height: 6px;
    background: var(--vb-primary);
    border-radius: 50%;
    opacity: 0.8;
    box-shadow: 0 0 8px var(--vb-primary);
    transform: translateZ(8px);
    animation: void-bloom 4s infinite cubic-bezier(0.2, 0.8, 0.2, 1);
  }

  /* Offline indicator styles */
  .cart-offline-mode .vb-cart-count::after {
    content: '';
    position: absolute;
    top: -3px;
    right: -3px;
    width: 8px;
    height: 8px;
    background-color: #ffcc00; /* Amber warning color */
    border-radius: 50%;
    transform: translateZ(18px);
    box-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
    animation: void-bloom 3s infinite cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  /* Network status indicator in header */
  .vb-network-status {
    display: none;
    align-items: center;
    font-size: 0.75rem;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    background-color: rgba(255, 204, 0, 0.15);
    color: #ffcc00;
    transform: translateZ(12px);
    position: absolute;
    bottom: -15px;
    right: 15px;
    opacity: 0;
    transition: opacity 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  
  .cart-offline-mode .vb-network-status {
    display: flex;
    opacity: 1;
  }
</style>

<header class="vb-header" 
        role="banner" 
        data-vb-component="header" 
        data-dimensional-anchors="true"
        data-neural-id="voidbloom-core"
        data-flux-intensity="{{ section.settings.flux_intensity | default: 0.6 }}">
        
  <div class="vb-header__particles" id="vb-particles"></div>
        
  <div class="vb-header__logo-wrapper" style="transform-style: preserve-3d;">
    <a href="{{ routes.root_url }}" 
       class="vb-header__logo" 
       aria-label="Homepage" 
       data-void-bloom
       data-flux="true"
       data-text="VOIDBLOOM">VOIDBLOOM</a>
  </div>

  <nav class="vb-header__nav" role="navigation">
    {% for link in linklists.main-menu.links %}
      <div class="vb-header__nav-item">
        <a href="{{ link.url }}" 
           {% if forloop.index <= 3 %}data-void-bloom{% endif %}
           {% if forloop.index == 1 %}data-flux="true"{% endif %}>
          {{ link.title }}
        </a>
      </div>
    {% endfor %}
  </nav>

  <div class="vb-header__utility">
    <form action="/search" method="get" class="vb-search-form" role="search">
      <input type="search" 
             name="q" 
             placeholder="Search..." 
             class="vb-search-input" 
             aria-label="Search">
      <button type="submit" class="vb-search-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="1.5">
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
    </form>

    <a href="/account" 
       class="vb-header__icon" 
       aria-label="Account"
       data-neural-connected="true">
      {% render 'icon-user', cyber_details: true, cyber_glow: true %}
    </a>

    <div class="vb-cart-wrapper">
      <button class="vb-header__icon cart-trigger" 
              aria-label="Cart"
              data-neural-connected="true">
        {% render 'icon-cart', cyber_details: true, cyber_glow: true %}
        <span class="vb-cart-count" data-cart-count>0</span>
      </button>
    </div>

    <button class="vb-header__icon vb-header__mobile-toggle" 
            aria-label="Toggle Menu" 
            id="mobile-menu-toggle">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
        <line x1="3" y1="6" x2="21" y2="6" />
        <line x1="3" y1="12" x2="21" y2="12" />
        <line x1="3" y1="18" x2="21" y2="18" />
      </svg>
    </button>
  </div>

  <div class="vb-network-status">
    <span>Dimensional Rift Active</span>
  </div>
</header>

<div id="vb-mobile-drawer" class="vb-mobile-drawer" aria-hidden="true">
  <button class="vb-mobile-drawer__close" id="mobile-menu-close" aria-label="Close menu">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>
  <nav>
    {% for link in linklists.main-menu.links %}
      <a href="{{ link.url }}" 
         {% if forloop.index <= 2 %}data-void-bloom{% endif %}
         {% if forloop.index == 1 %}data-flux="true"{% endif %}>
        {{ link.title }}
      </a>
    {% endfor %}
    <a href="/account" data-void-bloom>Account</a>
    <a href="/cart" data-void-bloom>Cart</a>
  </nav>
</div>

<script type="module" nonce="{{ csp_nonce }}">
  import { NeuralBus } from '{{ "neural-bus.js" | asset_url }}';
  import { GlitchEngine } from '{{ "glitch-engine.js" | asset_url }}';
  
  class VoidBloomHeader {
    constructor() {
      this.header = document.querySelector('.vb-header');
      this.mobileDrawer = document.getElementById('vb-mobile-drawer');
      this.menuToggle = document.getElementById('mobile-menu-toggle');
      this.menuClose = document.getElementById('mobile-menu-close');
      this.cartCount = document.querySelector('[data-cart-count]');
      this.particlesContainer = document.getElementById('vb-particles');
      this.neuralId = this.header.getAttribute('data-neural-id');
      this.dimensionalAnchors = this.header.hasAttribute('data-dimensional-anchors');
      
      // Internal state
      this.isNeuralConnected = false;
      this.entropyValues = null;
      this.particles = [];
      this.particleCount = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vb-particle-count')) || 50;
      
      this.init();
    }
    
    async init() {
      // Generate entropy for quantum effects
      await this.generateEntropy();
      
      // Initialize particle system
      this.initParticles();
      
      // Initialize base functionality
      this.initEventListeners();
      this.initCartSystem();
      
      // Initialize dimensional effects
      if (this.dimensionalAnchors) {
        this.initDimensionalAnchors();
      }
      
      // Connect to NeuralBus and subscribe to events
      this.initNeuralConnection();
      
      // Apply void bloom effects to elements
      this.initVoidBloomEffects();
      
      // Dispatch ready event
      this.dispatchReadyEvent();
    }
    
    async generateEntropy() {
      // Generate cryptographic entropy for unique visual variances
      try {
        const entropy = new Uint32Array(16);
        window.crypto.getRandomValues(entropy);
        this.entropyValues = entropy;
      } catch (error) {
        console.error('[VoidBloom] Entropy generation failed:', error);
      }
    }
    
    initParticles() {
      // Create particle system for header background
      if (!this.particlesContainer) return;
      
      // Clear any existing particles
      this.particlesContainer.innerHTML = '';
      
      // Create particles
      for (let i = 0; i < this.particleCount; i++) {
        const particle = document.createElement('div');
        
        // Use entropy for variation if available
        const entropyIndex = i % 16;
        const size = this.entropyValues ? 
          (this.entropyValues[entropyIndex] % 5) + 1 : 
          Math.random() * 5 + 1;
          
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        const delay = Math.random() * 5;
        const duration = (Math.random() * 15) + 10;
        const opacity = (Math.random() * 0.5) + 0.1;
        
        // Alternate between primary and secondary colors
        const isSecondary = i % 2 === 0;
        const color = isSecondary ? 'var(--vb-secondary)' : 'var(--vb-primary)';
        
        // Apply styles
        particle.style.cssText = `
          position: absolute;
          left: ${x}%;
          top: ${y}%;
          width: ${size}px;
          height: ${size}px;
          border-radius: 50%;
          background-color: ${color};
          opacity: ${opacity};
          filter: blur(${size / 2}px);
          pointer-events: none;
          animation: void-particle-float ${duration}s infinite ease-in-out;
          animation-delay: -${delay}s;
          transform-style: preserve-3d;
          transform: translateZ(${-size * 2}px);
        `;
        
        this.particlesContainer.appendChild(particle);
        this.particles.push(particle);
      }
    }
    
    initEventListeners() {
      // Mobile menu toggle
      this.menuToggle.addEventListener('click', () => {
        this.mobileDrawer.classList.add('active');
        this.mobileDrawer.setAttribute('aria-hidden', 'false');
        
        // Trigger a void bloom effect
        if (this.isNeuralConnected) {
          NeuralBus.publish('void:bloom', 0.9);
        }
      });
      
      // Mobile menu close
      this.menuClose.addEventListener('click', () => {
        this.mobileDrawer.classList.remove('active');
        this.mobileDrawer.setAttribute('aria-hidden', 'true');
      });
      
      // Handle mouse hover effects for dimensional transforms
      const navItems = this.header.querySelectorAll('.vb-header__nav-item');
      navItems.forEach(item => {
        item.addEventListener('mouseenter', () => {
          const zIndex = 10 + Math.random() * 5;
          item.style.transform = `translateZ(${zIndex}px) scale(1.05)`;
        });
        
        item.addEventListener('mouseleave', () => {
          item.style.transform = '';
        });
      });
    }
    
    initCartSystem() {
      // Import CartSystem for cart functionality
      import('{{ "cart-system.js" | asset_url }}')
        .then(module => {
          const CartSystem = module.CartSystem;
          
          // Initialize CartSystem with VoidBloom-specific config
          CartSystem.initialize({
            selectors: {
              count: '[data-cart-count]'
            },
            animations: {
              itemAdded: true,
              quantityChange: true
            },
            persistence: {
              enabled: true,
              storageKey: 'voidbloom-cart-v1',
              expiryDays: 7
            },
            onUpdate: (cart) => {
              if (this.isNeuralConnected) {
                NeuralBus.publish('cart:updated', { cart });
              }
              
              // If we're offline, show the dimensional rift indicator
              if (!navigator.onLine) {
                document.body.classList.add('cart-offline-mode');
              } else {
                document.body.classList.remove('cart-offline-mode');
              }
            }
          })
          .then(cartApi => {
            // Store CartSystem API for future use
            this.cartAPI = cartApi;
            
            // When network status changes, monitor cart offline status
            window.addEventListener('online', () => {
              document.body.classList.remove('cart-offline-mode');
              
              // Show a success effect when back online and synced
              if (this.isNeuralConnected) {
                NeuralBus.publish('void:bloom', 0.5);
                
                // Sync the cart with the server
                this.cartAPI.syncWithServer().then(() => {
                  console.log('[VoidBloom] Cart synchronized after dimensional rift closure');
                });
              }
            });
            
            window.addEventListener('offline', () => {
              document.body.classList.add('cart-offline-mode');
              console.log('[VoidBloom] Dimensional rift detected, cart persistence active');
            });
          })
          .catch(err => {
            console.error('[VoidBloom] Error initializing CartSystem:', err);
            this.initBasicCartFetch();
          });
        })
        .catch(err => {
          console.error('[VoidBloom] Could not load CartSystem:', err);
          this.initBasicCartFetch();
        });
    }
    
    initBasicCartFetch() {
      // Basic fallback for cart functionality if CartSystem fails
      console.log('[VoidBloom] Using basic cart fetch fallback');
      
      fetch('/cart.js')
        .then(res => res.json())
        .then(data => {
          const count = data.item_count;
          this.updateCartCount(count);
        })
        .catch(err => console.error('[VoidBloom] Error fetching cart:', err));
      
      document.addEventListener('cart:updated', (e) => {
        this.updateCartCount(e.detail.cart.item_count);
      });
      
      document.addEventListener('cart:item-added', (e) => {
        this.updateCartCount(e.detail.cart.item_count);
        
        if (this.isNeuralConnected) {
          NeuralBus.publish('void:bloom', 0.8);
        }
      });
    }
    
    updateCartCount(count) {
      if (this.cartCount) {
        this.cartCount.textContent = count;
        
        // Dimensional pulse animation
        this.cartCount.classList.add('dimensional-pulse');
        setTimeout(() => {
          this.cartCount.classList.remove('dimensional-pulse');
        }, 500);
      }
    }
    
    initVoidBloomEffects() {
      // Initialize void bloom effects on elements with data-void-bloom attribute
      const elements = document.querySelectorAll('[data-void-bloom]');
      
      elements.forEach(element => {
        // Create glow effect elements
        const glow1 = document.createElement('div');
        const glow2 = document.createElement('div');
        
        glow1.className = 'void-bloom-glow primary-glow';
        glow2.className = 'void-bloom-glow secondary-glow';
        
        // Position glows
        glow1.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background-color: var(--vb-primary);
          opacity: 0;
          filter: blur(10px);
          transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
          pointer-events: none;
          z-index: -1;
        `;
        
        glow2.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background-color: var(--vb-secondary);
          opacity: 0;
          filter: blur(15px);
          transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
          pointer-events: none;
          z-index: -2;
        `;
        
        // Only append if element has relative positioning
        const position = getComputedStyle(element).position;
        if (position === 'static') {
          element.style.position = 'relative';
        }
        
        element.appendChild(glow1);
        element.appendChild(glow2);
        
        // Add hover effects
        element.addEventListener('mouseenter', () => {
          glow1.style.opacity = '0.5';
          glow2.style.opacity = '0.3';
        });
        
        element.addEventListener('mouseleave', () => {
          glow1.style.opacity = '0';
          glow2.style.opacity = '0';
        });
      });
    }
    
    initDimensionalAnchors() {
      // Setup dimensional anchor effects for 3D perspective
      document.addEventListener('mousemove', this.handleMouseMove.bind(this));
      document.addEventListener('scroll', this.handleScroll.bind(this));
    }
    
    handleMouseMove(e) {
      if (!this.dimensionalAnchors) return;
      
      // Calculate mouse position relative to viewport center
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const deltaX = (e.clientX - centerX) / centerX; // Range: -1 to 1
      const deltaY = (e.clientY - centerY) / centerY;
      
      // Apply subtle transformations based on mouse position
      requestAnimationFrame(() => {
        // Apply to entire header
        const rotateY = deltaX * 2; // Max 2 degree rotation
        const rotateX = -deltaY * 1; // Max 1 degree rotation
        const translateX = deltaX * 5; // Max 5px shift
        const translateY = deltaY * 3; // Max 3px shift
        
        this.header.style.transform = `
          translate3d(${translateX}px, ${translateY}px, 0)
          rotateY(${rotateY}deg) 
          rotateX(${rotateX}deg)
        `;
        
        // Affect particles with opposing movement for parallax
        this.particles.forEach((particle, index) => {
          const depth = index % 5;
          const moveX = -deltaX * (depth + 1) * 3;
          const moveY = -deltaY * (depth + 1) * 2;
          
          particle.style.transform = `translateX(${moveX}px) translateY(${moveY}px) translateZ(${-depth * 5}px)`;
        });
      });
    }
    
    handleScroll() {
      if (!this.dimensionalAnchors) return;
      
      // Create subtle parallax effect on scroll
      const scrollY = window.scrollY;
      const translateY = scrollY * 0.05; // Subtle effect
      
      // Apply subtle float effect to header
      this.header.style.transform = `translateY(${translateY}px)`;
      
      // Apply opposing movement to particles
      this.particles.forEach((particle, index) => {
        const speed = (index % 3 + 1) * 0.1;
        particle.style.transform = `translateY(${-scrollY * speed}px)`;
      });
    }
    
    initNeuralConnection() {
      if (!this.neuralId) return;
      
      try {
        // Register with NeuralBus
        NeuralBus.register(this.neuralId, this);
        this.isNeuralConnected = true;
        
        // Subscribe to events
        this.subscribeToNeuralEvents();
        
        // Mark elements as connected
        document.querySelectorAll('[data-neural-connected]').forEach(el => {
          el.setAttribute('data-neural-connected', 'true');
        });
      } catch (error) {
        console.error('[VoidBloom] Neural connection failed:', error);
        this.isNeuralConnected = false;
      }
    }
    
    subscribeToNeuralEvents() {
      if (!this.isNeuralConnected) return;
      
      // Subscribe to relevant events
      NeuralBus.subscribe('theme:changed', this.handleThemeChange.bind(this));
      NeuralBus.subscribe('void:bloom', this.handleVoidBloom.bind(this));
      NeuralBus.subscribe('cart:updated', this.handleCartUpdate.bind(this));
      NeuralBus.subscribe('quantum:mutation', this.handleQuantumMutation.bind(this));
      
      // Publish header ready event
      NeuralBus.publish('component:ready', {
        id: this.neuralId,
        type: 'header-voidbloom',
        timestamp: Date.now(),
        features: {
          dimensionalAnchors: this.dimensionalAnchors,
          particles: this.particles.length,
          voidBloom: true
        }
      });
    }
    
    handleThemeChange(data) {
      // Handle theme change events
      if (data.profile === 'VoidBloom' || data.profile === 'NeonVortex') {
        this.applyThemeProfile(data.profile);
      }
    }
    
    handleVoidBloom(intensity) {
      // Create bloom effect on header elements
      const elements = document.querySelectorAll('[data-void-bloom]');
      
      elements.forEach(el => {
        // Create temporary glow overlay
        const overlay = document.createElement('div');
        overlay.className = 'void-bloom-overlay';
        overlay.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            45deg,
            var(--vb-primary),
            var(--vb-secondary)
          );
          opacity: 0;
          border-radius: inherit;
          filter: blur(20px);
          z-index: 10;
          pointer-events: none;
          transition: opacity 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        `;
        
        // Only append if element has relative positioning
        const position = getComputedStyle(el).position;
        if (position === 'static') {
          el.style.position = 'relative';
        }
        
        el.appendChild(overlay);
        
        // Animate in
        requestAnimationFrame(() => {
          overlay.style.opacity = intensity * 0.7;
        });
        
        // Animate out
        setTimeout(() => {
          overlay.style.opacity = '0';
          setTimeout(() => overlay.remove(), 400);
        }, 600);
      });
      
      // Intensify particle system temporarily
      this.intensifyParticles(intensity);
    }
    
    intensifyParticles(intensity) {
      // Create additional particles temporarily
      const extraParticles = Math.floor(intensity * 20);
      const currentCount = this.particles.length;
      
      // Add temporary particles
      for (let i = 0; i < extraParticles; i++) {
        const particle = document.createElement('div');
        
        const size = Math.random() * 8 + 3;
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        const color = i % 2 === 0 ? 'var(--vb-secondary)' : 'var(--vb-primary)';
        
        particle.style.cssText = `
          position: absolute;
          left: ${x}%;
          top: ${y}%;
          width: ${size}px;
          height: ${size}px;
          border-radius: 50%;
          background-color: ${color};
          opacity: 0.7;
          filter: blur(${size / 2}px);
          animation: void-bloom 2s cubic-bezier(0.2, 0.8, 0.2, 1);
          pointer-events: none;
        `;
        
        this.particlesContainer.appendChild(particle);
        
        // Remove after animation
        setTimeout(() => {
          particle.remove();
        }, 2000);
      }
    }
    
    handleCartUpdate(data) {
      // Handle cart update events
      if (data.cart) {
        this.updateCartCount(data.cart.item_count);
      }
    }
    
    handleQuantumMutation(data) {
      // Handle quantum mutation events
      if (data.profile) {
        this.applyThemeProfile(data.profile);
      }
    }
    
    applyThemeProfile(profile = 'VoidBloom') {
      // Apply theme profile settings
      const profiles = {
        VoidBloom: {
          variables: {
            '--vb-primary': '#6600ff',
            '--vb-primary-rgb': '102, 0, 255',
            '--vb-secondary': '#ff00cc',
            '--vb-secondary-rgb': '255, 0, 204'
          },
          classes: ['voidbloom-theme']
        },
        NeonVortex: {
          variables: {
            '--vb-primary': '#00c8ff',
            '--vb-primary-rgb': '0, 200, 255',
            '--vb-secondary': '#ff5500',
            '--vb-secondary-rgb': '255, 85, 0'
          },
          classes: ['neonvortex-theme']
        }
      };
      
      if (profiles[profile]) {
        const themeProfile = profiles[profile];
        
        // Apply CSS variables
        for (const [key, value] of Object.entries(themeProfile.variables)) {
          document.documentElement.style.setProperty(key, value);
        }
        
        // Apply classes
        document.body.classList.remove('voidbloom-theme', 'neonvortex-theme');
        themeProfile.classes.forEach(className => {
          document.body.classList.add(className);
        });
        
        // Rebuild particle system with new colors
        this.initParticles();
      }
    }
    
    dispatchReadyEvent() {
      // Notify system that the header is ready
      const event = new CustomEvent('voidbloom-ready', {
        detail: {
          component: 'voidbloom-header',
          neuralId: this.neuralId,
          timestamp: Date.now(),
          features: {
            dimensionalAnchors: this.dimensionalAnchors,
            neuralConnected: this.isNeuralConnected,
            particles: this.particles.length
          }
        }
      });
      
      document.dispatchEvent(event);
    }
  }
  
  // Initialize VoidBloom header when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    window.voidBloomHeader = new VoidBloomHeader();
  });
</script>