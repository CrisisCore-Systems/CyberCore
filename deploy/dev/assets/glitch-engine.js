/**
 * GLITCH-ENGINE.JS
 * Visual glitch effects engine for CyberCore theme
 *
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.5.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

(function (window) {
  'use strict';

  /**
   * Apply Canvas2D optimization for willReadFrequently
   * This patch improves performance when manipulating pixel data by telling
   * the browser to optimize for frequent reads from the canvas
   */
  if (!HTMLCanvasElement.prototype.__willReadFrequentlyPatched) {
    const originalGetContext = HTMLCanvasElement.prototype.getContext;
    HTMLCanvasElement.prototype.getContext = function (type, options) {
      if (type === '2d') {
        return originalGetContext.call(this, type, {
          ...options,
          willReadFrequently: true,
        });
      }
      return originalGetContext.call(this, type, options);
    };
    HTMLCanvasElement.prototype.__willReadFrequentlyPatched = true;
    console.log('Applied Canvas2D willReadFrequently optimization patch');
  }

  /**
   * Create a new GlitchEngine instance
   * @param {Object} options - Configuration options
   */
  function GlitchEngine(options = {}) {
    // Configuration with defaults
    this.config = {
      intensity: options.intensity || 0.5, // Base intensity of glitch effects
      targetSelector: options.targetSelector || '[data-glitch]', // CSS selector for targets
      autoStart: options.autoStart !== undefined ? options.autoStart : false,
      useWebGL: options.useWebGL !== undefined ? options.useWebGL : true,
      fpsLimit: options.fpsLimit || 30, // Performance limit
      glitchMode: options.glitchMode || 'rgb-shift', // Default effect type
      layerCount: options.layerCount || 2, // Number of distortion layers
      glitchTypes: options.glitchTypes || ['rgb-shift', 'noise', 'scanlines', 'jitter'],
      textGlitch: options.textGlitch !== undefined ? options.textGlitch : true,
      neuralSynced: options.neuralSynced !== undefined ? options.neuralSynced : true,
      debug: options.debug || false,
    };

    // State
    this.running = false;
    this.targets = [];
    this.rafId = null;
    this.lastFrameTime = 0;
    this.frameInterval = 1000 / this.config.fpsLimit;
    this.webglSupported = this._checkWebGLSupport();
    this.canvasContexts = new Map();
    this.textNodes = new Map();
    this.originalContent = new Map();
    this.glitchCharacters = '!<>-_\\/[]{}—=+*^?#________';
    this.neuralBusConnected = false;
    this.neuralNonce = null;

    // Initialize
    this._init();

    // Auto-start if configured
    if (this.config.autoStart) {
      this.start();
    }
  }

  // Prototype methods

  /**
   * Initialize the glitch engine
   * @private
   */
  GlitchEngine.prototype._init = function () {
    // Find targets in the DOM
    this._findTargets();

    // Initialize WebGL if supported and enabled
    if (this.config.useWebGL && this.webglSupported) {
      this._initWebGL();
    }

    // Connect to Neural Bus if available
    if (this.config.neuralSynced) {
      this._connectToNeuralBus();
    }

    // Store original content for text glitch
    if (this.config.textGlitch) {
      this._storeOriginalContent();
    }

    // Log debug information
    if (this.config.debug) {
      this._logDebug('GlitchEngine initialized', {
        targets: this.targets.length,
        webGL: this.webglSupported,
        neuralConnected: this.neuralBusConnected,
      });
    }

    // Add resize handler
    window.addEventListener('resize', this._handleResize.bind(this));
  };

  /**
   * Check if WebGL is supported
   * @private
   * @returns {boolean} WebGL support status
   */
  GlitchEngine.prototype._checkWebGLSupport = function () {
    try {
      const canvas = document.createElement('canvas');
      // Try WebGL2 first
      let gl = canvas.getContext('webgl2');

      if (!gl) {
        // Fall back to WebGL1 with optimized parameters
        gl =
          canvas.getContext('webgl', {
            alpha: false,
            antialias: false,
            powerPreference: 'high-performance',
          }) ||
          canvas.getContext('experimental-webgl', {
            alpha: false,
            antialias: false,
            powerPreference: 'high-performance',
          });
      }

      // Check if hardware acceleration is available
      if (gl) {
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL).toLowerCase();
          // Check if we're using a software renderer like SwiftShader
          if (
            renderer.includes('swiftshader') ||
            renderer.includes('software') ||
            renderer.includes('llvmpipe')
          ) {
            console.warn('Hardware acceleration may not be available. Using software renderer.');
            this._showHardwareAccelerationWarning();
          }
        }
      }

      return !!gl;
    } catch (e) {
      return false;
    }
  };

  /**
   * Show hardware acceleration warning to the user
   * @private
   */
  GlitchEngine.prototype._showHardwareAccelerationWarning = function () {
    // Check if warning already exists
    if (document.getElementById('webgl-acceleration-warning')) return;

    const warning = document.createElement('div');
    warning.id = 'webgl-acceleration-warning';
    warning.innerHTML = `
      <div style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                  background: #ffeb3b; color: #333; padding: 15px; border-radius: 8px;
                  z-index: 10000; box-shadow: 0 2px 10px rgba(0,0,0,0.2); max-width: 80%;">
        ⚠️ <strong>Performance Notice:</strong> Please enable hardware acceleration in your browser settings for optimal visual effects.
        <a href="https://enable-webgl.com" target="_blank" style="display: block; margin-top: 8px; color: #0066cc;">
          Learn how to enable WebGL
        </a>
        <button style="position: absolute; top: 5px; right: 5px; background: none; border: none;
                cursor: pointer; font-size: 16px;" onclick="this.parentNode.parentNode.remove()">×</button>
      </div>
    `;
    document.body.appendChild(warning);
  };

  /**
   * Start the glitch animation
   * @param {Object} options - Optional runtime options
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.start = function (options = {}) {
    if (this.running) return this;

    // Apply runtime options
    if (options.intensity !== undefined) {
      this.config.intensity = options.intensity;
    }

    if (options.glitchMode) {
      this.config.glitchMode = options.glitchMode;
    }

    // Start animation loop
    this.running = true;
    this.lastFrameTime = performance.now();
    this._tick();

    // Notify neural bus if connected
    if (this.neuralBusConnected && window.NeuralBus) {
      window.NeuralBus.publish('glitch:started', {
        intensity: this.config.intensity,
        mode: this.config.glitchMode,
        targetCount: this.targets.length,
      });
    }

    return this;
  };

  /**
   * Stop the glitch animation
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.stop = function () {
    if (!this.running) return this;

    // Stop animation loop
    this.running = false;
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }

    // Reset targets to original state
    this._resetTargets();

    // Notify neural bus if connected
    if (this.neuralBusConnected && window.NeuralBus) {
      window.NeuralBus.publish('glitch:stopped', {
        timestamp: Date.now(),
      });
    }

    return this;
  };

  /**
   * Trigger a momentary glitch pulse
   * @param {Object} options - Pulse options
   * @returns {Promise} Resolves when pulse completes
   */
  GlitchEngine.prototype.pulse = function (options = {}) {
    const intensity = options.intensity || 1.0;
    const duration = options.duration || 500;
    const mode = options.mode || this.config.glitchMode;

    // Store original settings
    const originalIntensity = this.config.intensity;
    const originalMode = this.config.glitchMode;
    const wasRunning = this.running;

    // Apply pulse settings
    this.config.intensity = intensity;
    this.config.glitchMode = mode;

    if (!wasRunning) {
      this.start();
    }

    // Create promise to track completion
    return new Promise((resolve) => {
      setTimeout(() => {
        // Restore original settings
        this.config.intensity = originalIntensity;
        this.config.glitchMode = originalMode;

        if (!wasRunning) {
          this.stop();
        }

        resolve();
      }, duration);
    });
  };

  /**
   * Set the glitch intensity
   * @param {number} intensity - New intensity value (0-1)
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.setIntensity = function (intensity) {
    this.config.intensity = Math.max(0, Math.min(1, intensity));
    return this;
  };

  /**
   * Set the glitch mode
   * @param {string} mode - Glitch effect mode
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.setMode = function (mode) {
    if (this.config.glitchTypes.includes(mode)) {
      this.config.glitchMode = mode;
    } else {
      console.warn(`Glitch mode "${mode}" not supported. Using default.`);
      this.config.glitchMode = 'rgb-shift';
    }
    return this;
  };

  /**
   * Add a new target element to the engine
   * @param {HTMLElement} element - Element to add
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.addTarget = function (element) {
    if (element && !this.targets.includes(element)) {
      this.targets.push(element);

      // Store original content for text glitch
      if (this.config.textGlitch && element.textContent) {
        this.originalContent.set(element, element.textContent);
      }

      // Create canvas if using WebGL
      if (this.config.useWebGL && this.webglSupported) {
        this._setupWebGLForElement(element);
      }
    }
    return this;
  };

  /**
   * Remove a target element from the engine
   * @param {HTMLElement} element - Element to remove
   * @returns {GlitchEngine} The engine instance for chaining
   */
  GlitchEngine.prototype.removeTarget = function (element) {
    const index = this.targets.indexOf(element);
    if (index !== -1) {
      this.targets.splice(index, 1);

      // Cleanup canvas if using WebGL
      if (this.canvasContexts.has(element)) {
        const canvas = this.canvasContexts.get(element).canvas;
        if (canvas && canvas.parentNode) {
          canvas.parentNode.removeChild(canvas);
        }
        this.canvasContexts.delete(element);
      }

      // Restore original content
      if (this.originalContent.has(element)) {
        element.textContent = this.originalContent.get(element);
        this.originalContent.delete(element);
      }
    }
    return this;
  };

  /**
   * Main animation tick function
   * @private
   */
  GlitchEngine.prototype._tick = function () {
    if (!this.running) return;

    const now = performance.now();
    const elapsed = now - this.lastFrameTime;

    if (elapsed >= this.frameInterval) {
      // Update last frame time with adjustment to prevent drift
      this.lastFrameTime = now - (elapsed % this.frameInterval);

      // Apply glitch effects
      this._applyGlitchEffects();
    }

    // Schedule next frame
    this.rafId = requestAnimationFrame(this._tick.bind(this));
  };

  /**
   * Apply glitch effects to all targets
   * @private
   */
  GlitchEngine.prototype._applyGlitchEffects = function () {
    // Skip if no intensity
    if (this.config.intensity <= 0) return;

    // Apply different effects based on mode and available features
    if (this.config.useWebGL && this.webglSupported) {
      this._applyWebGLEffects();
    } else if (this.config.textGlitch) {
      this._applyTextGlitch();
    }

    // Apply CSS transform glitches regardless of rendering mode
    this._applyCSSGlitch();
  };

  /**
   * Apply text-based glitch effects
   * @private
   */
  GlitchEngine.prototype._applyTextGlitch = function () {
    this.targets.forEach((target) => {
      if (!this.originalContent.has(target)) return;

      const original = this.originalContent.get(target);

      // Determine if we should glitch this frame based on intensity
      const shouldGlitch = Math.random() < this.config.intensity * 0.2;

      if (shouldGlitch) {
        let glitched = '';

        // Apply character-level glitches
        for (let i = 0; i < original.length; i++) {
          // Random chance to replace character based on intensity
          if (Math.random() < this.config.intensity * 0.3) {
            // Replace with random glitch character
            const glitchChar = this.glitchCharacters.charAt(
              Math.floor(Math.random() * this.glitchCharacters.length)
            );
            glitched += glitchChar;
          } else {
            glitched += original.charAt(i);
          }
        }

        target.textContent = glitched;

        // Schedule reset after short delay for flicker effect
        setTimeout(() => {
          if (this.running && this.targets.includes(target)) {
            target.textContent = original;
          }
        }, Math.random() * 50 + 50);
      }
    });
  };

  /**
   * Apply CSS-based transform glitches
   * @private
   */
  GlitchEngine.prototype._applyCSSGlitch = function () {
    this.targets.forEach((target) => {
      // Skip if target is a canvas (we're already applying WebGL effects)
      if (target.tagName === 'CANVAS') return;

      // Determine if we should glitch this frame based on intensity
      const shouldGlitch = Math.random() < this.config.intensity * 0.15;

      if (shouldGlitch) {
        // Apply random transform based on intensity and mode
        const translateX = (Math.random() - 0.5) * this.config.intensity * 10;
        const translateY = (Math.random() - 0.5) * this.config.intensity * 5;
        const skewX = (Math.random() - 0.5) * this.config.intensity * 5;

        let transform = '';
        let filter = '';

        // Mode-specific effects
        switch (this.config.glitchMode) {
          case 'rgb-shift':
            filter = `hue-rotate(${Math.random() * 360}deg) saturate(${
              1 + this.config.intensity * 5
            })`;
            transform = `translate(${translateX}px, ${translateY}px)`;
            break;
          case 'noise':
            // Noise is primarily handled by WebGL, so just add subtle transform
            transform = `translate(${translateX}px, ${translateY}px)`;
            break;
          case 'scanlines':
            // Scanlines effect is primarily handled by WebGL
            transform = `translateY(${translateY}px)`;
            break;
          case 'jitter':
            transform = `translate(${translateX}px, ${translateY}px) skew(${skewX}deg, 0deg)`;
            break;
          default:
            transform = `translate(${translateX}px, ${translateY}px)`;
        }

        // Apply effects
        target.style.transform = transform;
        if (filter) {
          target.style.filter = filter;
        }

        // Schedule reset after short delay for flicker effect
        setTimeout(() => {
          if (this.running && this.targets.includes(target)) {
            target.style.transform = '';
            if (filter) {
              target.style.filter = '';
            }
          }
        }, Math.random() * 100 + 50);
      }
    });
  };

  /**
   * Initialize WebGL for glitch effects
   * @private
   */
  GlitchEngine.prototype._initWebGL = function () {
    // Initialize WebGL for each target
    this.targets.forEach((target) => {
      this._setupWebGLForElement(target);
    });
  };

  /**
   * Setup WebGL for a specific element
   * @private
   * @param {HTMLElement} element - Target element
   */
  GlitchEngine.prototype._setupWebGLForElement = function (element) {
    // Create a canvas element for the target
    const canvas = document.createElement('canvas');
    const rect = element.getBoundingClientRect();

    // Set canvas size to match element
    canvas.width = rect.width;
    canvas.height = rect.height;

    // Position canvas absolutely to overlay the target
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '1';

    // Create a relative container if needed
    const container = element;
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }

    // Append canvas to container
    element.appendChild(canvas);

    // Initialize WebGL context with optimized settings
    let gl = null;
    try {
      // Try WebGL2 first for better performance
      gl = canvas.getContext('webgl2');

      if (!gl) {
        // Fall back to WebGL1 with optimized parameters
        gl = canvas.getContext('webgl', {
          alpha: false,
          antialias: false,
          powerPreference: 'high-performance',
          preserveDrawingBuffer: false, // Avoid unnecessary buffer preservation
        });

        if (!gl) {
          gl = canvas.getContext('experimental-webgl', {
            alpha: false,
            antialias: false,
            powerPreference: 'high-performance',
            preserveDrawingBuffer: false,
          });
        }
      }
    } catch (e) {
      console.error('Error creating WebGL context:', e);
    }

    if (!gl) {
      console.warn('WebGL not supported in this browser');
      element.removeChild(canvas);
      return;
    }

    // Create shader program
    const program = this._createShaderProgram(gl);

    if (!program) {
      console.warn('Failed to create shader program');
      element.removeChild(canvas);
      return;
    }

    // Setup geometry (a simple quad)
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

    // Quad vertices (two triangles)
    const vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Setup attributes
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Setup uniforms
    const intensityLocation = gl.getUniformLocation(program, 'u_intensity');
    const timeLocation = gl.getUniformLocation(program, 'u_time');
    const rgbShiftLocation = gl.getUniformLocation(program, 'u_rgbShift');
    const noiseLocation = gl.getUniformLocation(program, 'u_noiseAmount');
    const scanlineLocation = gl.getUniformLocation(program, 'u_scanlineAmount');
    const jitterLocation = gl.getUniformLocation(program, 'u_jitter');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

    // Set resolution uniform
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

    // Store context for later use
    this.canvasContexts.set(element, {
      canvas,
      gl,
      program,
      intensityLocation,
      timeLocation,
      rgbShiftLocation,
      noiseLocation,
      scanlineLocation,
      jitterLocation,
      resolutionLocation,
    });
  };

  /**
   * Create WebGL shader program
   * @private
   * @param {WebGLRenderingContext} gl - WebGL context
   * @returns {WebGLProgram} Shader program
   */
  GlitchEngine.prototype._createShaderProgram = function (gl) {
    // Vertex shader source
    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    // Fragment shader source
    const fragmentShaderSource = `
      precision mediump float;

      varying vec2 v_texCoord;

      uniform float u_intensity;
      uniform float u_time;
      uniform vec2 u_resolution;
      uniform float u_rgbShift;
      uniform float u_noiseAmount;
      uniform float u_scanlineAmount;
      uniform vec2 u_jitter;
      uniform sampler2D u_texture; // Texture uniform declaration

      // Proper define for controlling texture usage (fixed syntax)
      #define USE_TEXTURE_EFFECTS 0

      // Pseudo-random function
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }

      // Noise function
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        vec2 u = f * f * (3.0 - 2.0 * f);

        return mix(a, b, u.x) +
              (c - a) * u.y * (1.0 - u.x) +
              (d - b) * u.x * u.y;
      }

      void main() {
        // Apply jitter displacement
        vec2 texCoord = v_texCoord + u_jitter;

        // RGB shift effect
        vec3 color;

        // Base color (when no texture or texture effects disabled)
        color = vec3(0.1, 0.1, 0.12);

        // We completely disable the texture-using code with a compile-time constant
        // until proper texture initialization is implemented
        #if USE_TEXTURE_EFFECTS
          if (u_rgbShift > 0.0) {
            float r = texture2D(u_texture, texCoord + vec2(u_rgbShift * sin(u_time), 0.0)).r;
            float g = texture2D(u_texture, texCoord).g;
            float b = texture2D(u_texture, texCoord - vec2(u_rgbShift * sin(u_time), 0.0)).b;
            color = vec3(r, g, b);
          }
        #endif

        // Apply noise
        if (u_noiseAmount > 0.0) {
          float noiseValue = noise(texCoord * 100.0 + u_time);
          color = mix(color, vec3(noiseValue), u_noiseAmount * u_intensity);
        }

        // Apply scanlines
        if (u_scanlineAmount > 0.0) {
          float scanline = sin(texCoord.y * u_resolution.y * 0.5 - u_time * 10.0) * 0.5 + 0.5;
          color = mix(color, color * scanline, u_scanlineAmount * u_intensity);
        }

        // Random glitch blocks
        if (u_intensity > 0.3) {
          float blockNoise = random(floor(texCoord * 10.0) + floor(u_time * 0.1));
          if (blockNoise > 0.95) {
            texCoord.y = fract(texCoord.y + blockNoise * 0.1);
          }
        }

        // Random vertical glitch lines
        if (u_intensity > 0.5) {
          float lineNoise = random(vec2(floor(u_time * 10.0), floor(texCoord.y * 20.0)));
          if (lineNoise > 0.5) {
            texCoord.x = fract(texCoord.x + lineNoise * 0.1);
          }
        }

        // Output final color with intensity modulation
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Create shaders
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);

    // Check for compilation errors
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));
      gl.deleteShader(vertexShader);
      return null;
    }

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);

    // Check for compilation errors
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }

    // Create program and link shaders
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    // Check for linking errors
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program linking failed:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }

    // Use the program
    gl.useProgram(program);

    return program;
  };

  /**
   * Find all target elements based on selector
   * @private
   */
  GlitchEngine.prototype._findTargets = function () {
    if (typeof this.config.targetSelector === 'string') {
      // Find elements matching selector
      const elements = document.querySelectorAll(this.config.targetSelector);
      this.targets = Array.from(elements);
    } else if (Array.isArray(this.config.targetSelector)) {
      // Use array of elements directly
      this.targets = this.config.targetSelector.filter((el) => el instanceof HTMLElement);
    } else if (this.config.targetSelector instanceof HTMLElement) {
      // Use single element
      this.targets = [this.config.targetSelector];
    }
  };

  /**
   * Store original content of text elements
   * @private
   */
  GlitchEngine.prototype._storeOriginalContent = function () {
    this.targets.forEach((target) => {
      if (target.textContent) {
        this.originalContent.set(target, target.textContent);
      }
    });
  };

  /**
   * Reset targets to original state
   * @private
   */
  GlitchEngine.prototype._resetTargets = function () {
    this.targets.forEach((target) => {
      // Reset CSS properties
      target.style.transform = '';
      target.style.filter = '';

      // Reset text content if modified
      if (this.originalContent.has(target)) {
        target.textContent = this.originalContent.get(target);
      }
    });
  };

  /**
   * Handle window resize events
   * @private
   */
  GlitchEngine.prototype._handleResize = function () {
    // Update WebGL canvases if using WebGL
    if (this.config.useWebGL && this.webglSupported) {
      for (const [element, context] of this.canvasContexts.entries()) {
        const canvas = context.canvas;
        const rect = element.getBoundingClientRect();

        // Update canvas size
        canvas.width = rect.width;
        canvas.height = rect.height;

        // Update GL viewport and uniforms
        const gl = context.gl;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(context.resolutionLocation, canvas.width, canvas.height);
      }
    }
  };

  /**
   * Connect to Neural Bus for event-driven effects
   * @private
   */
  GlitchEngine.prototype._connectToNeuralBus = function () {
    try {
      if (typeof window.NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = window.NeuralBus.register('glitch-engine', {
          version: '2.5.0',
          capabilities: {
            webgl: this.webglSupported,
            textGlitch: this.config.textGlitch,
            modes: this.config.glitchTypes,
          },
        });

        this.neuralBusConnected = true;
        this.neuralNonce = registration.nonce;

        // Subscribe to relevant events
        window.NeuralBus.subscribe('glitch:trigger', this._handleGlitchTrigger.bind(this));
        window.NeuralBus.subscribe('quantum:mutation', this._handleQuantumMutation.bind(this));
        window.NeuralBus.subscribe('theme:changed', this._handleThemeChange.bind(this));

        if (this.config.debug) {
          this._logDebug('Connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
      this.neuralBusConnected = false;
    }
  };

  /**
   * Handle glitch trigger events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  GlitchEngine.prototype._handleGlitchTrigger = function (data) {
    // Handle immediate glitch pulse request
    if (data && typeof data === 'object') {
      this.pulse({
        intensity: data.intensity || 1.0,
        duration: data.duration || 500,
        mode: data.mode || this.config.glitchMode,
      });
    }
  };

  /**
   * Handle quantum mutation events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  GlitchEngine.prototype._handleQuantumMutation = function (data) {
    if (data && data.profile) {
      // Adjust glitch properties based on mutation profile
      switch (data.profile) {
        case 'CyberLotus':
          this.setMode('rgb-shift');
          break;
        case 'ObsidianBloom':
          this.setMode('noise');
          break;
        case 'VoidBloom':
          this.setMode('jitter');
          break;
        case 'NeonVortex':
          this.setMode('scanlines');
          break;
      }

      // Apply a pulse effect to visualize the change
      this.pulse({
        intensity: 0.8,
        duration: 800,
      });
    }
  };

  /**
   * Handle theme change events from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  GlitchEngine.prototype._handleThemeChange = function (data) {
    if (data && data.glitchIntensity !== undefined) {
      this.setIntensity(data.glitchIntensity);
    }

    if (data && data.glitchMode) {
      this.setMode(data.glitchMode);
    }
  };

  /**
   * Log debug information
   * @private
   * @param {string} message - Debug message
   * @param {Object} data - Additional data to log
   */
  GlitchEngine.prototype._logDebug = function (message, data) {
    if (!this.config.debug) return;

    console.log(`[GlitchEngine] ${message}`, data || '');
  };

  // Expose to global scope for browser usage
  window.GlitchEngine = GlitchEngine;

  // Auto-initialize when loaded if in browser environment with auto elements
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', () => {
      // Auto-init for any elements with data-glitch-auto attribute
      const autoElements = document.querySelectorAll('[data-glitch-auto]');

      if (autoElements.length > 0) {
        const engine = new GlitchEngine({
          targetSelector: '[data-glitch-auto]',
          autoStart: true,
          intensity: 0.3,
        });

        // Expose instance to global scope for debugging
        window.__glitchEngine = engine;
      }
    });
  }
})(typeof window !== 'undefined' ? window : this);
