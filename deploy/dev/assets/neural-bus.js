/**
 * NEURAL-BUS.JS
 * Neural communication bus for component interaction
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 3.1.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

/**
 * NeuralBus
 * Central event bus system for component communication using a pub/sub pattern with 
 * enhanced encryption and quantum handshakes.
 * 
 * Key Features:
 * - Secure handshaking using crypto APIs
 * - Component registration and discovery
 * - Event logging for debugging
 * - DOM mutation capabilities
 */
export class NeuralBus {
  // Private static properties
  static #components = new Map();
  static #eventSubscriptions = new Map();
  static #securityKeys = new Map();
  static #debugMode = false;
  static #initialized = false;
  static #version = '3.1.0';
  static #nonceRegistry = new Map();
  static #entangled = false;
  
  /**
   * Initialize the Neural Bus
   * @param {Object} options - Configuration options
   */
  static initialize(options = {}) {
    if (this.#initialized) return;
    
    this.#debugMode = options.debug || false;
    
    // Initialize security
    this.#initializeSecurity();
    
    // Register with the Quantum Layer if available
    this.#registerWithQuantumLayer();
    
    this.#initialized = true;
    this.#log('NeuralBus initialized', 'version', this.#version);
    
    // Dispatch initialization event
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('neuralbus:initialized', {
        detail: { version: this.#version }
      }));
    }
    
    return this;
  }

  /**
   * Initialize security system for the Neural Bus
   * @private
   */
  static #initializeSecurity() {
    // Use crypto API if available
    if (window.crypto && window.crypto.subtle) {
      try {
        this.#log('Initializing NeuralBus encryption');
        
        // Create a base entropy pool for the session
        const entropyArray = new Uint32Array(16);
        window.crypto.getRandomValues(entropyArray);
        
        // Store for future handshakes
        this.#securityKeys.set('entropy', entropyArray);
        this.#entangled = true;
      } catch (error) {
        this.#log('Encryption initialization failed', error);
        this.#entangled = false;
      }
    } else {
      this.#log('Advanced encryption not available in this environment');
      this.#entangled = false;
    }
  }
  
  /**
   * Register the Neural Bus with the Quantum Layer if available
   * @private
   */
  static #registerWithQuantumLayer() {
    if (typeof window !== 'undefined' && window.QuantumLayer) {
      try {
        window.QuantumLayer.register('neural-bus', {
          id: 'neural-bus',
          version: this.#version,
          entangled: this.#entangled
        });
        
        this.#log('Registered with Quantum Layer');
      } catch (error) {
        this.#log('Failed to register with Quantum Layer', error);
      }
    }
  }
  
  /**
   * Register a component in the Neural Bus
   * @param {string} id - Unique component identifier
   * @param {Object} component - Component instance or configuration
   * @returns {Object} Nonce for secure operations
   */
  static register(id, component) {
    if (!id || this.#components.has(id)) {
      throw new Error(`Component ID must be unique: ${id}`);
    }
    
    // Create security nonce for this component
    const nonce = this.#generateNonce();
    this.#nonceRegistry.set(id, nonce);
    
    // Store component reference
    this.#components.set(id, {
      id,
      component,
      registered: Date.now(),
      nonce
    });
    
    this.#log(`Component registered: ${id}`);
    
    // Return the nonce for secure operations
    return { nonce };
  }
  
  /**
   * Generate a secure nonce for component authentication
   * @private
   * @returns {string} Unique nonce
   */
  static #generateNonce() {
    let nonce;
    
    // Use crypto if available
    if (window.crypto && window.crypto.getRandomValues) {
      const array = new Uint32Array(4);
      window.crypto.getRandomValues(array);
      nonce = Array.from(array).map(n => n.toString(16)).join('');
    } else {
      // Fallback for environments without crypto
      nonce = Math.random().toString(36).substring(2, 15) + 
              Math.random().toString(36).substring(2, 15);
    }
    
    return nonce;
  }
  
  /**
   * Check if a component is registered
   * @param {string} id - Component identifier
   * @returns {boolean} True if component is registered
   */
  static isRegistered(id) {
    return this.#components.has(id);
  }
  
  /**
   * Deregister a component from the Neural Bus
   * @param {string} id - Component identifier
   * @param {string} nonce - Security nonce
   */
  static deregister(id, nonce) {
    // Validate nonce for security
    if (!this.#validateNonce(id, nonce)) {
      throw new Error('Invalid security nonce');
    }
    
    if (this.#components.has(id)) {
      // Remove any subscriptions for this component
      for (const [event, subscribers] of this.#eventSubscriptions.entries()) {
        this.#eventSubscriptions.set(
          event,
          subscribers.filter(sub => sub.id !== id)
        );
        
        // Clean up empty subscription lists
        if (this.#eventSubscriptions.get(event).length === 0) {
          this.#eventSubscriptions.delete(event);
        }
      }
      
      // Remove component
      this.#components.delete(id);
      this.#nonceRegistry.delete(id);
      
      this.#log(`Component deregistered: ${id}`);
    }
  }
  
  /**
   * Validate a security nonce for a component
   * @private
   * @param {string} id - Component identifier
   * @param {string} nonce - Security nonce to validate
   * @returns {boolean} True if valid
   */
  static #validateNonce(id, nonce) {
    // Skip validation in non-production
    if (this.#debugMode) return true;
    
    return this.#nonceRegistry.get(id) === nonce;
  }
  
  /**
   * Subscribe to an event
   * @param {string} event - Event name to subscribe to
   * @param {Function} callback - Function to call when event is triggered
   * @param {Object} options - Subscription options
   * @returns {Object} Subscription object with unsubscribe method
   */
  static subscribe(event, callback, options = {}) {
    if (!this.#initialized) this.initialize();
    
    // Get or create subscription array for this event
    if (!this.#eventSubscriptions.has(event)) {
      this.#eventSubscriptions.set(event, []);
    }
    
    const id = options.id || `sub_${Math.random().toString(36).substring(2, 9)}`;
    
    // Add to subscriptions
    this.#eventSubscriptions.get(event).push({
      id,
      callback,
      options
    });
    
    this.#log(`Subscribed to ${event}`, id);
    
    // Return unsubscribe function
    return {
      id,
      unsubscribe: () => this.unsubscribe(event, id)
    };
  }
  
  /**
   * Unsubscribe from an event
   * @param {string} event - Event name
   * @param {string} id - Subscription identifier
   */
  static unsubscribe(event, id) {
    if (!this.#eventSubscriptions.has(event)) return;
    
    const subscriptions = this.#eventSubscriptions.get(event);
    const updatedSubscriptions = subscriptions.filter(sub => sub.id !== id);
    
    // Update subscriptions
    if (updatedSubscriptions.length === 0) {
      this.#eventSubscriptions.delete(event);
    } else {
      this.#eventSubscriptions.set(event, updatedSubscriptions);
    }
    
    this.#log(`Unsubscribed from ${event}`, id);
  }
  
  /**
   * Publish an event to subscribers
   * @param {string} event - Event name
   * @param {*} data - Event data
   * @param {Object} options - Publishing options
   * @returns {number} Number of subscribers notified
   */
  static publish(event, data, options = {}) {
    if (!this.#initialized) this.initialize();
    
    // Skip if no subscribers
    if (!this.#eventSubscriptions.has(event)) {
      this.#log(`Event published with no subscribers: ${event}`);
      return 0;
    }
    
    const subscribers = this.#eventSubscriptions.get(event);
    const timestamp = Date.now();
    const eventObj = {
      event,
      data,
      timestamp,
      sender: options.sender || 'anonymous'
    };
    
    // Notify each subscriber
    let notified = 0;
    subscribers.forEach(subscriber => {
      try {
        subscriber.callback(data, eventObj);
        notified++;
      } catch (error) {
        this.#log(`Error in subscriber callback for ${event}`, error);
      }
    });
    
    this.#log(`Published ${event} to ${notified} subscribers`);
    
    // Dispatch DOM event for external listeners
    if (typeof window !== 'undefined') {
      const domEvent = new CustomEvent(`neuralbus:${event}`, {
        detail: eventObj,
        bubbles: options.bubble || false
      });
      
      window.dispatchEvent(domEvent);
    }
    
    return notified;
  }
  
  /**
   * Apply a quantum mutation to a DOM element
   * @param {HTMLElement} element - Element to mutate
   * @param {Object} mutation - Mutation details
   * @returns {boolean} Success status
   */
  static applyMutation(element, mutation) {
    if (!element || !(element instanceof HTMLElement)) {
      this.#log('Invalid element for mutation');
      return false;
    }
    
    try {
      // Handle style mutations
      if (mutation.style) {
        Object.entries(mutation.style).forEach(([property, value]) => {
          element.style[property] = value;
        });
      }
      
      // Handle attribute mutations
      if (mutation.attributes) {
        Object.entries(mutation.attributes).forEach(([attr, value]) => {
          if (value === null) {
            element.removeAttribute(attr);
          } else {
            element.setAttribute(attr, value);
          }
        });
      }
      
      // Handle class mutations
      if (mutation.classList) {
        if (mutation.classList.add) {
          element.classList.add(...mutation.classList.add);
        }
        if (mutation.classList.remove) {
          element.classList.remove(...mutation.classList.remove);
        }
        if (mutation.classList.toggle) {
          mutation.classList.toggle.forEach(cls => {
            element.classList.toggle(cls);
          });
        }
      }
      
      // Handle content mutations
      if (mutation.content !== undefined) {
        element.textContent = mutation.content;
      }
      
      // Handle HTML mutations
      if (mutation.html !== undefined) {
        element.innerHTML = mutation.html;
      }
      
      this.#log('Mutation applied successfully');
      
      // Publish mutation event
      this.publish('element:mutated', {
        element,
        mutation,
        timestamp: Date.now()
      });
      
      return true;
    } catch (error) {
      this.#log('Mutation application failed', error);
      return false;
    }
  }
  
  /**
   * Query the DOM for elements and apply mutations
   * @param {string} selector - CSS selector
   * @param {Object} mutation - Mutation details
   * @returns {number} Number of elements mutated
   */
  static queryAndMutate(selector, mutation) {
    if (!selector || typeof selector !== 'string') {
      this.#log('Invalid selector for queryAndMutate');
      return 0;
    }
    
    try {
      const elements = document.querySelectorAll(selector);
      let mutated = 0;
      
      elements.forEach(element => {
        if (this.applyMutation(element, mutation)) {
          mutated++;
        }
      });
      
      this.#log(`Mutated ${mutated} elements matching "${selector}"`);
      return mutated;
    } catch (error) {
      this.#log('Query and mutate operation failed', error);
      return 0;
    }
  }
  
  /**
   * Get information about registered components
   * @returns {Array} Array of component information
   */
  static getRegisteredComponents() {
    const componentInfo = [];
    
    for (const [id, data] of this.#components.entries()) {
      componentInfo.push({
        id,
        registered: data.registered
      });
    }
    
    return componentInfo;
  }
  
  /**
   * Get information about event subscriptions
   * @returns {Object} Map of events and subscriber counts
   */
  static getSubscriptionInfo() {
    const subscriptionInfo = {};
    
    for (const [event, subscribers] of this.#eventSubscriptions.entries()) {
      subscriptionInfo[event] = subscribers.length;
    }
    
    return subscriptionInfo;
  }
  
  /**
   * Check if Neural Bus is in debug mode
   * @returns {boolean} Debug mode state
   */
  static isDebugMode() {
    return this.#debugMode;
  }
  
  /**
   * Set debug mode state
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  static setDebugMode(enabled) {
    this.#debugMode = !!enabled;
    this.#log(`Debug mode ${this.#debugMode ? 'enabled' : 'disabled'}`);
  }
  
  /**
   * Log debug messages when debug mode is enabled
   * @private
   * @param {string} message - Message to log
   * @param {...any} args - Additional arguments to log
   */
  static #log(message, ...args) {
    if (!this.#debugMode) return;
    
    console.log(`[NeuralBus] ${message}`, ...args);
  }
  
  /**
   * Get version information
   * @returns {string} Version string
   */
  static getVersion() {
    return this.#version;
  }
  
  /**
   * Check if the bus is securely entangled
   * @returns {boolean} Entanglement status
   */
  static isEntangled() {
    return this.#entangled;
  }
}

// Auto-initialize when loaded if in browser environment
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    NeuralBus.initialize({ debug: window.location.search.includes('debug=true') });
    
    // Expose to global scope for debugging and external access
    window.NeuralBus = NeuralBus;
  });
}