/**
 * CART-SYSTEM.JS
 * Advanced cart functionality for CyberCore theme
 * 
 * @MutationCompatible: All Variants
 * @StrategyProfile: quantum-entangled
 * @Version: 2.2.0
 */
// Generated by CyberCore Neural Forge v3.0.0 //

import { NeuralBus } from './neural-bus.js';

/**
 * CartSystem
 * Advanced cart management system with quantum effects and 3D previews
 * 
 * Key Features:
 * - AJAX cart updates without page refresh
 * - Cart drawer with animations
 * - Quantity adjustments and validations
 * - Cross-sell recommendations
 * - 3D product previews (when supported)
 * - Integration with NeuralBus events
 */
export class CartSystem {
  // Private static properties
  static #config = {
    cartDrawerSelector: '#cart-drawer',
    cartIconSelector: '#cart-icon-bubble',
    cartCountSelector: '#cart-count',
    cartTotalSelector: '#cart-total',
    addToCartFormSelector: 'form[action="/cart/add"]',
    cartItemSelector: '.cart-item',
    cartItemRemoveSelector: '.cart-item__remove',
    cartItemQuantitySelector: '.cart-item__quantity-input',
    cartDrawerToggleSelector: '[data-cart-toggle]',
    cartEmptyMessageSelector: '.cart-empty-message',
    cartErrorSelector: '.cart-error',
    cartRecommendationsSelector: '.cart-recommendations',
    cartCheckoutButtonSelector: '#cart-checkout-button',
    continueShoppingSelector: '#continue-shopping',
    cartPreviewContainerSelector: '#cart-preview-container',
    neuralSynced: true,
    useQuantumEffects: true,
    useHolographicPreviews: true, // Enabled since we now have the renderer
    debug: false,
    apiEndpoints: {
      cartAdd: '/cart/add.js',
      cartUpdate: '/cart/update.js',
      cartChange: '/cart/change.js',
      cartGet: '/cart.js',
      cartClear: '/cart/clear.js'
    }
  };
  
  static #instance = null;
  static #eventHandlersAttached = false;
  static #isOpen = false;
  static #cartData = null;
  static #neuralBusConnected = false;
  static #neuralNonce = null;
  static #lastRequestTimestamp = 0;
  static #requestThrottleMs = 500;
  static #pendingRequests = [];
  static #holographicPreviewsSupported = false;
  static #holographicRenderer = null;
  static #activeProduct = null;
  static #productMutationRegistry = new Map();
  
  /**
   * Initialize the cart system
   * @param {Object} options - Configuration options
   * @returns {CartSystem} Cart system instance
   */
  static initialize(options = {}) {
    // Only initialize once
    if (this.#instance) return this.#instance;
    
    // Merge options with defaults
    this.#config = { ...this.#config, ...options };
    
    // Check for holographic preview support
    this.#checkHolographicSupport();
    
    // Attach event listeners
    this.#attachEventHandlers();
    
    // Initial cart fetch
    this.#fetchCart();
    
    // Connect to Neural Bus if available
    if (this.#config.neuralSynced) {
      this.#connectToNeuralBus();
    }
    
    // Log initialization
    if (this.#config.debug) {
      console.log('[CartSystem] Initialized with config:', this.#config);
    }
    
    this.#instance = this;
    return this.#instance;
  }
  
  /**
   * Get cart data
   * @returns {Promise<Object>} Cart data
   */
  static async getCart() {
    if (!this.#cartData) {
      await this.#fetchCart();
    }
    return this.#cartData;
  }
  
  /**
   * Add an item to the cart
   * @param {number|string} variantId - Product variant ID
   * @param {number} quantity - Quantity to add
   * @param {Object} properties - Line item properties
   * @returns {Promise<Object>} Updated cart
   */
  static async addToCart(variantId, quantity = 1, properties = {}) {
    try {
      this.#showLoading();
      
      const data = {
        id: variantId,
        quantity: quantity
      };
      
      // Add properties if provided
      if (Object.keys(properties).length > 0) {
        data.properties = properties;
      }
      
      // Send to Shopify API
      const response = await this.#postToShopify(this.#config.apiEndpoints.cartAdd, data);
      
      // Trigger quantum effect if enabled
      if (this.#config.useQuantumEffects) {
        this.#triggerQuantumEffect('add', variantId);
      }
      
      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('item:added', { 
        item: response, 
        cartData: this.#cartData 
      });
      
      // Sync with NeuralBus
      this.#handleCartItemAdded({ item: response });
      
      // Show drawer
      this.openCartDrawer();
      
      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }
  
  /**
   * Update cart item quantity
   * @param {string} key - Cart item key
   * @param {number} quantity - New quantity
   * @returns {Promise<Object>} Updated cart
   */
  static async updateItemQuantity(key, quantity) {
    try {
      this.#showLoading();
      
      // Send to Shopify API
      const data = {
        id: key,
        quantity: quantity
      };
      
      await this.#postToShopify(this.#config.apiEndpoints.cartChange, data);
      
      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('item:updated', { 
        key: key, 
        quantity: quantity,
        cartData: this.#cartData
      });
      
      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }
  
  /**
   * Remove an item from the cart
   * @param {string} key - Cart item key
   * @returns {Promise<Object>} Updated cart
   */
  static async removeItem(key) {
    return this.updateItemQuantity(key, 0);
  }
  
  /**
   * Clear the cart
   * @returns {Promise<Object>} Empty cart
   */
  static async clearCart() {
    try {
      this.#showLoading();
      
      // Send to Shopify API
      await fetch(this.#config.apiEndpoints.cartClear, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      // Update cart and notify listeners
      await this.#fetchCart();
      this.#updateCartUI();
      this.#triggerEvent('cart:cleared', { cartData: this.#cartData });
      
      return this.#cartData;
    } catch (error) {
      this.#handleError(error);
      throw error;
    } finally {
      this.#hideLoading();
    }
  }
  
  /**
   * Open the cart drawer
   */
  static openCartDrawer() {
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!drawer) return;
    
    // Add open class to drawer
    drawer.classList.add('open');
    
    // Set body class for locking scroll
    document.body.classList.add('cart-drawer-open');
    
    // Update state
    this.#isOpen = true;
    
    // Trigger event
    this.#triggerEvent('drawer:opened', {});
    
    // Set up holographic preview if enabled and supported
    if (this.#config.useHolographicPreviews && this.#holographicPreviewsSupported) {
      this.#initHolographicPreviews();
    }
    
    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('drawer', 'open');
    }
  }
  
  /**
   * Close the cart drawer
   */
  static closeCartDrawer() {
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!drawer) return;
    
    // Remove open class from drawer
    drawer.classList.remove('open');
    
    // Remove body class for unlocking scroll
    document.body.classList.remove('cart-drawer-open');
    
    // Update state
    this.#isOpen = false;
    
    // Trigger event
    this.#triggerEvent('drawer:closed', {});
    
    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('drawer', 'close');
    }
  }
  
  /**
   * Toggle the cart drawer
   */
  static toggleCartDrawer() {
    if (this.#isOpen) {
      this.closeCartDrawer();
    } else {
      this.openCartDrawer();
    }
  }
  
  /**
   * Set active product for preview
   * @param {Object} product - Product data
   */
  static setActiveProduct(product) {
    this.#activeProduct = product;
    
    // Update holographic preview if enabled and drawer is open
    if (this.#config.useHolographicPreviews && 
        this.#holographicPreviewsSupported && 
        this.#isOpen) {
      this.#updateHolographicPreview(product);
    }
  }
  
  /**
   * Check if cart drawer is open
   * @returns {boolean} Is drawer open
   */
  static isCartDrawerOpen() {
    return this.#isOpen;
  }
  
  /**
   * Attach event handlers to cart elements
   * @private
   */
  static #attachEventHandlers() {
    if (this.#eventHandlersAttached) return;
    
    document.addEventListener('DOMContentLoaded', () => {
      // Toggle cart drawer
      const toggleButtons = document.querySelectorAll(this.#config.cartDrawerToggleSelector);
      toggleButtons.forEach(button => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          this.toggleCartDrawer();
        });
      });
      
      // Continue shopping button
      const continueButton = document.querySelector(this.#config.continueShoppingSelector);
      if (continueButton) {
        continueButton.addEventListener('click', (event) => {
          event.preventDefault();
          this.closeCartDrawer();
        });
      });
      
      // Add to cart forms
      const addToCartForms = document.querySelectorAll(this.#config.addToCartFormSelector);
      addToCartForms.forEach(form => {
        form.addEventListener('submit', this.#handleFormSubmit.bind(this));
      });
      
      // Document click to close drawer
      document.addEventListener('click', (event) => {
        if (this.#isOpen && 
            !event.target.closest(this.#config.cartDrawerSelector) && 
            !event.target.closest(this.#config.cartDrawerToggleSelector)) {
          this.closeCartDrawer();
        }
      });
      
      // Escape key to close drawer
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && this.#isOpen) {
          this.closeCartDrawer();
        }
      });
      
      // Attach delegated event handlers for dynamic cart content
      document.addEventListener('click', (event) => {
        // Remove item buttons
        if (event.target.closest(this.#config.cartItemRemoveSelector)) {
          event.preventDefault();
          const itemEl = event.target.closest(this.#config.cartItemSelector);
          const key = itemEl?.dataset.key;
          if (key) {
            this.removeItem(key);
          }
        }
      });
      
      // Quantity input change events
      document.addEventListener('change', (event) => {
        if (event.target.matches(this.#config.cartItemQuantitySelector)) {
          const itemEl = event.target.closest(this.#config.cartItemSelector);
          const key = itemEl?.dataset.key;
          const quantity = parseInt(event.target.value, 10);
          
          if (key && !isNaN(quantity)) {
            this.updateItemQuantity(key, quantity);
          }
        }
      });
      
      // Mark event handlers as attached
      this.#eventHandlersAttached = true;
      
      // Initial UI update
      this.#updateCartUI();
    });
  }
  
  /**
   * Handle form submission for add to cart
   * @private
   * @param {Event} event - Form submit event
   */
  static #handleFormSubmit(event) {
    event.preventDefault();
    
    const form = event.target;
    const formData = new FormData(form);
    
    // Extract form data
    const variantId = formData.get('id');
    const quantity = parseInt(formData.get('quantity') || 1, 10);
    
    // Extract properties from form
    const properties = {};
    for (const [key, value] of formData.entries()) {
      if (key.startsWith('properties[') && key.endsWith(']')) {
        const propName = key.slice(11, -1); // Extract property name from properties[name]
        properties[propName] = value;
      }
    }
    
    // Add to cart
    this.addToCart(variantId, quantity, properties)
      .catch(error => {
        console.error('Add to cart failed:', error);
      });
  }
  
  /**
   * Fetch current cart data from Shopify
   * @private
   * @returns {Promise<Object>} Cart data
   */
  static async #fetchCart() {
    try {
      const response = await fetch(this.#config.apiEndpoints.cartGet, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Cart fetch failed: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      this.#cartData = data;
      
      return data;
    } catch (error) {
      console.error('Error fetching cart:', error);
      throw error;
    }
  }
  
  /**
   * Post data to Shopify API
   * @private
   * @param {string} endpoint - API endpoint
   * @param {Object} data - Request data
   * @returns {Promise<Object>} Response data
   */
  static async #postToShopify(endpoint, data) {
    // Throttle requests to prevent API rate limiting
    const now = Date.now();
    if (now - this.#lastRequestTimestamp < this.#requestThrottleMs) {
      // Queue the request
      return new Promise((resolve, reject) => {
        this.#pendingRequests.push({ endpoint, data, resolve, reject });
        
        // Process queue after throttle time
        setTimeout(() => {
          this.#processRequestQueue();
        }, this.#requestThrottleMs);
      });
    }
    
    this.#lastRequestTimestamp = now;
    
    // Execute the request
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error(`Request failed: ${response.status} ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error(`Error posting to ${endpoint}:`, error);
      throw error;
    }
  }
  
  /**
   * Process the queue of pending requests
   * @private
   */
  static #processRequestQueue() {
    if (this.#pendingRequests.length === 0) return;
    
    // Get the next request
    const { endpoint, data, resolve, reject } = this.#pendingRequests.shift();
    
    // Update timestamp
    this.#lastRequestTimestamp = Date.now();
    
    // Execute the request
    this.#postToShopify(endpoint, data)
      .then(resolve)
      .catch(reject)
      .finally(() => {
        // Schedule processing of next request
        if (this.#pendingRequests.length > 0) {
          setTimeout(() => {
            this.#processRequestQueue();
          }, this.#requestThrottleMs);
        }
      });
  }
  
  /**
   * Update the cart UI
   * @private
   */
  static #updateCartUI() {
    if (!this.#cartData) return;
    
    // Update cart count
    const cartCountEl = document.querySelector(this.#config.cartCountSelector);
    if (cartCountEl) {
      cartCountEl.textContent = this.#cartData.item_count;
      
      // Toggle visibility based on item count
      if (this.#cartData.item_count > 0) {
        cartCountEl.classList.remove('hidden');
      } else {
        cartCountEl.classList.add('hidden');
      }
    }
    
    // Update cart total
    const cartTotalEl = document.querySelector(this.#config.cartTotalSelector);
    if (cartTotalEl) {
      // Format price with currency
      const formattedPrice = this.#formatMoney(this.#cartData.total_price);
      cartTotalEl.textContent = formattedPrice;
    }
    
    // Toggle empty cart message
    const emptyMessageEl = document.querySelector(this.#config.cartEmptyMessageSelector);
    if (emptyMessageEl) {
      if (this.#cartData.item_count === 0) {
        emptyMessageEl.classList.remove('hidden');
      } else {
        emptyMessageEl.classList.add('hidden');
      }
    }
    
    // Update cart items
    this.#renderCartItems();
    
    // Update recommendations if any
    this.#updateRecommendations();
  }
  
  /**
   * Render cart items
   * @private
   */
  static #renderCartItems() {
    const cartItemContainer = document.querySelector('#cart-items');
    if (!cartItemContainer || !this.#cartData) return;
    
    // Clear existing items
    cartItemContainer.innerHTML = '';
    
    // Render each item
    this.#cartData.items.forEach(item => {
      const itemElement = document.createElement('div');
      itemElement.className = 'cart-item';
      itemElement.dataset.key = item.key;
      
      // Escape special characters in HTML to prevent XSS
      const escapedTitle = this.#escapeHTML(item.title);
      const escapedVariantTitle = this.#escapeHTML(item.variant_title || '');
      const formattedPrice = this.#formatMoney(item.final_line_price);
      
      itemElement.innerHTML = `
        <div class="cart-item__image">
          <img src="${item.image || '/assets/no-image.jpg'}" alt="${escapedTitle}">
        </div>
        <div class="cart-item__content">
          <div class="cart-item__title">${escapedTitle}</div>
          ${escapedVariantTitle ? `<div class="cart-item__variant">${escapedVariantTitle}</div>` : ''}
          <div class="cart-item__price">${formattedPrice}</div>
          <div class="cart-item__quantity">
            <label for="quantity-${item.key}">Qty:</label>
            <input 
              type="number" 
              id="quantity-${item.key}" 
              class="cart-item__quantity-input" 
              value="${item.quantity}" 
              min="1" 
              data-item-key="${item.key}"
            >
          </div>
        </div>
        <button class="cart-item__remove" aria-label="Remove item">×</button>
      `;
      
      cartItemContainer.appendChild(itemElement);
      
      // Apply quantum effects if enabled
      if (this.#config.useQuantumEffects) {
        this.#applyItemQuantumEffect(itemElement);
      }
    });
  }
  
  /**
   * Update product recommendations
   * @private
   */
  static #updateRecommendations() {
    const recommendationsContainer = document.querySelector(this.#config.cartRecommendationsSelector);
    if (!recommendationsContainer || !this.#cartData || this.#cartData.item_count === 0) {
      return;
    }
    
    // TODO: Implement product recommendations logic
    // This would typically make an API call to Shopify's recommendations endpoint
    // For now, let's just clear the container
    recommendationsContainer.innerHTML = '';
  }
  
  /**
   * Format money value
   * @private
   * @param {number} cents - Price in cents
   * @returns {string} Formatted price
   */
  static #formatMoney(cents) {
    if (typeof Shopify !== 'undefined' && Shopify.formatMoney) {
      return Shopify.formatMoney(cents);
    }
    
    // Fallback formatter if Shopify's isn't available
    const dollars = cents / 100;
    return '$' + dollars.toFixed(2);
  }
  
  /**
   * Escape HTML special characters
   * @private
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  static #escapeHTML(str) {
    if (!str) return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  
  /**
   * Show loading indicator
   * @private
   */
  static #showLoading() {
    document.body.classList.add('cart-loading');
    
    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('loading', 'start');
    }
  }
  
  /**
   * Hide loading indicator
   * @private
   */
  static #hideLoading() {
    document.body.classList.remove('cart-loading');
    
    // Apply quantum effect if enabled
    if (this.#config.useQuantumEffects) {
      this.#triggerQuantumEffect('loading', 'end');
    }
  }
  
  /**
   * Handle errors
   * @private
   * @param {Error} error - Error object
   */
  static #handleError(error) {
    console.error('Cart error:', error);
    
    // Display error message
    const errorEl = document.querySelector(this.#config.cartErrorSelector);
    if (errorEl) {
      errorEl.textContent = error.message || 'An error occurred';
      errorEl.classList.remove('hidden');
      
      // Hide after a delay
      setTimeout(() => {
        errorEl.classList.add('hidden');
      }, 5000);
    }
    
    // Notify Neural Bus
    if (this.#neuralBusConnected) {
      NeuralBus.publish('cart:error', {
        message: error.message,
        stack: error.stack,
        timestamp: Date.now()
      });
    }
  }
  
  /**
   * Trigger custom event
   * @private
   * @param {string} name - Event name
   * @param {Object} detail - Event details
   */
  static #triggerEvent(name, detail = {}) {
    // DOM event
    document.dispatchEvent(new CustomEvent(`cart:${name}`, { 
      detail,
      bubbles: true 
    }));
    
    // Neural Bus event
    if (this.#neuralBusConnected) {
      NeuralBus.publish(`cart:${name}`, detail);
    }
    
    // Log if debug enabled
    if (this.#config.debug) {
      console.log(`[CartSystem] Event: cart:${name}`, detail);
    }
  }
  
  /**
   * Connect to Neural Bus
   * @private
   */
  static #connectToNeuralBus() {
    try {
      if (typeof NeuralBus !== 'undefined') {
        // Register with Neural Bus
        const registration = NeuralBus.register('cart-system', {
          version: '2.2.0',
          capabilities: {
            quantumEffects: this.#config.useQuantumEffects,
            holographicPreviews: this.#holographicPreviewsSupported
          }
        });
        
        this.#neuralBusConnected = true;
        this.#neuralNonce = registration.nonce;
        
        // Subscribe to relevant events
        NeuralBus.subscribe('cart:refresh', this.#handleCartRefresh.bind(this));
        NeuralBus.subscribe('product:view', this.#handleProductView.bind(this));
        NeuralBus.subscribe('quantum:mutation', this.#handleQuantumMutation.bind(this));
        
        if (this.#config.debug) {
          console.log('[CartSystem] Connected to Neural Bus');
        }
      }
    } catch (error) {
      console.warn('Failed to connect to Neural Bus:', error);
      this.#neuralBusConnected = false;
    }
  }
  
  /**
   * Handle cart refresh event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleCartRefresh(data) {
    this.#fetchCart().then(() => {
      this.#updateCartUI();
    });
  }
  
  /**
   * Handle product view event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleProductView(data) {
    if (data && data.product) {
      this.setActiveProduct(data.product);
    }
  }
  
  /**
   * Handle quantum mutation event from Neural Bus
   * @private
   * @param {Object} data - Event data
   */
  static #handleQuantumMutation(data) {
    if (data && data.target === 'cart') {
      // Adapt cart UI based on mutation profile
      this.#applyMutationProfile(data.profile);
    }
  }
  
  /**
   * Apply mutation profile to cart UI
   * @private
   * @param {string} profile - Mutation profile name
   */
  static #applyMutationProfile(profile) {
    const cartDrawer = document.querySelector(this.#config.cartDrawerSelector);
    if (!cartDrawer) return;
    
    // Remove all profile classes
    cartDrawer.classList.remove(
      'profile-cyberlotus',
      'profile-obsidianbloom',
      'profile-voidbloom',
      'profile-neonvortex'
    );
    
    // Add the new profile class
    switch (profile) {
      case 'CyberLotus':
        cartDrawer.classList.add('profile-cyberlotus');
        break;
      case 'ObsidianBloom':
        cartDrawer.classList.add('profile-obsidianbloom');
        break;
      case 'VoidBloom':
        cartDrawer.classList.add('profile-voidbloom');
        break;
      case 'NeonVortex':
        cartDrawer.classList.add('profile-neonvortex');
        break;
    }
    
    // Apply a subtle effect to visualize the change
    this.#triggerQuantumEffect('mutation', profile);
  }
  
  /**
   * Trigger quantum effect
   * @private
   * @param {string} type - Effect type
   * @param {string|number} target - Effect target
   */
  static #triggerQuantumEffect(type, target) {
    if (!this.#config.useQuantumEffects) return;
    
    // Use NeuralBus to trigger glitch effect
    if (this.#neuralBusConnected) {
      NeuralBus.publish('glitch:trigger', {
        intensity: 0.7,
        duration: 300,
        mode: type === 'mutation' ? 'rgb-shift' : 'jitter',
        source: 'cart-system',
        target: target
      });
    }
    
    // Apply CSS-based effects directly to cart elements
    const drawer = document.querySelector(this.#config.cartDrawerSelector);
    if (drawer) {
      drawer.classList.add('quantum-effect');
      
      setTimeout(() => {
        drawer.classList.remove('quantum-effect');
      }, 500);
    }
  }
  
  /**
   * Apply quantum effect to a cart item
   * @private
   * @param {HTMLElement} itemElement - Cart item element
   */
  static #applyItemQuantumEffect(itemElement) {
    if (!this.#config.useQuantumEffects) return;
    
    // Add quantum data attribute for CSS targeting
    itemElement.setAttribute('data-quantum', 'true');
    
    // Add glitch class with small delay for entrance effect
    setTimeout(() => {
      itemElement.classList.add('quantum-entrance');
      
      // Remove class after animation completes
      setTimeout(() => {
        itemElement.classList.remove('quantum-entrance');
      }, 1000);
    }, Math.random() * 200);
  }
  
  /**
   * Check for holographic preview support
   * @private
   */
  static #checkHolographicSupport() {
    if (!this.#config.useHolographicPreviews) {
      this.#holographicPreviewsSupported = false;
      return;
    }
    
    // Check for WebGL support (required for holographics)
    try {
      const canvas = document.createElement('canvas');
      this.#holographicPreviewsSupported = !!(
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
      );
      
      // Check for hologram renderer module
      if (this.#holographicPreviewsSupported) {
        // Dynamically import the hologram renderer if available
        import('./hologram-renderer.js')
          .then(module => {
            this.#holographicRenderer = module.HologramRenderer;
            if (this.#config.debug) {
              console.log('[CartSystem] Holographic previews enabled');
            }
          })
          .catch(error => {
            console.warn('Hologram renderer not available:', error);
            this.#holographicPreviewsSupported = false;
          });
      }
    } catch (e) {
      this.#holographicPreviewsSupported = false;
    }
  }
  
  /**
   * Initialize holographic previews
   * @private
   */
  static #initHolographicPreviews() {
    if (!this.#holographicPreviewsSupported || !this.#holographicRenderer) return;
    
    const previewContainer = document.querySelector(this.#config.cartPreviewContainerSelector);
    if (!previewContainer) return;
    
    // Initialize hologram renderer
    this.#holographicRenderer.initialize({
      container: previewContainer,
      width: previewContainer.clientWidth,
      height: previewContainer.clientHeight
    });
    
    // Show active product if available
    if (this.#activeProduct) {
      this.#updateHolographicPreview(this.#activeProduct);
    }
  }
  
  /**
   * Update holographic preview with new product
   * @private
   * @param {Object} product - Product data
   */
  static #updateHolographicPreview(product) {
    if (!this.#holographicPreviewsSupported || !this.#holographicRenderer) return;
    
    // Find model URL in product data
    const modelUrl = this.#findProductModelUrl(product);
    if (!modelUrl) return;
    
    // Load the 3D model
    this.#holographicRenderer.loadModel(modelUrl, {
      product: product,
      scale: 1.0,
      position: [0, 0, 0],
      rotation: [0, 0, 0]
    });
  }
  
  /**
   * Find 3D model URL in product data
   * @private
   * @param {Object} product - Product data
   * @returns {string|null} Model URL or null if not found
   */
  static #findProductModelUrl(product) {
    if (!product) return null;
    
    // Check for model in media
    if (product.media && Array.isArray(product.media)) {
      const modelMedia = product.media.find(m => m.media_type === 'model');
      if (modelMedia && modelMedia.sources) {
        const glbSource = modelMedia.sources.find(s => s.format === 'glb');
        if (glbSource) return glbSource.url;
      }
    }
    
    // Fallback: look for model in metafields
    if (product.metafields) {
      const modelField = product.metafields.find(
        m => m.namespace === '3d' && m.key === 'model'
      );
      if (modelField && modelField.value) return modelField.value;
    }
    
    return null;
  }
  
  /**
   * Handle cart events and sync with NeuralBus
   * @private
   * @param {Object} data - Event data
   */
  static #handleCartItemAdded(data) {
    if (!data || !data.item) return;
    
    // Extract product ID
    const productId = data.item.product_id;
    
    // Determine the natural mutation profile based on product tags or collection
    let mutationProfile = 'CyberLotus'; // Default profile
    
    // Check product tags if available in the item data
    if (data.item.tags && Array.isArray(data.item.tags)) {
      if (data.item.tags.includes('voidbloom')) {
        mutationProfile = 'VoidBloom';
      } else if (data.item.tags.includes('obsidianbloom')) {
        mutationProfile = 'ObsidianBloom';
      } else if (data.item.tags.includes('neonvortex')) {
        mutationProfile = 'NeonVortex';
      }
    }
    
    // Register the product-mutation association in our internal registry
    this.#productMutationRegistry.set(productId.toString(), {
      profile: mutationProfile,
      timestamp: Date.now(),
      variantId: data.item.variant_id,
      quantity: data.item.quantity
    });
    
    // Publish quantum mutation event
    NeuralBus.publish('quantum:mutation', {
      source: 'cart-system',
      target: 'product',
      productId: productId,
      profile: mutationProfile,
      action: 'cart-add',
      cartKey: data.item.key,
      timestamp: Date.now()
    });
    
    // Update visualizer if it exists
    if (window.QuantumVisualizer) {
      window.QuantumVisualizer.updateProduct(productId, mutationProfile, 'cart-add');
    }
  }
}

// Auto-initialize when loaded if in browser environment
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    CartSystem.initialize({
      debug: window.location.search.includes('debug=true')
    });
    
    // Expose to global scope for external access
    window.CartSystem = CartSystem;
  });
}