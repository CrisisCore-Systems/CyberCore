{% comment %}
  Quantum Layer - VoidBloom's recursive visual effects system
  @MutationCompatible: All Profiles
  @StrategyProfile: quantum-entangled
  @Version: 3.7.1
{% endcomment %}

<div class="quantum-layer" data-phase="{{ settings.default_memory_phase }}" data-trauma="{{ settings.default_trauma_type }}">
  <div class="quantum-background"></div>
  <div class="quantum-particles"></div>
  <div class="quantum-glitch"></div>
</div>

{% if customer %}
  {% assign quantum_registry = customer.metafields.voidbloom_quantum_config.registry | json %}
  {% assign nonce_registry = customer.metafields.voidbloom_memory_protected.nonce | json %}
{% else %}
  {% assign quantum_registry = '{}' %}
  {% assign nonce_registry = '{}' %}
{% endif %}

{% if quantum_registry %}
<script type="application/json" id="quantum-registry-data">
  {{ quantum_registry }}
</script>
{% endif %}

{% if nonce_registry %}
<script type="application/json" id="nonce-registry-data">
  {{ nonce_registry }}
</script>
{% endif %}

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize quantum layer
    const quantumLayer = {
      init: function() {
        // Check for user's trauma profile
        this.checkTraumaProfile();

        // Setup event listeners
        this.setupEvents();

        // Initialize effects
        this.initEffects();
      },

      checkTraumaProfile: function() {
        const userTrauma = localStorage.getItem('voidbloom_primary_trauma');
        const coherenceBaseline = parseFloat(localStorage.getItem('voidbloom_coherence_baseline') || '0.5');

        if (userTrauma) {
          // Update the trauma pattern
          const traumaPattern = document.querySelector('.trauma-pattern');
          if (traumaPattern) {
            traumaPattern.setAttribute('data-trauma-type', userTrauma);
            traumaPattern.style.setProperty('--trauma-intensity', coherenceBaseline);
          }

          // Update quantum layer
          document.querySelector('.quantum-layer').setAttribute('data-trauma', userTrauma);
        }
      },

      setupEvents: function() {
        // Listen for trauma events from Neural Bus
        if (window.NeuralBus) {
          NeuralBus.subscribe('trauma:activated', this.handleTraumaEvent.bind(this));
          NeuralBus.subscribe('phase:changed', this.handlePhaseChange.bind(this));
          NeuralBus.subscribe('quantum:mutation', this.handleQuantumMutation.bind(this));
        }

        // Handle scroll intensity changes
        window.addEventListener('scroll', this.handleScroll.bind(this), { passive: true });

        // Handle cursor movement for quantum field distortions
        document.addEventListener('mousemove', this.handleMouseMove.bind(this), { passive: true });
      },

      initEffects: function() {
        // Initialize WebGL effects if available
        if (window.QEARWebGLBridge) {
          this.qearBridge = new QEARWebGLBridge({
            targetSelector: '.quantum-particles',
            traumaType: document.querySelector('.quantum-layer').getAttribute('data-trauma'),
            intensity: parseFloat(localStorage.getItem('voidbloom_coherence_baseline') || '0.5')
          });
          this.qearBridge.initialize();
        }

        // Initialize glitch effects
        if (window.GlitchEngine) {
          this.glitchEngine = new GlitchEngine({
            targetSelector: '.quantum-glitch',
            autoStart: false,
            profile: 'quantum'
          });
        }
      },

      handleTraumaEvent: function(data) {
        if (!data || !data.type) return;

        // Update class on quantum layer
        const quantumLayer = document.querySelector('.quantum-layer');

        // Remove previous trauma classes
        ["abandonment", "fragmentation", "recursion", "surveillance", "displacement", "dissolution"].forEach(trauma => {
          quantumLayer.classList.remove(`trauma-${trauma}`);
        });

        // Add new trauma class
        quantumLayer.classList.add(`trauma-${data.type}`);
        quantumLayer.setAttribute('data-trauma', data.type);

        // Trigger glitch effect for transition
        if (this.glitchEngine) {
          this.glitchEngine.start({
            duration: 1000,
            intensity: data.intensity || 0.5
          });
        }

        // Update WebGL effects
        if (this.qearBridge) {
          this.qearBridge.triggerTrauma(data.type, data.intensity || 0.5);
        }
      },

      handlePhaseChange: function(data) {
        if (!data || !data.phase) return;

        // Update data attribute
        document.querySelector('.quantum-layer').setAttribute('data-phase', data.phase);

        // Trigger phase-specific effects
        // In a real implementation, this would animate the transition
        document.body.classList.add('phase-transitioning');

        setTimeout(() => {
          document.body.classList.remove('phase-transitioning');
        }, 2000);
      },

      handleQuantumMutation: function(data) {
        // Handle quantum mutation events from QEAR
        if (!data) return;

        // Trigger glitch effect for mutation
        if (this.glitchEngine) {
          this.glitchEngine.start({
            duration: 500,
            intensity: data.intensity || 0.3,
            profile: 'mutation'
          });
        }
      },

      handleScroll: function() {
        // Calculate scroll position as percentage
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        const scrollPercent = scrollTop / scrollHeight;

        // Adjust quantum effects based on scroll
        document.querySelector('.quantum-background').style.setProperty('--scroll-intensity', scrollPercent);

        // Trigger subtle glitches on scroll breakpoints
        if (scrollPercent > 0.3 && scrollPercent < 0.32 && this.glitchEngine) {
          this.glitchEngine.triggerMicroGlitch();
        }
        if (scrollPercent > 0.7 && scrollPercent < 0.72 && this.glitchEngine) {
          this.glitchEngine.triggerMicroGlitch();
        }
      },

      handleMouseMove: function(e) {
        // Get mouse position
        const mouseX = e.clientX / window.innerWidth;
        const mouseY = e.clientY / window.innerHeight;

        // Apply distortion to quantum field
        document.querySelector('.quantum-background').style.setProperty('--mouse-x', mouseX);
        document.querySelector('.quantum-background').style.setProperty('--mouse-y', mouseY);
      }
    };

    // Initialize if quantum effects are enabled
    if (window.voidBloom && window.voidBloom.config.quantumEffects) {
      quantumLayer.init();
    }
  });
</script>

<style>
  /* Quantum Layer Base Styles */
  .quantum-layer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
  }

  .quantum-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--phase-background);
    opacity: 0.8;
    --scroll-intensity: 0;
    --mouse-x: 0.5;
    --mouse-y: 0.5;
  }

  .quantum-particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .quantum-glitch {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    mix-blend-mode: overlay;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  /* Phase-specific backgrounds */
  .quantum-layer[data-phase="cyber-lotus"] .quantum-background {
    background: radial-gradient(
      ellipse at calc(var(--mouse-x) * 100%) calc(var(--mouse-y) * 100%),
      rgba(80, 255, 64, 0.15),
      rgba(19, 0, 25, 0.9)
    );
  }

  .quantum-layer[data-phase="alien-flora"] .quantum-background {
    background: radial-gradient(
      ellipse at calc(var(--mouse-x) * 100%) calc(var(--mouse-y) * 100%),
      rgba(255, 153, 0, 0.15),
      rgba(25, 15, 0, 0.9)
    );
  }

  .quantum-layer[data-phase="rolling-virus"] .quantum-background {
    background: radial-gradient(
      ellipse at calc(var(--mouse-x) * 100%) calc(var(--mouse-y) * 100%),
      rgba(255, 33, 80, 0.15),
      rgba(51, 0, 17, 0.9)
    );
  }

  /* Trauma-specific effects */
  .quantum-layer[data-trauma="abandonment"] .quantum-background {
    animation: quantum-pulse-abandonment 8s ease-in-out infinite;
  }

  .quantum-layer[data-trauma="fragmentation"] .quantum-background {
    animation: quantum-shatter 10s linear infinite;
  }

  .quantum-layer[data-trauma="recursion"] .quantum-background {
    animation: quantum-recursion 12s linear infinite;
  }

  .quantum-layer[data-trauma="surveillance"] .quantum-background {
    animation: quantum-scan 6s linear infinite;
  }

  .quantum-layer[data-trauma="displacement"] .quantum-background {
    animation: quantum-displace 15s ease-in-out infinite;
  }

  .quantum-layer[data-trauma="dissolution"] .quantum-background {
    animation: quantum-dissolve 20s ease-in-out infinite;
  }

  /* Animation Keyframes */
  @keyframes quantum-pulse-abandonment {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  @keyframes quantum-shatter {
    0% { transform: translate(0) rotate(0); }
    25% { transform: translate(5px, -3px) rotate(1deg); }
    50% { transform: translate(-2px, 5px) rotate(-1deg); }
    75% { transform: translate(-5px, -2px) rotate(1deg); }
    100% { transform: translate(0) rotate(0); }
  }

  @keyframes quantum-recursion {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }

  @keyframes quantum-scan {
    0% { background-position: 0 0; }
    100% { background-position: 0 100%; }
  }

  @keyframes quantum-displace {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
  }

  @keyframes quantum-dissolve {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 0.4; }
  }

  /* Phase transition animation */
  .phase-transitioning .quantum-background {
    animation: phase-transition 2s ease-in-out;
  }

  @keyframes phase-transition {
    0% { filter: brightness(1) contrast(1); }
    25% { filter: brightness(1.5) contrast(1.2); }
    50% { filter: brightness(0.8) contrast(1.5) hue-rotate(15deg); }
    75% { filter: brightness(1.2) contrast(0.9) hue-rotate(-15deg); }
    100% { filter: brightness(1) contrast(1); }
  }
</style>
