# CYBERCORE QUANTUM FORGE v2.2.1
# Universal PowerShell Edition - Syntax-Corrected

$global:QuantumSignature = "// Generated by VoidBloom Neural Forge v2.2.1 //"
$global:RequiredDirs = @('layout', 'sections', 'snippets', 'assets', 'config', 'blueprints')
$global:QuantumEnvironment = $null

class QuantumRegistry {
    static [hashtable] $Artifacts = @{}
    static [string] $RegistryPath = "./config/quantum-registry.json"
    
    static [void] UpdateRegistry([string]$file, [string]$hash, [string]$type, [string[]]$mutationCompatible) {
        [QuantumRegistry]::Artifacts[$file] = @{
            Hash = $hash
            Type = $type
            Created = [DateTime]::Now.ToString("o")
            MutationCompatible = $mutationCompatible
        }
        # Fix: Store the path in a separate variable first
        $regPath = [QuantumRegistry]::RegistryPath 
        [QuantumRegistry]::Artifacts | ConvertTo-Json -Depth 3 | Set-Content $regPath
    }
}

function Initialize-QuantumEnvironment {
    param(
        [Parameter(Mandatory)]
        [ValidateSet("Production","Staging","Development")]
        [string]$Environment
    )

    $global:QuantumEnvironment = $Environment
    
    # Create directory structure
    New-Item -Path $global:RequiredDirs -ItemType Directory -Force | Out-Null

    # Initialize nonce registry
    $nonceRegistry = @{
        Production  = [Convert]::ToBase64String((1..32 | ForEach-Object { Get-Random -Minimum 0 -Maximum 255 }))
        Staging     = [Convert]::ToBase64String((1..32 | ForEach-Object { Get-Random -Minimum 0 -Maximum 255 }))
        Development = "DEV-NONCE-ALLOW-INSECURE"
    }
    $nonceRegistry | ConvertTo-Json | Out-File "./config/nonce-registry.json"

    # Reset artifact registry
    [QuantumRegistry]::Artifacts = @{}
}

function New-QuantumFile {
    param(
        [Parameter(Mandatory)]
        [string]$Path,
        [Parameter(Mandatory)]
        [string]$Content,
        [string]$Type = 'liquid',
        [string[]]$Dependencies = @(),
        [switch]$DryRun,
        [string[]]$MutationCompatible = @()
    )

    # Ensure parent directory exists
    $parentDir = Split-Path $Path -Parent
    if (-not (Test-Path $parentDir)) {
        New-Item -Path $parentDir -ItemType Directory -Force | Out-Null
    }

    # Check dependencies
    $missingDeps = $Dependencies | Where-Object { -not (Test-Path $_) }
    if ($missingDeps) {
        throw "Quantum dependency collapse: Missing $($missingDeps -join ', ')"
    }

    # Build content with mutation headers
    $fullContent = @(
        "{% comment %}"
        "@MutationCompatible: $($MutationCompatible -join ', ')"
        "@StrategyProfile: quantum-entangled"
        "{% endcomment %}"
        $global:QuantumSignature
        "// Entangled: $(Get-Date -Format 'o') //"
        $Content
    ) -join "`n"

    # Dry-run mode
    if ($DryRun) {
        Write-Host "[DryRun] Would forge: $Path" -ForegroundColor Cyan
        return
    }

    # Validate content
    $validation = Test-QuantumBlueprint -Content $fullContent -Type $Type
    if (-not $validation.Valid) {
        throw "Quantum validation failure: $($validation.Message)"
    }

    # Create file
    Set-Content -Path $Path -Value $fullContent -Encoding UTF8 -NoNewline

    # Verify write integrity
    if ((Get-Content $Path -Raw) -ne $fullContent) {
        Remove-Item $Path -Force
        throw "Quantum file collapse in $Path"
    }

    # Register artifact
    $fileHash = (Get-FileHash $Path -Algorithm SHA256).Hash
    [QuantumRegistry]::UpdateRegistry($Path, $fileHash, $Type, $MutationCompatible)
}

function Test-QuantumBlueprint {
    param(
        [string]$Content,
        [string]$Type
    )

    $report = @{ Valid = $true; Message = '' }

    # Liquid validation
    if ($Type -eq 'liquid') {
        # FIXED: Properly escape regex patterns
        if ($Content -match '<script(?!.*nonce=["'']{{[^}]+}}["''])') {
            $report.Valid = $false
            $report.Message = "CSP nonce violation in script tag"
        }

        if ($Content -match '"name":\s*"(.{26,})"') {
            $report.Valid = $false
            $report.Message = "Schema name exceeds 25 characters: $($matches[1])"
        }
    }

    # CSS validation
    if ($Type -eq 'css' -and -not ($Content -match '--glitch-intensity')) {
        $report.Valid = $false
        $report.Message = "Missing glitch-intensity CSS variable"
    }

    # JS validation
    if ($Type -eq 'js' -and $Content -match 'NeuralBus' -and -not (
        $Content -match 'import { NeuralBus }' -or 
        $Content -match 'export class NeuralBus'
    )) {
        $report.Valid = $false
        $report.Message = "NeuralBus dependency missing in JS module"
    }

    return $report
}

function Test-QuantumTemplate {
    param(
        [Parameter(Mandatory)]
        [string]$Content
    )
    
    $requiredPatterns = @(
        '{% #cybercore-nonce: \{\{ (nonce|csp_nonce) \}\} %}',
        '{{\s*content_for_header\s*}}'
    )
    
    $result = @{
        Valid = $true
        Violations = @()
    }
    
    foreach ($pattern in $requiredPatterns) {
        if (-not ($Content -match $pattern)) {
            $result.Valid = $false
            $result.Violations += "Missing required pattern: $pattern"
        }
    }
    
    # FIXED: Properly escape regex patterns for PowerShell
    if ($Content -match '<script(?!.*nonce=["'']{{[^}]+}}["'']).*?>') {
        $result.Valid = $false
        $result.Violations += "Script tag without nonce attribute detected"
    }
    
    return $result
}

function Invoke-QuantumBlueprint {
    param(
        [Parameter(Mandatory)]
        [string]$BlueprintPath,
        [switch]$DryRun
    )

    # Load and convert blueprint
    $raw = ConvertFrom-Json (Get-Content $BlueprintPath -Raw)
    $blueprint = @{}
    $raw.PSObject.Properties | ForEach-Object {
        $blueprint[$_.Name] = $_.Value
    }

    # Generate components
    foreach ($component in @('sections', 'snippets', 'assets', 'layout')) {
        if (-not $blueprint.ContainsKey($component)) { continue }

        foreach ($file in $blueprint[$component]) {
            $filePath = "./$component/$file"
            
            # Check if file already exists
            if (Test-Path $filePath) {
                Write-Host "[Using existing file: $filePath]" -ForegroundColor Cyan
                $content = Get-Content $filePath -Raw
                
                # Calculate hash and update registry
                $fileHash = (Get-FileHash $filePath -Algorithm SHA256).Hash
                [QuantumRegistry]::UpdateRegistry($filePath, $fileHash, ($file.Split('.')[-1]), @('CyberLotus', 'ObsidianBloom'))
            }
            else {
                # For new files, use built-in templates
                $content = switch ($file) {
                    'theme.liquid' { $themeLiquid }
                    'quantum-header.liquid' { $quantumHeader }
                    'neural-bus.js' { $neuralBusJS }
                    default { throw "Unknown blueprint component: $file" }
                }
                
                # Create new file
                New-QuantumFile -Path $filePath -Content $content -DryRun:$DryRun `
                    -MutationCompatible @('CyberLotus', 'ObsidianBloom') -Type ($file.Split('.')[-1])
            }
        }
    }
}

function Export-QuantumBlueprint {
    param(
        [Parameter(Mandatory)]
        [string]$OutputPath,
        [ValidateSet("Full","Minimal")]
        [string]$DetailLevel = "Full"
    )

    $blueprint = @{}
    foreach ($filePath in [QuantumRegistry]::Artifacts.Keys) {
        $dir = (Split-Path $filePath -Parent).Replace(".","").TrimStart('/')
        $file = Split-Path $filePath -Leaf
        
        if (-not $blueprint.ContainsKey($dir)) {
            $blueprint[$dir] = @()
        }

        $entry = if ($DetailLevel -eq "Full") {
            @{
                file = $file
                hash = [QuantumRegistry]::Artifacts[$filePath].Hash
                mutations = [QuantumRegistry]::Artifacts[$filePath].MutationCompatible
            }
        } else {
            $file
        }

        $blueprint[$dir] += $entry
    }

    # Add metadata
    $blueprint["_meta"] = @{
        generated = Get-Date -Format 'o'
        environment = $global:QuantumEnvironment
        nonce_source = if ($global:QuantumEnvironment -eq "Development") { "INSECURE" } else { "SECURE_ROTATING" }
    }

    $blueprint | ConvertTo-Json -Depth 5 | Out-File $OutputPath
    Write-Host "Blueprint exported to $OutputPath" -ForegroundColor Cyan
}

function Register-QuantumBlueprint {
    param(
        [Parameter(Mandatory)]
        [string]$Path,
        [switch]$RequireSignature,
        [string]$Author = $env:USERNAME,
        [string]$Description = ""
    )
    
    if (-not (Test-Path $Path)) {
        throw "Blueprint not found at path: $Path"
    }
    
    try {
        $blueprint = Get-Content $Path -Raw | ConvertFrom-Json
    }
    catch {
        throw "Invalid blueprint JSON format: $($_.Exception.Message)"
    }
    
    # Add metadata
    $metaProperties = @{
        registered = [DateTime]::Now.ToString("o")
        author = $Author
        description = $Description
        signature = if ($RequireSignature) {
            $fileBytes = [System.IO.File]::ReadAllBytes($Path)
            $hashBytes = [System.Security.Cryptography.SHA256]::Create().ComputeHash($fileBytes)
            [Convert]::ToBase64String($hashBytes)
        } else { "" }
    }
    
    # Create metadata object
    $meta = New-Object PSObject
    foreach ($key in $metaProperties.Keys) {
        Add-Member -InputObject $meta -MemberType NoteProperty -Name $key -Value $metaProperties[$key]
    }
    
    # Add metadata to blueprint
    Add-Member -InputObject $blueprint -MemberType NoteProperty -Name "_meta" -Value $meta -Force
    
    # Write updated blueprint
    $blueprint | ConvertTo-Json -Depth 5 | Set-Content $Path
    
    Write-Host "[Blueprint registered: $Path]" -ForegroundColor Green
    if ($RequireSignature) {
        Write-Host "[Signature: $($metaProperties.signature.Substring(0, 12))...]" -ForegroundColor Cyan
    }
    
    return $blueprint
}

function New-QuantumEntanglement {
    param(
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [string[]]$Dependencies,
        [string]$EntanglementLevel = "Strong",
        [switch]$RequireExistence
    )
    
    $componentPath = $null
    
    # Find component file
    foreach ($dir in @('sections', 'snippets', 'assets', 'layout')) {
        $possiblePath = "./$dir/$Component"
        if (-not $possiblePath.EndsWith('.liquid') -and $dir -ne 'assets') {
            $possiblePath += '.liquid'
        }
        
        if (Test-Path $possiblePath) {
            $componentPath = $possiblePath
            break
        }
    }
    
    if (-not $componentPath) {
        if ($RequireExistence) {
            throw "Component not found: $Component"
        }
        Write-Host "[Warning: Component not found: $Component]" -ForegroundColor Yellow
        return $false
    }
    
    # Validate dependencies
    $missingDeps = @()
    $validDeps = @()
    
    foreach ($dep in $Dependencies) {
        $found = $false
        foreach ($dir in @('sections', 'snippets', 'assets', 'layout')) {
            $possiblePath = "./$dir/$dep"
            if (-not $possiblePath.EndsWith('.liquid') -and -not $possiblePath.EndsWith('.js') -and $dir -ne 'assets') {
                $possiblePath += '.liquid'
            }
            
            if (Test-Path $possiblePath) {
                $found = $true
                $validDeps += $possiblePath
                break
            }
        }
        
        if (-not $found) {
            $missingDeps += $dep
        }
    }
    
    if ($missingDeps.Count -gt 0 -and $RequireExistence) {
        throw "Missing dependencies: $($missingDeps -join ', ')"
    }
    
    # Create entanglement record - in a real implementation, this would be saved to a config file
    $entanglement = @{
        Component = $componentPath
        Dependencies = $validDeps
        Level = $EntanglementLevel
        Created = [DateTime]::Now.ToString("o")
    }
    
    # In a full implementation, this would update an entanglement registry file
    # For now, just display the entanglement
    Write-Host "[Quantum Entanglement Created]" -ForegroundColor Cyan
    Write-Host "Component: $componentPath" -ForegroundColor Green
    Write-Host "Dependencies: $($validDeps -join ', ')" -ForegroundColor Green
    
    if ($missingDeps.Count -gt 0) {
        Write-Host "Missing Dependencies: $($missingDeps -join ', ')" -ForegroundColor Yellow
    }
    
    return $entanglement
}

function Split-QuantumRegistry {
    param(
        [Parameter(Mandatory)]
        [ValidateSet("ComponentType", "MutationProfile", "TimeStamp")]
        [string]$Strategy,
        [Parameter(Mandatory)]
        [string]$Output,
        [switch]$KeepOriginal
    )
    
    # Ensure output directory exists
    if (-not (Test-Path $Output)) {
        New-Item -Path $Output -ItemType Directory -Force | Out-Null
    }
    
    # Load current registry
    $registryPath = [QuantumRegistry]::RegistryPath
    if (-not (Test-Path $registryPath)) {
        throw "Quantum registry not found at $registryPath"
    }
    
    try {
        $registry = Get-Content $registryPath -Raw | ConvertFrom-Json
    }
    catch {
        throw "Invalid registry format: $($_.Exception.Message)"
    }
    
    # Prepare partitioned registries
    $partitions = @{}
    
    # Process registry entries based on strategy
    foreach ($file in $registry.PSObject.Properties.Name) {
        $entry = $registry."$file"
        
        # Determine partition key based on strategy
        $partitionKey = switch ($Strategy) {
            "ComponentType" {
                $ext = [System.IO.Path]::GetExtension($file)
                if ([string]::IsNullOrEmpty($ext)) {
                    "unknown"
                } else {
                    $ext.Substring(1).ToLower() # Remove the dot
                }
            }
            "MutationProfile" {
                if ($entry.MutationCompatible -and $entry.MutationCompatible.Count -gt 0) {
                    $entry.MutationCompatible[0] # Use first mutation profile
                } else {
                    "default"
                }
            }
            "TimeStamp" {
                [DateTime]::Parse($entry.Created).ToString("yyyy-MM-dd")
            }
        }
        
        # Create partition if it doesn't exist
        if (-not $partitions.ContainsKey($partitionKey)) {
            $partitions[$partitionKey] = [ordered]@{}
        }
        
        # Add entry to partition
        $partitions[$partitionKey][$file] = $entry
    }
    
    # Write partitioned registries
    foreach ($key in $partitions.Keys) {
        $partitionPath = Join-Path $Output "$key-registry.json"
        $partitions[$key] | ConvertTo-Json -Depth 5 | Set-Content $partitionPath
        # FIXED: Properly format string output
        Write-Host "[Registry partition created: $key ($($partitions[$key].Count) entries)]" -ForegroundColor Green
    }
    
    # Create a manifest file
    $manifest = @{
        Strategy = $Strategy
        Created = [DateTime]::Now.ToString("o")
        Partitions = @{}
    }
    
    foreach ($key in $partitions.Keys) {
        $manifest.Partitions[$key] = @{
            Path = "$key-registry.json"
            Count = $partitions[$key].Count
        }
    }
    
    $manifestPath = Join-Path $Output "registry-manifest.json"
    $manifest | ConvertTo-Json -Depth 5 | Set-Content $manifestPath
    
    # Remove original registry if requested
    if (-not $KeepOriginal) {
        Remove-Item $registryPath -Force
        Write-Host "[Original registry removed]" -ForegroundColor Yellow
    }
    
    Write-Host "`n[Registry successfully partitioned using $Strategy strategy]" -ForegroundColor Cyan
    Write-Host "[Manifest created at $manifestPath]" -ForegroundColor Green
    
    return $manifest
}

# Core Templates - Using Here-Strings to avoid PowerShell parsing issues with Liquid templates
$themeLiquid = @'
<!DOCTYPE html>
<html lang="{{ locale.iso_code }}" data-quantum-state="stable">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'nonce-{{ csp_nonce }}' 'strict-dynamic'; style-src 'self' 'unsafe-inline';">
  {{ content_for_header }}
</head>
<body>
  {% section 'quantum-header' %}
  <main id="QuantumMain">{{ content_for_layout }}</main>
</body>
</html>
'@

$quantumHeader = @'
<header class="quantum-core" data-neural-node>
  <nav class="glitch-nav">
    {% for link in linklists.main-menu.links %}
      <a href="{{ link.url }}" class="quantum-link" data-depth="{{ forloop.index0 }}">
        <span class="glitch-text">{{ link.title }}</span>
      </a>
    {% endfor %}
  </nav>
</header>

{% schema %}
{
  "name": "Quantum Header",
  "settings": [
    {
      "type": "range",
      "id": "glitch_level",
      "label": "Glitch Intensity",
      "min": 0,
      "max": 1,
      "step": 0.1,
      "default": 0.7
    }
  ]
}
{% endschema %}
'@

$neuralBusJS = @'
const NEURAL_VERSION = '3.1.0';
export class NeuralBus {
  static #nonce = '{{ csp_nonce }}';
  
  static handshake() {
    return crypto.subtle.digest('SHA-256', 
      new TextEncoder().encode(this.#nonce))
  }
}
'@

# Persistent storage on exit
Register-EngineEvent -SourceIdentifier PowerShell.Exiting -Action {
    [QuantumRegistry]::Artifacts | ConvertTo-Json -Depth 3 | Out-File [QuantumRegistry]::RegistryPath
}

# Main execution
try {
    Initialize-QuantumEnvironment -Environment Production
    Invoke-QuantumBlueprint -BlueprintPath "./blueprints/core.json"    
    # Write registry file immediately rather than waiting for session exit
    $registryPath = "./config/quantum-registry.json"
    [QuantumRegistry]::Artifacts | ConvertTo-Json -Depth 3 | Out-File $registryPath
    
    Export-QuantumBlueprint -OutputPath "./blueprints/$(Get-Date -Format 'yyyyMMdd-HHmmss').json" -DetailLevel Full
    Write-Host "`n[QUANTUM MATRIX STABLE]" -ForegroundColor Green
    Write-Host "[Entangled Files: $([QuantumRegistry]::Artifacts.Count)]" -ForegroundColor Cyan
    Write-Host "[Nonce System: $((Get-Content "./config/nonce-registry.json" | ConvertFrom-Json).Production.substring(0,12))...]" -ForegroundColor Yellow
    Write-Host "[Registry saved to: $registryPath]" -ForegroundColor Green
}
catch {
    Write-Host "`n[QUANTUM COLLAPSE DETECTED]" -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)"
    Write-Host "Failure Path: $($_.Exception.TargetObject)"
    Write-Host "Stack Trace: $($_.Exception.StackTrace)"
    Write-Host "Error Type: $($_.Exception.GetType().FullName)"
    
    # Check for common errors
    if (-not (Test-Path "./blueprints/core.json")) {
        Write-Host "`n[Missing blueprint file. Please ensure ./blueprints/core.json exists.]" -ForegroundColor Yellow
    }
    
    if ($_.Exception.Message -match "dependency") {
        Write-Host "`n[Dependency error detected. Check that all required files exist.]" -ForegroundColor Yellow
    }
    
    exit 1
}